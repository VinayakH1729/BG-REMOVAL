(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))a(i);new MutationObserver(i=>{for(const l of i)if(l.type==="childList")for(const u of l.addedNodes)u.tagName==="LINK"&&u.rel==="modulepreload"&&a(u)}).observe(document,{childList:!0,subtree:!0});function t(i){const l={};return i.integrity&&(l.integrity=i.integrity),i.referrerPolicy&&(l.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?l.credentials="include":i.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function a(i){if(i.ep)return;i.ep=!0;const l=t(i);fetch(i.href,l)}})();function fC(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var cg={exports:{}},pp={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Sv;function hC(){if(Sv)return pp;Sv=1;var e=Symbol.for("react.transitional.element"),n=Symbol.for("react.fragment");function t(a,i,l){var u=null;if(l!==void 0&&(u=""+l),i.key!==void 0&&(u=""+i.key),"key"in i){l={};for(var d in i)d!=="key"&&(l[d]=i[d])}else l=i;return i=l.ref,{$$typeof:e,type:a,key:u,ref:i!==void 0?i:null,props:l}}return pp.Fragment=n,pp.jsx=t,pp.jsxs=t,pp}var Cv;function pC(){return Cv||(Cv=1,cg.exports=hC()),cg.exports}var rt=pC(),dg={exports:{}},on={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Pv;function mC(){if(Pv)return on;Pv=1;var e=Symbol.for("react.transitional.element"),n=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),l=Symbol.for("react.consumer"),u=Symbol.for("react.context"),d=Symbol.for("react.forward_ref"),f=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),_=Symbol.for("react.lazy"),m=Symbol.iterator;function p(q){return q===null||typeof q!="object"?null:(q=m&&q[m]||q["@@iterator"],typeof q=="function"?q:null)}var y={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},v=Object.assign,x={};function L(q,B,R){this.props=q,this.context=B,this.refs=x,this.updater=R||y}L.prototype.isReactComponent={},L.prototype.setState=function(q,B){if(typeof q!="object"&&typeof q!="function"&&q!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,q,B,"setState")},L.prototype.forceUpdate=function(q){this.updater.enqueueForceUpdate(this,q,"forceUpdate")};function T(){}T.prototype=L.prototype;function E(q,B,R){this.props=q,this.context=B,this.refs=x,this.updater=R||y}var I=E.prototype=new T;I.constructor=E,v(I,L.prototype),I.isPureReactComponent=!0;var P=Array.isArray,S={H:null,A:null,T:null,S:null,V:null},k=Object.prototype.hasOwnProperty;function C(q,B,R,Q,G,fe){return R=fe.ref,{$$typeof:e,type:q,key:B,ref:R!==void 0?R:null,props:fe}}function D(q,B){return C(q.type,B,void 0,void 0,void 0,q.props)}function V(q){return typeof q=="object"&&q!==null&&q.$$typeof===e}function U(q){var B={"=":"=0",":":"=2"};return"$"+q.replace(/[=:]/g,function(R){return B[R]})}var ne=/\/+/g;function ee(q,B){return typeof q=="object"&&q!==null&&q.key!=null?U(""+q.key):B.toString(36)}function H(){}function oe(q){switch(q.status){case"fulfilled":return q.value;case"rejected":throw q.reason;default:switch(typeof q.status=="string"?q.then(H,H):(q.status="pending",q.then(function(B){q.status==="pending"&&(q.status="fulfilled",q.value=B)},function(B){q.status==="pending"&&(q.status="rejected",q.reason=B)})),q.status){case"fulfilled":return q.value;case"rejected":throw q.reason}}throw q}function ae(q,B,R,Q,G){var fe=typeof q;(fe==="undefined"||fe==="boolean")&&(q=null);var Te=!1;if(q===null)Te=!0;else switch(fe){case"bigint":case"string":case"number":Te=!0;break;case"object":switch(q.$$typeof){case e:case n:Te=!0;break;case _:return Te=q._init,ae(Te(q._payload),B,R,Q,G)}}if(Te)return G=G(q),Te=Q===""?"."+ee(q,0):Q,P(G)?(R="",Te!=null&&(R=Te.replace(ne,"$&/")+"/"),ae(G,B,R,"",function(ft){return ft})):G!=null&&(V(G)&&(G=D(G,R+(G.key==null||q&&q.key===G.key?"":(""+G.key).replace(ne,"$&/")+"/")+Te)),B.push(G)),1;Te=0;var ze=Q===""?".":Q+":";if(P(q))for(var Ue=0;Ue<q.length;Ue++)Q=q[Ue],fe=ze+ee(Q,Ue),Te+=ae(Q,B,R,fe,G);else if(Ue=p(q),typeof Ue=="function")for(q=Ue.call(q),Ue=0;!(Q=q.next()).done;)Q=Q.value,fe=ze+ee(Q,Ue++),Te+=ae(Q,B,R,fe,G);else if(fe==="object"){if(typeof q.then=="function")return ae(oe(q),B,R,Q,G);throw B=String(q),Error("Objects are not valid as a React child (found: "+(B==="[object Object]"?"object with keys {"+Object.keys(q).join(", ")+"}":B)+"). If you meant to render a collection of children, use an array instead.")}return Te}function W(q,B,R){if(q==null)return q;var Q=[],G=0;return ae(q,Q,"","",function(fe){return B.call(R,fe,G++)}),Q}function te(q){if(q._status===-1){var B=q._result;B=B(),B.then(function(R){(q._status===0||q._status===-1)&&(q._status=1,q._result=R)},function(R){(q._status===0||q._status===-1)&&(q._status=2,q._result=R)}),q._status===-1&&(q._status=0,q._result=B)}if(q._status===1)return q._result.default;throw q._result}var ie=typeof reportError=="function"?reportError:function(q){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var B=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof q=="object"&&q!==null&&typeof q.message=="string"?String(q.message):String(q),error:q});if(!window.dispatchEvent(B))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",q);return}console.error(q)};function _e(){}return on.Children={map:W,forEach:function(q,B,R){W(q,function(){B.apply(this,arguments)},R)},count:function(q){var B=0;return W(q,function(){B++}),B},toArray:function(q){return W(q,function(B){return B})||[]},only:function(q){if(!V(q))throw Error("React.Children.only expected to receive a single React element child.");return q}},on.Component=L,on.Fragment=t,on.Profiler=i,on.PureComponent=E,on.StrictMode=a,on.Suspense=f,on.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=S,on.__COMPILER_RUNTIME={__proto__:null,c:function(q){return S.H.useMemoCache(q)}},on.cache=function(q){return function(){return q.apply(null,arguments)}},on.cloneElement=function(q,B,R){if(q==null)throw Error("The argument must be a React element, but you passed "+q+".");var Q=v({},q.props),G=q.key,fe=void 0;if(B!=null)for(Te in B.ref!==void 0&&(fe=void 0),B.key!==void 0&&(G=""+B.key),B)!k.call(B,Te)||Te==="key"||Te==="__self"||Te==="__source"||Te==="ref"&&B.ref===void 0||(Q[Te]=B[Te]);var Te=arguments.length-2;if(Te===1)Q.children=R;else if(1<Te){for(var ze=Array(Te),Ue=0;Ue<Te;Ue++)ze[Ue]=arguments[Ue+2];Q.children=ze}return C(q.type,G,void 0,void 0,fe,Q)},on.createContext=function(q){return q={$$typeof:u,_currentValue:q,_currentValue2:q,_threadCount:0,Provider:null,Consumer:null},q.Provider=q,q.Consumer={$$typeof:l,_context:q},q},on.createElement=function(q,B,R){var Q,G={},fe=null;if(B!=null)for(Q in B.key!==void 0&&(fe=""+B.key),B)k.call(B,Q)&&Q!=="key"&&Q!=="__self"&&Q!=="__source"&&(G[Q]=B[Q]);var Te=arguments.length-2;if(Te===1)G.children=R;else if(1<Te){for(var ze=Array(Te),Ue=0;Ue<Te;Ue++)ze[Ue]=arguments[Ue+2];G.children=ze}if(q&&q.defaultProps)for(Q in Te=q.defaultProps,Te)G[Q]===void 0&&(G[Q]=Te[Q]);return C(q,fe,void 0,void 0,null,G)},on.createRef=function(){return{current:null}},on.forwardRef=function(q){return{$$typeof:d,render:q}},on.isValidElement=V,on.lazy=function(q){return{$$typeof:_,_payload:{_status:-1,_result:q},_init:te}},on.memo=function(q,B){return{$$typeof:h,type:q,compare:B===void 0?null:B}},on.startTransition=function(q){var B=S.T,R={};S.T=R;try{var Q=q(),G=S.S;G!==null&&G(R,Q),typeof Q=="object"&&Q!==null&&typeof Q.then=="function"&&Q.then(_e,ie)}catch(fe){ie(fe)}finally{S.T=B}},on.unstable_useCacheRefresh=function(){return S.H.useCacheRefresh()},on.use=function(q){return S.H.use(q)},on.useActionState=function(q,B,R){return S.H.useActionState(q,B,R)},on.useCallback=function(q,B){return S.H.useCallback(q,B)},on.useContext=function(q){return S.H.useContext(q)},on.useDebugValue=function(){},on.useDeferredValue=function(q,B){return S.H.useDeferredValue(q,B)},on.useEffect=function(q,B,R){var Q=S.H;if(typeof R=="function")throw Error("useEffect CRUD overload is not enabled in this build of React.");return Q.useEffect(q,B)},on.useId=function(){return S.H.useId()},on.useImperativeHandle=function(q,B,R){return S.H.useImperativeHandle(q,B,R)},on.useInsertionEffect=function(q,B){return S.H.useInsertionEffect(q,B)},on.useLayoutEffect=function(q,B){return S.H.useLayoutEffect(q,B)},on.useMemo=function(q,B){return S.H.useMemo(q,B)},on.useOptimistic=function(q,B){return S.H.useOptimistic(q,B)},on.useReducer=function(q,B,R){return S.H.useReducer(q,B,R)},on.useRef=function(q){return S.H.useRef(q)},on.useState=function(q){return S.H.useState(q)},on.useSyncExternalStore=function(q,B,R){return S.H.useSyncExternalStore(q,B,R)},on.useTransition=function(){return S.H.useTransition()},on.version="19.1.1",on}var Av;function A_(){return Av||(Av=1,dg.exports=mC()),dg.exports}var Ce=A_();const We=fC(Ce);var fg={exports:{}},mp={},hg={exports:{}},pg={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var kv;function _C(){return kv||(kv=1,(function(e){function n(W,te){var ie=W.length;W.push(te);e:for(;0<ie;){var _e=ie-1>>>1,q=W[_e];if(0<i(q,te))W[_e]=te,W[ie]=q,ie=_e;else break e}}function t(W){return W.length===0?null:W[0]}function a(W){if(W.length===0)return null;var te=W[0],ie=W.pop();if(ie!==te){W[0]=ie;e:for(var _e=0,q=W.length,B=q>>>1;_e<B;){var R=2*(_e+1)-1,Q=W[R],G=R+1,fe=W[G];if(0>i(Q,ie))G<q&&0>i(fe,Q)?(W[_e]=fe,W[G]=ie,_e=G):(W[_e]=Q,W[R]=ie,_e=R);else if(G<q&&0>i(fe,ie))W[_e]=fe,W[G]=ie,_e=G;else break e}}return te}function i(W,te){var ie=W.sortIndex-te.sortIndex;return ie!==0?ie:W.id-te.id}if(e.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var l=performance;e.unstable_now=function(){return l.now()}}else{var u=Date,d=u.now();e.unstable_now=function(){return u.now()-d}}var f=[],h=[],_=1,m=null,p=3,y=!1,v=!1,x=!1,L=!1,T=typeof setTimeout=="function"?setTimeout:null,E=typeof clearTimeout=="function"?clearTimeout:null,I=typeof setImmediate<"u"?setImmediate:null;function P(W){for(var te=t(h);te!==null;){if(te.callback===null)a(h);else if(te.startTime<=W)a(h),te.sortIndex=te.expirationTime,n(f,te);else break;te=t(h)}}function S(W){if(x=!1,P(W),!v)if(t(f)!==null)v=!0,k||(k=!0,ee());else{var te=t(h);te!==null&&ae(S,te.startTime-W)}}var k=!1,C=-1,D=5,V=-1;function U(){return L?!0:!(e.unstable_now()-V<D)}function ne(){if(L=!1,k){var W=e.unstable_now();V=W;var te=!0;try{e:{v=!1,x&&(x=!1,E(C),C=-1),y=!0;var ie=p;try{t:{for(P(W),m=t(f);m!==null&&!(m.expirationTime>W&&U());){var _e=m.callback;if(typeof _e=="function"){m.callback=null,p=m.priorityLevel;var q=_e(m.expirationTime<=W);if(W=e.unstable_now(),typeof q=="function"){m.callback=q,P(W),te=!0;break t}m===t(f)&&a(f),P(W)}else a(f);m=t(f)}if(m!==null)te=!0;else{var B=t(h);B!==null&&ae(S,B.startTime-W),te=!1}}break e}finally{m=null,p=ie,y=!1}te=void 0}}finally{te?ee():k=!1}}}var ee;if(typeof I=="function")ee=function(){I(ne)};else if(typeof MessageChannel<"u"){var H=new MessageChannel,oe=H.port2;H.port1.onmessage=ne,ee=function(){oe.postMessage(null)}}else ee=function(){T(ne,0)};function ae(W,te){C=T(function(){W(e.unstable_now())},te)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(W){W.callback=null},e.unstable_forceFrameRate=function(W){0>W||125<W?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):D=0<W?Math.floor(1e3/W):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_next=function(W){switch(p){case 1:case 2:case 3:var te=3;break;default:te=p}var ie=p;p=te;try{return W()}finally{p=ie}},e.unstable_requestPaint=function(){L=!0},e.unstable_runWithPriority=function(W,te){switch(W){case 1:case 2:case 3:case 4:case 5:break;default:W=3}var ie=p;p=W;try{return te()}finally{p=ie}},e.unstable_scheduleCallback=function(W,te,ie){var _e=e.unstable_now();switch(typeof ie=="object"&&ie!==null?(ie=ie.delay,ie=typeof ie=="number"&&0<ie?_e+ie:_e):ie=_e,W){case 1:var q=-1;break;case 2:q=250;break;case 5:q=1073741823;break;case 4:q=1e4;break;default:q=5e3}return q=ie+q,W={id:_++,callback:te,priorityLevel:W,startTime:ie,expirationTime:q,sortIndex:-1},ie>_e?(W.sortIndex=ie,n(h,W),t(f)===null&&W===t(h)&&(x?(E(C),C=-1):x=!0,ae(S,ie-_e))):(W.sortIndex=q,n(f,W),v||y||(v=!0,k||(k=!0,ee()))),W},e.unstable_shouldYield=U,e.unstable_wrapCallback=function(W){var te=p;return function(){var ie=p;p=te;try{return W.apply(this,arguments)}finally{p=ie}}}})(pg)),pg}var Ov;function gC(){return Ov||(Ov=1,hg.exports=_C()),hg.exports}var mg={exports:{}},Ms={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var $v;function yC(){if($v)return Ms;$v=1;var e=A_();function n(f){var h="https://react.dev/errors/"+f;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var _=2;_<arguments.length;_++)h+="&args[]="+encodeURIComponent(arguments[_])}return"Minified React error #"+f+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var a={d:{f:t,r:function(){throw Error(n(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},i=Symbol.for("react.portal");function l(f,h,_){var m=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:i,key:m==null?null:""+m,children:f,containerInfo:h,implementation:_}}var u=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function d(f,h){if(f==="font")return"";if(typeof h=="string")return h==="use-credentials"?h:""}return Ms.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=a,Ms.createPortal=function(f,h){var _=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)throw Error(n(299));return l(f,h,null,_)},Ms.flushSync=function(f){var h=u.T,_=a.p;try{if(u.T=null,a.p=2,f)return f()}finally{u.T=h,a.p=_,a.d.f()}},Ms.preconnect=function(f,h){typeof f=="string"&&(h?(h=h.crossOrigin,h=typeof h=="string"?h==="use-credentials"?h:"":void 0):h=null,a.d.C(f,h))},Ms.prefetchDNS=function(f){typeof f=="string"&&a.d.D(f)},Ms.preinit=function(f,h){if(typeof f=="string"&&h&&typeof h.as=="string"){var _=h.as,m=d(_,h.crossOrigin),p=typeof h.integrity=="string"?h.integrity:void 0,y=typeof h.fetchPriority=="string"?h.fetchPriority:void 0;_==="style"?a.d.S(f,typeof h.precedence=="string"?h.precedence:void 0,{crossOrigin:m,integrity:p,fetchPriority:y}):_==="script"&&a.d.X(f,{crossOrigin:m,integrity:p,fetchPriority:y,nonce:typeof h.nonce=="string"?h.nonce:void 0})}},Ms.preinitModule=function(f,h){if(typeof f=="string")if(typeof h=="object"&&h!==null){if(h.as==null||h.as==="script"){var _=d(h.as,h.crossOrigin);a.d.M(f,{crossOrigin:_,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0})}}else h==null&&a.d.M(f)},Ms.preload=function(f,h){if(typeof f=="string"&&typeof h=="object"&&h!==null&&typeof h.as=="string"){var _=h.as,m=d(_,h.crossOrigin);a.d.L(f,_,{crossOrigin:m,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0,type:typeof h.type=="string"?h.type:void 0,fetchPriority:typeof h.fetchPriority=="string"?h.fetchPriority:void 0,referrerPolicy:typeof h.referrerPolicy=="string"?h.referrerPolicy:void 0,imageSrcSet:typeof h.imageSrcSet=="string"?h.imageSrcSet:void 0,imageSizes:typeof h.imageSizes=="string"?h.imageSizes:void 0,media:typeof h.media=="string"?h.media:void 0})}},Ms.preloadModule=function(f,h){if(typeof f=="string")if(h){var _=d(h.as,h.crossOrigin);a.d.m(f,{as:typeof h.as=="string"&&h.as!=="script"?h.as:void 0,crossOrigin:_,integrity:typeof h.integrity=="string"?h.integrity:void 0})}else a.d.m(f)},Ms.requestFormReset=function(f){a.d.r(f)},Ms.unstable_batchedUpdates=function(f,h){return f(h)},Ms.useFormState=function(f,h,_){return u.H.useFormState(f,h,_)},Ms.useFormStatus=function(){return u.H.useHostTransitionStatus()},Ms.version="19.1.1",Ms}var Dv;function Z2(){if(Dv)return mg.exports;Dv=1;function e(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(n){console.error(n)}}return e(),mg.exports=yC(),mg.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Iv;function vC(){if(Iv)return mp;Iv=1;var e=gC(),n=A_(),t=Z2();function a(r){var s="https://react.dev/errors/"+r;if(1<arguments.length){s+="?args[]="+encodeURIComponent(arguments[1]);for(var o=2;o<arguments.length;o++)s+="&args[]="+encodeURIComponent(arguments[o])}return"Minified React error #"+r+"; visit "+s+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function i(r){return!(!r||r.nodeType!==1&&r.nodeType!==9&&r.nodeType!==11)}function l(r){var s=r,o=r;if(r.alternate)for(;s.return;)s=s.return;else{r=s;do s=r,(s.flags&4098)!==0&&(o=s.return),r=s.return;while(r)}return s.tag===3?o:null}function u(r){if(r.tag===13){var s=r.memoizedState;if(s===null&&(r=r.alternate,r!==null&&(s=r.memoizedState)),s!==null)return s.dehydrated}return null}function d(r){if(l(r)!==r)throw Error(a(188))}function f(r){var s=r.alternate;if(!s){if(s=l(r),s===null)throw Error(a(188));return s!==r?null:r}for(var o=r,c=s;;){var g=o.return;if(g===null)break;var M=g.alternate;if(M===null){if(c=g.return,c!==null){o=c;continue}break}if(g.child===M.child){for(M=g.child;M;){if(M===o)return d(g),r;if(M===c)return d(g),s;M=M.sibling}throw Error(a(188))}if(o.return!==c.return)o=g,c=M;else{for(var j=!1,Y=g.child;Y;){if(Y===o){j=!0,o=g,c=M;break}if(Y===c){j=!0,c=g,o=M;break}Y=Y.sibling}if(!j){for(Y=M.child;Y;){if(Y===o){j=!0,o=M,c=g;break}if(Y===c){j=!0,c=M,o=g;break}Y=Y.sibling}if(!j)throw Error(a(189))}}if(o.alternate!==c)throw Error(a(190))}if(o.tag!==3)throw Error(a(188));return o.stateNode.current===o?r:s}function h(r){var s=r.tag;if(s===5||s===26||s===27||s===6)return r;for(r=r.child;r!==null;){if(s=h(r),s!==null)return s;r=r.sibling}return null}var _=Object.assign,m=Symbol.for("react.element"),p=Symbol.for("react.transitional.element"),y=Symbol.for("react.portal"),v=Symbol.for("react.fragment"),x=Symbol.for("react.strict_mode"),L=Symbol.for("react.profiler"),T=Symbol.for("react.provider"),E=Symbol.for("react.consumer"),I=Symbol.for("react.context"),P=Symbol.for("react.forward_ref"),S=Symbol.for("react.suspense"),k=Symbol.for("react.suspense_list"),C=Symbol.for("react.memo"),D=Symbol.for("react.lazy"),V=Symbol.for("react.activity"),U=Symbol.for("react.memo_cache_sentinel"),ne=Symbol.iterator;function ee(r){return r===null||typeof r!="object"?null:(r=ne&&r[ne]||r["@@iterator"],typeof r=="function"?r:null)}var H=Symbol.for("react.client.reference");function oe(r){if(r==null)return null;if(typeof r=="function")return r.$$typeof===H?null:r.displayName||r.name||null;if(typeof r=="string")return r;switch(r){case v:return"Fragment";case L:return"Profiler";case x:return"StrictMode";case S:return"Suspense";case k:return"SuspenseList";case V:return"Activity"}if(typeof r=="object")switch(r.$$typeof){case y:return"Portal";case I:return(r.displayName||"Context")+".Provider";case E:return(r._context.displayName||"Context")+".Consumer";case P:var s=r.render;return r=r.displayName,r||(r=s.displayName||s.name||"",r=r!==""?"ForwardRef("+r+")":"ForwardRef"),r;case C:return s=r.displayName||null,s!==null?s:oe(r.type)||"Memo";case D:s=r._payload,r=r._init;try{return oe(r(s))}catch{}}return null}var ae=Array.isArray,W=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,te=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,ie={pending:!1,data:null,method:null,action:null},_e=[],q=-1;function B(r){return{current:r}}function R(r){0>q||(r.current=_e[q],_e[q]=null,q--)}function Q(r,s){q++,_e[q]=r.current,r.current=s}var G=B(null),fe=B(null),Te=B(null),ze=B(null);function Ue(r,s){switch(Q(Te,s),Q(fe,r),Q(G,null),s.nodeType){case 9:case 11:r=(r=s.documentElement)&&(r=r.namespaceURI)?br(r):0;break;default:if(r=s.tagName,s=s.namespaceURI)s=br(s),r=wr(s,r);else switch(r){case"svg":r=1;break;case"math":r=2;break;default:r=0}}R(G),Q(G,r)}function ft(){R(G),R(fe),R(Te)}function je(r){r.memoizedState!==null&&Q(ze,r);var s=G.current,o=wr(s,r.type);s!==o&&(Q(fe,r),Q(G,o))}function le(r){fe.current===r&&(R(G),R(fe)),ze.current===r&&(R(ze),up._currentValue=ie)}var J=Object.prototype.hasOwnProperty,be=e.unstable_scheduleCallback,Ae=e.unstable_cancelCallback,Ne=e.unstable_shouldYield,De=e.unstable_requestPaint,xe=e.unstable_now,Ve=e.unstable_getCurrentPriorityLevel,Ee=e.unstable_ImmediatePriority,Ge=e.unstable_UserBlockingPriority,Ye=e.unstable_NormalPriority,_t=e.unstable_LowPriority,Re=e.unstable_IdlePriority,xt=e.log,st=e.unstable_setDisableYieldValue,nt=null,ct=null;function pt(r){if(typeof xt=="function"&&st(r),ct&&typeof ct.setStrictMode=="function")try{ct.setStrictMode(nt,r)}catch{}}var lt=Math.clz32?Math.clz32:an,Mt=Math.log,tn=Math.LN2;function an(r){return r>>>=0,r===0?32:31-(Mt(r)/tn|0)|0}var Ft=256,or=4194304;function Or(r){var s=r&42;if(s!==0)return s;switch(r&-r){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return r&4194048;case 4194304:case 8388608:case 16777216:case 33554432:return r&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return r}}function Br(r,s,o){var c=r.pendingLanes;if(c===0)return 0;var g=0,M=r.suspendedLanes,j=r.pingedLanes;r=r.warmLanes;var Y=c&134217727;return Y!==0?(c=Y&~M,c!==0?g=Or(c):(j&=Y,j!==0?g=Or(j):o||(o=Y&~r,o!==0&&(g=Or(o))))):(Y=c&~M,Y!==0?g=Or(Y):j!==0?g=Or(j):o||(o=c&~r,o!==0&&(g=Or(o)))),g===0?0:s!==0&&s!==g&&(s&M)===0&&(M=g&-g,o=s&-s,M>=o||M===32&&(o&4194048)!==0)?s:g}function $r(r,s){return(r.pendingLanes&~(r.suspendedLanes&~r.pingedLanes)&s)===0}function er(r,s){switch(r){case 1:case 2:case 4:case 8:case 64:return s+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return s+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function jr(){var r=Ft;return Ft<<=1,(Ft&4194048)===0&&(Ft=256),r}function ja(){var r=or;return or<<=1,(or&62914560)===0&&(or=4194304),r}function ga(r){for(var s=[],o=0;31>o;o++)s.push(r);return s}function Es(r,s){r.pendingLanes|=s,s!==268435456&&(r.suspendedLanes=0,r.pingedLanes=0,r.warmLanes=0)}function Ss(r,s,o,c,g,M){var j=r.pendingLanes;r.pendingLanes=o,r.suspendedLanes=0,r.pingedLanes=0,r.warmLanes=0,r.expiredLanes&=o,r.entangledLanes&=o,r.errorRecoveryDisabledLanes&=o,r.shellSuspendCounter=0;var Y=r.entanglements,he=r.expirationTimes,$e=r.hiddenUpdates;for(o=j&~o;0<o;){var Ze=31-lt(o),tt=1<<Ze;Y[Ze]=0,he[Ze]=-1;var Le=$e[Ze];if(Le!==null)for($e[Ze]=null,Ze=0;Ze<Le.length;Ze++){var Fe=Le[Ze];Fe!==null&&(Fe.lane&=-536870913)}o&=~tt}c!==0&&zt(r,c,0),M!==0&&g===0&&r.tag!==0&&(r.suspendedLanes|=M&~(j&~s))}function zt(r,s,o){r.pendingLanes|=s,r.suspendedLanes&=~s;var c=31-lt(s);r.entangledLanes|=s,r.entanglements[c]=r.entanglements[c]|1073741824|o&4194090}function Zs(r,s){var o=r.entangledLanes|=s;for(r=r.entanglements;o;){var c=31-lt(o),g=1<<c;g&s|r[c]&s&&(r[c]|=s),o&=~g}}function En(r){switch(r){case 2:r=1;break;case 8:r=4;break;case 32:r=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:r=128;break;case 268435456:r=134217728;break;default:r=0}return r}function Kt(r){return r&=-r,2<r?8<r?(r&134217727)!==0?32:268435456:8:2}function Js(){var r=te.p;return r!==0?r:(r=window.event,r===void 0?32:bv(r.type))}function z(r,s){var o=te.p;try{return te.p=r,s()}finally{te.p=o}}var ce=Math.random().toString(36).slice(2),X="__reactFiber$"+ce,ue="__reactProps$"+ce,pe="__reactContainer$"+ce,ke="__reactEvents$"+ce,Qe="__reactListeners$"+ce,Tt="__reactHandles$"+ce,At="__reactResources$"+ce,mt="__reactMarker$"+ce;function Zt(r){delete r[X],delete r[ue],delete r[ke],delete r[Qe],delete r[Tt]}function qt(r){var s=r[X];if(s)return s;for(var o=r.parentNode;o;){if(s=o[pe]||o[X]){if(o=s.alternate,s.child!==null||o!==null&&o.child!==null)for(r=cc(r);r!==null;){if(o=r[X])return o;r=cc(r)}return s}r=o,o=r.parentNode}return null}function On(r){if(r=r[X]||r[pe]){var s=r.tag;if(s===5||s===6||s===13||s===26||s===27||s===3)return r}return null}function wn(r){var s=r.tag;if(s===5||s===26||s===27||s===6)return r.stateNode;throw Error(a(33))}function Un(r){var s=r[At];return s||(s=r[At]={hoistableStyles:new Map,hoistableScripts:new Map}),s}function Sn(r){r[mt]=!0}var Bn=new Set,hr={};function pr(r,s){lr(r,s),lr(r+"Capture",s)}function lr(r,s){for(hr[r]=s,r=0;r<s.length;r++)Bn.add(s[r])}var ea=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Vs={},Xr={};function ya(r){return J.call(Xr,r)?!0:J.call(Vs,r)?!1:ea.test(r)?Xr[r]=!0:(Vs[r]=!0,!1)}function Vr(r,s,o){if(ya(s))if(o===null)r.removeAttribute(s);else{switch(typeof o){case"undefined":case"function":case"symbol":r.removeAttribute(s);return;case"boolean":var c=s.toLowerCase().slice(0,5);if(c!=="data-"&&c!=="aria-"){r.removeAttribute(s);return}}r.setAttribute(s,""+o)}}function ur(r,s,o){if(o===null)r.removeAttribute(s);else{switch(typeof o){case"undefined":case"function":case"symbol":case"boolean":r.removeAttribute(s);return}r.setAttribute(s,""+o)}}function mr(r,s,o,c){if(c===null)r.removeAttribute(o);else{switch(typeof c){case"undefined":case"function":case"symbol":case"boolean":r.removeAttribute(o);return}r.setAttributeNS(s,o,""+c)}}var tr,Er;function Yr(r){if(tr===void 0)try{throw Error()}catch(o){var s=o.stack.trim().match(/\n( *(at )?)/);tr=s&&s[1]||"",Er=-1<o.stack.indexOf(`
    at`)?" (<anonymous>)":-1<o.stack.indexOf("@")?"@unknown:0:0":""}return`
`+tr+r+Er}var ls=!1;function Gs(r,s){if(!r||ls)return"";ls=!0;var o=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var c={DetermineComponentFrameRoot:function(){try{if(s){var tt=function(){throw Error()};if(Object.defineProperty(tt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(tt,[])}catch(Fe){var Le=Fe}Reflect.construct(r,[],tt)}else{try{tt.call()}catch(Fe){Le=Fe}r.call(tt.prototype)}}else{try{throw Error()}catch(Fe){Le=Fe}(tt=r())&&typeof tt.catch=="function"&&tt.catch(function(){})}}catch(Fe){if(Fe&&Le&&typeof Fe.stack=="string")return[Fe.stack,Le.stack]}return[null,null]}};c.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var g=Object.getOwnPropertyDescriptor(c.DetermineComponentFrameRoot,"name");g&&g.configurable&&Object.defineProperty(c.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var M=c.DetermineComponentFrameRoot(),j=M[0],Y=M[1];if(j&&Y){var he=j.split(`
`),$e=Y.split(`
`);for(g=c=0;c<he.length&&!he[c].includes("DetermineComponentFrameRoot");)c++;for(;g<$e.length&&!$e[g].includes("DetermineComponentFrameRoot");)g++;if(c===he.length||g===$e.length)for(c=he.length-1,g=$e.length-1;1<=c&&0<=g&&he[c]!==$e[g];)g--;for(;1<=c&&0<=g;c--,g--)if(he[c]!==$e[g]){if(c!==1||g!==1)do if(c--,g--,0>g||he[c]!==$e[g]){var Ze=`
`+he[c].replace(" at new "," at ");return r.displayName&&Ze.includes("<anonymous>")&&(Ze=Ze.replace("<anonymous>",r.displayName)),Ze}while(1<=c&&0<=g);break}}}finally{ls=!1,Error.prepareStackTrace=o}return(o=r?r.displayName||r.name:"")?Yr(o):""}function Na(r){switch(r.tag){case 26:case 27:case 5:return Yr(r.type);case 16:return Yr("Lazy");case 13:return Yr("Suspense");case 19:return Yr("SuspenseList");case 0:case 15:return Gs(r.type,!1);case 11:return Gs(r.type.render,!1);case 1:return Gs(r.type,!0);case 31:return Yr("Activity");default:return""}}function Zr(r){try{var s="";do s+=Na(r),r=r.return;while(r);return s}catch(o){return`
Error generating stack: `+o.message+`
`+o.stack}}function et(r){switch(typeof r){case"bigint":case"boolean":case"number":case"string":case"undefined":return r;case"object":return r;default:return""}}function ot(r){var s=r.type;return(r=r.nodeName)&&r.toLowerCase()==="input"&&(s==="checkbox"||s==="radio")}function Et(r){var s=ot(r)?"checked":"value",o=Object.getOwnPropertyDescriptor(r.constructor.prototype,s),c=""+r[s];if(!r.hasOwnProperty(s)&&typeof o<"u"&&typeof o.get=="function"&&typeof o.set=="function"){var g=o.get,M=o.set;return Object.defineProperty(r,s,{configurable:!0,get:function(){return g.call(this)},set:function(j){c=""+j,M.call(this,j)}}),Object.defineProperty(r,s,{enumerable:o.enumerable}),{getValue:function(){return c},setValue:function(j){c=""+j},stopTracking:function(){r._valueTracker=null,delete r[s]}}}}function $n(r){r._valueTracker||(r._valueTracker=Et(r))}function va(r){if(!r)return!1;var s=r._valueTracker;if(!s)return!0;var o=s.getValue(),c="";return r&&(c=ot(r)?r.checked?"true":"false":r.value),r=c,r!==o?(s.setValue(r),!0):!1}function Cs(r){if(r=r||(typeof document<"u"?document:void 0),typeof r>"u")return null;try{return r.activeElement||r.body}catch{return r.body}}var Ps=/[\n"\\]/g;function Gr(r){return r.replace(Ps,function(s){return"\\"+s.charCodeAt(0).toString(16)+" "})}function Ua(r,s,o,c,g,M,j,Y){r.name="",j!=null&&typeof j!="function"&&typeof j!="symbol"&&typeof j!="boolean"?r.type=j:r.removeAttribute("type"),s!=null?j==="number"?(s===0&&r.value===""||r.value!=s)&&(r.value=""+et(s)):r.value!==""+et(s)&&(r.value=""+et(s)):j!=="submit"&&j!=="reset"||r.removeAttribute("value"),s!=null?Si(r,j,et(s)):o!=null?Si(r,j,et(o)):c!=null&&r.removeAttribute("value"),g==null&&M!=null&&(r.defaultChecked=!!M),g!=null&&(r.checked=g&&typeof g!="function"&&typeof g!="symbol"),Y!=null&&typeof Y!="function"&&typeof Y!="symbol"&&typeof Y!="boolean"?r.name=""+et(Y):r.removeAttribute("name")}function Ei(r,s,o,c,g,M,j,Y){if(M!=null&&typeof M!="function"&&typeof M!="symbol"&&typeof M!="boolean"&&(r.type=M),s!=null||o!=null){if(!(M!=="submit"&&M!=="reset"||s!=null))return;o=o!=null?""+et(o):"",s=s!=null?""+et(s):o,Y||s===r.value||(r.value=s),r.defaultValue=s}c=c??g,c=typeof c!="function"&&typeof c!="symbol"&&!!c,r.checked=Y?r.checked:!!c,r.defaultChecked=!!c,j!=null&&typeof j!="function"&&typeof j!="symbol"&&typeof j!="boolean"&&(r.name=j)}function Si(r,s,o){s==="number"&&Cs(r.ownerDocument)===r||r.defaultValue===""+o||(r.defaultValue=""+o)}function we(r,s,o,c){if(r=r.options,s){s={};for(var g=0;g<o.length;g++)s["$"+o[g]]=!0;for(o=0;o<r.length;o++)g=s.hasOwnProperty("$"+r[o].value),r[o].selected!==g&&(r[o].selected=g),g&&c&&(r[o].defaultSelected=!0)}else{for(o=""+et(o),s=null,g=0;g<r.length;g++){if(r[g].value===o){r[g].selected=!0,c&&(r[g].defaultSelected=!0);return}s!==null||r[g].disabled||(s=r[g])}s!==null&&(s.selected=!0)}}function F(r,s,o){if(s!=null&&(s=""+et(s),s!==r.value&&(r.value=s),o==null)){r.defaultValue!==s&&(r.defaultValue=s);return}r.defaultValue=o!=null?""+et(o):""}function se(r,s,o,c){if(s==null){if(c!=null){if(o!=null)throw Error(a(92));if(ae(c)){if(1<c.length)throw Error(a(93));c=c[0]}o=c}o==null&&(o=""),s=o}o=et(s),r.defaultValue=o,c=r.textContent,c===o&&c!==""&&c!==null&&(r.value=c)}function de(r,s){if(s){var o=r.firstChild;if(o&&o===r.lastChild&&o.nodeType===3){o.nodeValue=s;return}}r.textContent=s}var me=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Ie(r,s,o){var c=s.indexOf("--")===0;o==null||typeof o=="boolean"||o===""?c?r.setProperty(s,""):s==="float"?r.cssFloat="":r[s]="":c?r.setProperty(s,o):typeof o!="number"||o===0||me.has(s)?s==="float"?r.cssFloat=o:r[s]=(""+o).trim():r[s]=o+"px"}function Ke(r,s,o){if(s!=null&&typeof s!="object")throw Error(a(62));if(r=r.style,o!=null){for(var c in o)!o.hasOwnProperty(c)||s!=null&&s.hasOwnProperty(c)||(c.indexOf("--")===0?r.setProperty(c,""):c==="float"?r.cssFloat="":r[c]="");for(var g in s)c=s[g],s.hasOwnProperty(g)&&o[g]!==c&&Ie(r,g,c)}else for(var M in s)s.hasOwnProperty(M)&&Ie(r,M,s[M])}function gt(r){if(r.indexOf("-")===-1)return!1;switch(r){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var vt=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),wt=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function dt(r){return wt.test(""+r)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":r}var Qt=null;function Ut(r){return r=r.target||r.srcElement||window,r.correspondingUseElement&&(r=r.correspondingUseElement),r.nodeType===3?r.parentNode:r}var Dn=null,Kn=null;function jn(r){var s=On(r);if(s&&(r=s.stateNode)){var o=r[ue]||null;e:switch(r=s.stateNode,s.type){case"input":if(Ua(r,o.value,o.defaultValue,o.defaultValue,o.checked,o.defaultChecked,o.type,o.name),s=o.name,o.type==="radio"&&s!=null){for(o=r;o.parentNode;)o=o.parentNode;for(o=o.querySelectorAll('input[name="'+Gr(""+s)+'"][type="radio"]'),s=0;s<o.length;s++){var c=o[s];if(c!==r&&c.form===r.form){var g=c[ue]||null;if(!g)throw Error(a(90));Ua(c,g.value,g.defaultValue,g.defaultValue,g.checked,g.defaultChecked,g.type,g.name)}}for(s=0;s<o.length;s++)c=o[s],c.form===r.form&&va(c)}break e;case"textarea":F(r,o.value,o.defaultValue);break e;case"select":s=o.value,s!=null&&we(r,!!o.multiple,s,!1)}}}var Vn=!1;function Cn(r,s,o){if(Vn)return r(s,o);Vn=!0;try{var c=r(s);return c}finally{if(Vn=!1,(Dn!==null||Kn!==null)&&(ic(),Dn&&(s=Dn,r=Kn,Kn=Dn=null,jn(s),r)))for(s=0;s<r.length;s++)jn(r[s])}}function Wr(r,s){var o=r.stateNode;if(o===null)return null;var c=o[ue]||null;if(c===null)return null;o=c[s];e:switch(s){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(c=!c.disabled)||(r=r.type,c=!(r==="button"||r==="input"||r==="select"||r==="textarea")),r=!c;break e;default:r=!1}if(r)return null;if(o&&typeof o!="function")throw Error(a(231,s,typeof o));return o}var Dr=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),_r=!1;if(Dr)try{var us={};Object.defineProperty(us,"passive",{get:function(){_r=!0}}),window.addEventListener("test",us,us),window.removeEventListener("test",us,us)}catch{_r=!1}var vn=null,nr=null,gr=null;function ps(){if(gr)return gr;var r,s=nr,o=s.length,c,g="value"in vn?vn.value:vn.textContent,M=g.length;for(r=0;r<o&&s[r]===g[r];r++);var j=o-r;for(c=1;c<=j&&s[o-c]===g[M-c];c++);return gr=g.slice(r,1<c?1-c:void 0)}function ms(r){var s=r.keyCode;return"charCode"in r?(r=r.charCode,r===0&&s===13&&(r=13)):r=s,r===10&&(r=13),32<=r||r===13?r:0}function rr(){return!0}function As(){return!1}function _n(r){function s(o,c,g,M,j){this._reactName=o,this._targetInst=g,this.type=c,this.nativeEvent=M,this.target=j,this.currentTarget=null;for(var Y in r)r.hasOwnProperty(Y)&&(o=r[Y],this[Y]=o?o(M):M[Y]);return this.isDefaultPrevented=(M.defaultPrevented!=null?M.defaultPrevented:M.returnValue===!1)?rr:As,this.isPropagationStopped=As,this}return _(s.prototype,{preventDefault:function(){this.defaultPrevented=!0;var o=this.nativeEvent;o&&(o.preventDefault?o.preventDefault():typeof o.returnValue!="unknown"&&(o.returnValue=!1),this.isDefaultPrevented=rr)},stopPropagation:function(){var o=this.nativeEvent;o&&(o.stopPropagation?o.stopPropagation():typeof o.cancelBubble!="unknown"&&(o.cancelBubble=!0),this.isPropagationStopped=rr)},persist:function(){},isPersistent:rr}),s}var Mn={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(r){return r.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Yn=_n(Mn),Nn=_({},Mn,{view:0,detail:0}),cs=_n(Nn),ba,Ws,Va,ro=_({},Nn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:so,button:0,buttons:0,relatedTarget:function(r){return r.relatedTarget===void 0?r.fromElement===r.srcElement?r.toElement:r.fromElement:r.relatedTarget},movementX:function(r){return"movementX"in r?r.movementX:(r!==Va&&(Va&&r.type==="mousemove"?(ba=r.screenX-Va.screenX,Ws=r.screenY-Va.screenY):Ws=ba=0,Va=r),ba)},movementY:function(r){return"movementY"in r?r.movementY:Ws}}),Ql=_n(ro),Cc=_({},ro,{dataTransfer:0}),Pc=_n(Cc),Ci=_({},Nn,{relatedTarget:0}),Qo=_n(Ci),Ac=_({},Mn,{animationName:0,elapsedTime:0,pseudoElement:0}),kc=_n(Ac),Oc=_({},Mn,{clipboardData:function(r){return"clipboardData"in r?r.clipboardData:window.clipboardData}}),$c=_n(Oc),Pi=_({},Mn,{data:0}),Xl=_n(Pi),Yl={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Zl={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Jl={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Dc(r){var s=this.nativeEvent;return s.getModifierState?s.getModifierState(r):(r=Jl[r])?!!s[r]:!1}function so(){return Dc}var eu=_({},Nn,{key:function(r){if(r.key){var s=Yl[r.key]||r.key;if(s!=="Unidentified")return s}return r.type==="keypress"?(r=ms(r),r===13?"Enter":String.fromCharCode(r)):r.type==="keydown"||r.type==="keyup"?Zl[r.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:so,charCode:function(r){return r.type==="keypress"?ms(r):0},keyCode:function(r){return r.type==="keydown"||r.type==="keyup"?r.keyCode:0},which:function(r){return r.type==="keypress"?ms(r):r.type==="keydown"||r.type==="keyup"?r.keyCode:0}}),tu=_n(eu),Ga=_({},ro,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),nu=_n(Ga),Xo=_({},Nn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:so}),Ic=_n(Xo),ru=_({},Mn,{propertyName:0,elapsedTime:0,pseudoElement:0}),ff=_n(ru),Yo=_({},ro,{deltaX:function(r){return"deltaX"in r?r.deltaX:"wheelDeltaX"in r?-r.wheelDeltaX:0},deltaY:function(r){return"deltaY"in r?r.deltaY:"wheelDeltaY"in r?-r.wheelDeltaY:"wheelDelta"in r?-r.wheelDelta:0},deltaZ:0,deltaMode:0}),Zo=_n(Yo),su=_({},Mn,{newState:0,oldState:0}),Jo=_n(su),Lc=[9,13,27,32],el=Dr&&"CompositionEvent"in window,Ai=null;Dr&&"documentMode"in document&&(Ai=document.documentMode);var zc=Dr&&"TextEvent"in window&&!Ai,au=Dr&&(!el||Ai&&8<Ai&&11>=Ai),iu=" ",ou=!1;function ki(r,s){switch(r){case"keyup":return Lc.indexOf(s.keyCode)!==-1;case"keydown":return s.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function wa(r){return r=r.detail,typeof r=="object"&&"data"in r?r.data:null}var Ma=!1;function tl(r,s){switch(r){case"compositionend":return wa(s);case"keypress":return s.which!==32?null:(ou=!0,iu);case"textInput":return r=s.data,r===iu&&ou?null:r;default:return null}}function lu(r,s){if(Ma)return r==="compositionend"||!el&&ki(r,s)?(r=ps(),gr=nr=vn=null,Ma=!1,r):null;switch(r){case"paste":return null;case"keypress":if(!(s.ctrlKey||s.altKey||s.metaKey)||s.ctrlKey&&s.altKey){if(s.char&&1<s.char.length)return s.char;if(s.which)return String.fromCharCode(s.which)}return null;case"compositionend":return au&&s.locale!=="ko"?null:s.data;default:return null}}var nl={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Oi(r){var s=r&&r.nodeName&&r.nodeName.toLowerCase();return s==="input"?!!nl[r.type]:s==="textarea"}function ta(r,s,o,c){Dn?Kn?Kn.push(c):Kn=[c]:Dn=c,s=Oe(s,"onChange"),0<s.length&&(o=new Yn("onChange","change",null,o,c),r.push({event:o,listeners:s}))}var Wa=null,$i=null;function uu(r){Sm(r,0)}function ao(r){var s=wn(r);if(va(s))return r}function rl(r,s){if(r==="change")return s}var sl=!1;if(Dr){var io;if(Dr){var oo="oninput"in document;if(!oo){var Di=document.createElement("div");Di.setAttribute("oninput","return;"),oo=typeof Di.oninput=="function"}io=oo}else io=!1;sl=io&&(!document.documentMode||9<document.documentMode)}function $t(){Wa&&(Wa.detachEvent("onpropertychange",cu),$i=Wa=null)}function cu(r){if(r.propertyName==="value"&&ao($i)){var s=[];ta(s,$i,r,Ut(r)),Cn(uu,s)}}function lo(r,s,o){r==="focusin"?($t(),Wa=s,$i=o,Wa.attachEvent("onpropertychange",cu)):r==="focusout"&&$t()}function du(r){if(r==="selectionchange"||r==="keyup"||r==="keydown")return ao($i)}function uo(r,s){if(r==="click")return ao(s)}function ks(r,s){if(r==="input"||r==="change")return ao(s)}function Ii(r,s){return r===s&&(r!==0||1/r===1/s)||r!==r&&s!==s}var Hr=typeof Object.is=="function"?Object.is:Ii;function Ha(r,s){if(Hr(r,s))return!0;if(typeof r!="object"||r===null||typeof s!="object"||s===null)return!1;var o=Object.keys(r),c=Object.keys(s);if(o.length!==c.length)return!1;for(c=0;c<o.length;c++){var g=o[c];if(!J.call(s,g)||!Hr(r[g],s[g]))return!1}return!0}function co(r){for(;r&&r.firstChild;)r=r.firstChild;return r}function al(r,s){var o=co(r);r=0;for(var c;o;){if(o.nodeType===3){if(c=r+o.textContent.length,r<=s&&c>=s)return{node:o,offset:s-r};r=c}e:{for(;o;){if(o.nextSibling){o=o.nextSibling;break e}o=o.parentNode}o=void 0}o=co(o)}}function fo(r,s){return r&&s?r===s?!0:r&&r.nodeType===3?!1:s&&s.nodeType===3?fo(r,s.parentNode):"contains"in r?r.contains(s):r.compareDocumentPosition?!!(r.compareDocumentPosition(s)&16):!1:!1}function ho(r){r=r!=null&&r.ownerDocument!=null&&r.ownerDocument.defaultView!=null?r.ownerDocument.defaultView:window;for(var s=Cs(r.document);s instanceof r.HTMLIFrameElement;){try{var o=typeof s.contentWindow.location.href=="string"}catch{o=!1}if(o)r=s.contentWindow;else break;s=Cs(r.document)}return s}function po(r){var s=r&&r.nodeName&&r.nodeName.toLowerCase();return s&&(s==="input"&&(r.type==="text"||r.type==="search"||r.type==="tel"||r.type==="url"||r.type==="password")||s==="textarea"||r.contentEditable==="true")}var fu=Dr&&"documentMode"in document&&11>=document.documentMode,Os=null,Li=null,xa=null,zi=!1;function il(r,s,o){var c=o.window===o?o.document:o.nodeType===9?o:o.ownerDocument;zi||Os==null||Os!==Cs(c)||(c=Os,"selectionStart"in c&&po(c)?c={start:c.selectionStart,end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset}),xa&&Ha(xa,c)||(xa=c,c=Oe(Li,"onSelect"),0<c.length&&(s=new Yn("onSelect","select",null,s,o),r.push({event:s,listeners:c}),s.target=Os)))}function na(r,s){var o={};return o[r.toLowerCase()]=s.toLowerCase(),o["Webkit"+r]="webkit"+s,o["Moz"+r]="moz"+s,o}var ra={animationend:na("Animation","AnimationEnd"),animationiteration:na("Animation","AnimationIteration"),animationstart:na("Animation","AnimationStart"),transitionrun:na("Transition","TransitionRun"),transitionstart:na("Transition","TransitionStart"),transitioncancel:na("Transition","TransitionCancel"),transitionend:na("Transition","TransitionEnd")},mo={},b={};Dr&&(b=document.createElement("div").style,"AnimationEvent"in window||(delete ra.animationend.animation,delete ra.animationiteration.animation,delete ra.animationstart.animation),"TransitionEvent"in window||delete ra.transitionend.transition);function $(r){if(mo[r])return mo[r];if(!ra[r])return r;var s=ra[r],o;for(o in s)if(s.hasOwnProperty(o)&&o in b)return mo[r]=s[o];return r}var N=$("animationend"),K=$("animationiteration"),re=$("animationstart"),ye=$("transitionrun"),He=$("transitionstart"),at=$("transitioncancel"),yt=$("transitionend"),Pt=new Map,jt="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");jt.push("scrollEnd");function Xt(r,s){Pt.set(r,s),pr(s,[r])}var gn=new WeakMap;function Pn(r,s){if(typeof r=="object"&&r!==null){var o=gn.get(r);return o!==void 0?o:(s={value:r,source:s,stack:Zr(s)},gn.set(r,s),s)}return{value:r,source:s,stack:Zr(s)}}var Ir=[],Ta=0,Fc=0;function hu(){for(var r=Ta,s=Fc=Ta=0;s<r;){var o=Ir[s];Ir[s++]=null;var c=Ir[s];Ir[s++]=null;var g=Ir[s];Ir[s++]=null;var M=Ir[s];if(Ir[s++]=null,c!==null&&g!==null){var j=c.pending;j===null?g.next=g:(g.next=j.next,j.next=g),c.pending=g}M!==0&&Bc(o,g,M)}}function ol(r,s,o,c){Ir[Ta++]=r,Ir[Ta++]=s,Ir[Ta++]=o,Ir[Ta++]=c,Fc|=c,r.lanes|=c,r=r.alternate,r!==null&&(r.lanes|=c)}function Rc(r,s,o,c){return ol(r,s,o,c),pu(r)}function _o(r,s){return ol(r,null,null,s),pu(r)}function Bc(r,s,o){r.lanes|=o;var c=r.alternate;c!==null&&(c.lanes|=o);for(var g=!1,M=r.return;M!==null;)M.childLanes|=o,c=M.alternate,c!==null&&(c.childLanes|=o),M.tag===22&&(r=M.stateNode,r===null||r._visibility&1||(g=!0)),r=M,M=M.return;return r.tag===3?(M=r.stateNode,g&&s!==null&&(g=31-lt(o),r=M.hiddenUpdates,c=r[g],c===null?r[g]=[s]:c.push(s),s.lane=o|536870912),M):null}function pu(r){if(50<kl)throw kl=0,ac=null,Error(a(185));for(var s=r.return;s!==null;)r=s,s=r.return;return r.tag===3?r.stateNode:null}var go={};function hf(r,s,o,c){this.tag=r,this.key=o,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=s,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=c,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function _s(r,s,o,c){return new hf(r,s,o,c)}function jc(r){return r=r.prototype,!(!r||!r.isReactComponent)}function sa(r,s){var o=r.alternate;return o===null?(o=_s(r.tag,s,r.key,r.mode),o.elementType=r.elementType,o.type=r.type,o.stateNode=r.stateNode,o.alternate=r,r.alternate=o):(o.pendingProps=s,o.type=r.type,o.flags=0,o.subtreeFlags=0,o.deletions=null),o.flags=r.flags&65011712,o.childLanes=r.childLanes,o.lanes=r.lanes,o.child=r.child,o.memoizedProps=r.memoizedProps,o.memoizedState=r.memoizedState,o.updateQueue=r.updateQueue,s=r.dependencies,o.dependencies=s===null?null:{lanes:s.lanes,firstContext:s.firstContext},o.sibling=r.sibling,o.index=r.index,o.ref=r.ref,o.refCleanup=r.refCleanup,o}function pf(r,s){r.flags&=65011714;var o=r.alternate;return o===null?(r.childLanes=0,r.lanes=s,r.child=null,r.subtreeFlags=0,r.memoizedProps=null,r.memoizedState=null,r.updateQueue=null,r.dependencies=null,r.stateNode=null):(r.childLanes=o.childLanes,r.lanes=o.lanes,r.child=o.child,r.subtreeFlags=0,r.deletions=null,r.memoizedProps=o.memoizedProps,r.memoizedState=o.memoizedState,r.updateQueue=o.updateQueue,r.type=o.type,s=o.dependencies,r.dependencies=s===null?null:{lanes:s.lanes,firstContext:s.firstContext}),r}function mu(r,s,o,c,g,M){var j=0;if(c=r,typeof r=="function")jc(r)&&(j=1);else if(typeof r=="string")j=JS(r,o,G.current)?26:r==="html"||r==="head"||r==="body"?27:5;else e:switch(r){case V:return r=_s(31,o,s,g),r.elementType=V,r.lanes=M,r;case v:return Ka(o.children,g,M,s);case x:j=8,g|=24;break;case L:return r=_s(12,o,s,g|2),r.elementType=L,r.lanes=M,r;case S:return r=_s(13,o,s,g),r.elementType=S,r.lanes=M,r;case k:return r=_s(19,o,s,g),r.elementType=k,r.lanes=M,r;default:if(typeof r=="object"&&r!==null)switch(r.$$typeof){case T:case I:j=10;break e;case E:j=9;break e;case P:j=11;break e;case C:j=14;break e;case D:j=16,c=null;break e}j=29,o=Error(a(130,r===null?"null":typeof r,"")),c=null}return s=_s(j,o,s,g),s.elementType=r,s.type=c,s.lanes=M,s}function Ka(r,s,o,c){return r=_s(7,r,c,s),r.lanes=o,r}function Nc(r,s,o){return r=_s(6,r,null,s),r.lanes=o,r}function Uc(r,s,o){return s=_s(4,r.children!==null?r.children:[],r.key,s),s.lanes=o,s.stateNode={containerInfo:r.containerInfo,pendingChildren:null,implementation:r.implementation},s}var Fi=[],yo=0,_u=null,ll=0,$s=[],Ds=0,qa=null,Ea=1,Sa="";function Qa(r,s){Fi[yo++]=ll,Fi[yo++]=_u,_u=r,ll=s}function mf(r,s,o){$s[Ds++]=Ea,$s[Ds++]=Sa,$s[Ds++]=qa,qa=r;var c=Ea;r=Sa;var g=32-lt(c)-1;c&=~(1<<g),o+=1;var M=32-lt(s)+g;if(30<M){var j=g-g%5;M=(c&(1<<j)-1).toString(32),c>>=j,g-=j,Ea=1<<32-lt(s)+g|o<<g|c,Sa=M+r}else Ea=1<<M|o<<g|c,Sa=r}function Vc(r){r.return!==null&&(Qa(r,1),mf(r,1,0))}function gu(r){for(;r===_u;)_u=Fi[--yo],Fi[yo]=null,ll=Fi[--yo],Fi[yo]=null;for(;r===qa;)qa=$s[--Ds],$s[Ds]=null,Sa=$s[--Ds],$s[Ds]=null,Ea=$s[--Ds],$s[Ds]=null}var rs=null,cr=null,bn=!1,Ri=null,aa=!1,yu=Error(a(519));function Bi(r){var s=Error(a(418,""));throw dl(Pn(s,r)),yu}function _f(r){var s=r.stateNode,o=r.type,c=r.memoizedProps;switch(s[X]=r,s[ue]=c,o){case"dialog":un("cancel",s),un("close",s);break;case"iframe":case"object":case"embed":un("load",s);break;case"video":case"audio":for(o=0;o<Pr.length;o++)un(Pr[o],s);break;case"source":un("error",s);break;case"img":case"image":case"link":un("error",s),un("load",s);break;case"details":un("toggle",s);break;case"input":un("invalid",s),Ei(s,c.value,c.defaultValue,c.checked,c.defaultChecked,c.type,c.name,!0),$n(s);break;case"select":un("invalid",s);break;case"textarea":un("invalid",s),se(s,c.value,c.defaultValue,c.children),$n(s)}o=c.children,typeof o!="string"&&typeof o!="number"&&typeof o!="bigint"||s.textContent===""+o||c.suppressHydrationWarning===!0||Yt(s.textContent,o)?(c.popover!=null&&(un("beforetoggle",s),un("toggle",s)),c.onScroll!=null&&un("scroll",s),c.onScrollEnd!=null&&un("scrollend",s),c.onClick!=null&&(s.onclick=Wt),s=!0):s=!1,s||Bi(r)}function Gc(r){for(rs=r.return;rs;)switch(rs.tag){case 5:case 13:aa=!1;return;case 27:case 3:aa=!0;return;default:rs=rs.return}}function ul(r){if(r!==rs)return!1;if(!bn)return Gc(r),bn=!0,!1;var s=r.tag,o;if((o=s!==3&&s!==27)&&((o=s===5)&&(o=r.type,o=!(o!=="form"&&o!=="button")||ar(r.type,r.memoizedProps)),o=!o),o&&cr&&Bi(r),Gc(r),s===13){if(r=r.memoizedState,r=r!==null?r.dehydrated:null,!r)throw Error(a(317));e:{for(r=r.nextSibling,s=0;r;){if(r.nodeType===8)if(o=r.data,o==="/$"){if(s===0){cr=es(r.nextSibling);break e}s--}else o!=="$"&&o!=="$!"&&o!=="$?"||s++;r=r.nextSibling}cr=null}}else s===27?(s=cr,Rs(r.type)?(r=Yi,Yi=null,cr=r):cr=s):cr=rs?es(r.stateNode.nextSibling):null;return!0}function cl(){cr=rs=null,bn=!1}function Wc(){var r=Ri;return r!==null&&(vs===null?vs=r:vs.push.apply(vs,r),Ri=null),r}function dl(r){Ri===null?Ri=[r]:Ri.push(r)}var Hc=B(null),Xa=null,Ca=null;function Ya(r,s,o){Q(Hc,s._currentValue),s._currentValue=o}function ia(r){r._currentValue=Hc.current,R(Hc)}function Kc(r,s,o){for(;r!==null;){var c=r.alternate;if((r.childLanes&s)!==s?(r.childLanes|=s,c!==null&&(c.childLanes|=s)):c!==null&&(c.childLanes&s)!==s&&(c.childLanes|=s),r===o)break;r=r.return}}function qc(r,s,o,c){var g=r.child;for(g!==null&&(g.return=r);g!==null;){var M=g.dependencies;if(M!==null){var j=g.child;M=M.firstContext;e:for(;M!==null;){var Y=M;M=g;for(var he=0;he<s.length;he++)if(Y.context===s[he]){M.lanes|=o,Y=M.alternate,Y!==null&&(Y.lanes|=o),Kc(M.return,o,r),c||(j=null);break e}M=Y.next}}else if(g.tag===18){if(j=g.return,j===null)throw Error(a(341));j.lanes|=o,M=j.alternate,M!==null&&(M.lanes|=o),Kc(j,o,r),j=null}else j=g.child;if(j!==null)j.return=g;else for(j=g;j!==null;){if(j===r){j=null;break}if(g=j.sibling,g!==null){g.return=j.return,j=g;break}j=j.return}g=j}}function fl(r,s,o,c){r=null;for(var g=s,M=!1;g!==null;){if(!M){if((g.flags&524288)!==0)M=!0;else if((g.flags&262144)!==0)break}if(g.tag===10){var j=g.alternate;if(j===null)throw Error(a(387));if(j=j.memoizedProps,j!==null){var Y=g.type;Hr(g.pendingProps.value,j.value)||(r!==null?r.push(Y):r=[Y])}}else if(g===ze.current){if(j=g.alternate,j===null)throw Error(a(387));j.memoizedState.memoizedState!==g.memoizedState.memoizedState&&(r!==null?r.push(up):r=[up])}g=g.return}r!==null&&qc(s,r,o,c),s.flags|=262144}function vu(r){for(r=r.firstContext;r!==null;){if(!Hr(r.context._currentValue,r.memoizedValue))return!0;r=r.next}return!1}function Za(r){Xa=r,Ca=null,r=r.dependencies,r!==null&&(r.firstContext=null)}function Jr(r){return Qc(Xa,r)}function bu(r,s){return Xa===null&&Za(r),Qc(r,s)}function Qc(r,s){var o=s._currentValue;if(s={context:s,memoizedValue:o,next:null},Ca===null){if(r===null)throw Error(a(308));Ca=s,r.dependencies={lanes:0,firstContext:s},r.flags|=524288}else Ca=Ca.next=s;return o}var qp=typeof AbortController<"u"?AbortController:function(){var r=[],s=this.signal={aborted:!1,addEventListener:function(o,c){r.push(c)}};this.abort=function(){s.aborted=!0,r.forEach(function(o){return o()})}},Qp=e.unstable_scheduleCallback,gf=e.unstable_NormalPriority,Lr={$$typeof:I,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Xc(){return{controller:new qp,data:new Map,refCount:0}}function vo(r){r.refCount--,r.refCount===0&&Qp(gf,function(){r.controller.abort()})}var hl=null,Yc=0,ji=0,bo=null;function Xp(r,s){if(hl===null){var o=hl=[];Yc=0,ji=sp(),bo={status:"pending",value:void 0,then:function(c){o.push(c)}}}return Yc++,s.then(Zc,Zc),s}function Zc(){if(--Yc===0&&hl!==null){bo!==null&&(bo.status="fulfilled");var r=hl;hl=null,ji=0,bo=null;for(var s=0;s<r.length;s++)(0,r[s])()}}function Yp(r,s){var o=[],c={status:"pending",value:null,reason:null,then:function(g){o.push(g)}};return r.then(function(){c.status="fulfilled",c.value=s;for(var g=0;g<o.length;g++)(0,o[g])(s)},function(g){for(c.status="rejected",c.reason=g,g=0;g<o.length;g++)(0,o[g])(void 0)}),c}var yf=W.S;W.S=function(r,s){typeof s=="object"&&s!==null&&typeof s.then=="function"&&Xp(r,s),yf!==null&&yf(r,s)};var Ja=B(null);function Jc(){var r=Ja.current;return r!==null?r:Gn.pooledCache}function wu(r,s){s===null?Q(Ja,Ja.current):Q(Ja,s.pool)}function vf(){var r=Jc();return r===null?null:{parent:Lr._currentValue,pool:r}}var pl=Error(a(460)),ed=Error(a(474)),Mu=Error(a(542)),td={then:function(){}};function bf(r){return r=r.status,r==="fulfilled"||r==="rejected"}function xu(){}function nd(r,s,o){switch(o=r[o],o===void 0?r.push(s):o!==s&&(s.then(xu,xu),s=o),s.status){case"fulfilled":return s.value;case"rejected":throw r=s.reason,Mf(r),r;default:if(typeof s.status=="string")s.then(xu,xu);else{if(r=Gn,r!==null&&100<r.shellSuspendCounter)throw Error(a(482));r=s,r.status="pending",r.then(function(c){if(s.status==="pending"){var g=s;g.status="fulfilled",g.value=c}},function(c){if(s.status==="pending"){var g=s;g.status="rejected",g.reason=c}})}switch(s.status){case"fulfilled":return s.value;case"rejected":throw r=s.reason,Mf(r),r}throw ml=s,pl}}var ml=null;function wf(){if(ml===null)throw Error(a(459));var r=ml;return ml=null,r}function Mf(r){if(r===pl||r===Mu)throw Error(a(483))}var ei=!1;function Tu(r){r.updateQueue={baseState:r.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function rd(r,s){r=r.updateQueue,s.updateQueue===r&&(s.updateQueue={baseState:r.baseState,firstBaseUpdate:r.firstBaseUpdate,lastBaseUpdate:r.lastBaseUpdate,shared:r.shared,callbacks:null})}function ti(r){return{lane:r,tag:0,payload:null,callback:null,next:null}}function ni(r,s,o){var c=r.updateQueue;if(c===null)return null;if(c=c.shared,(xn&2)!==0){var g=c.pending;return g===null?s.next=s:(s.next=g.next,g.next=s),c.pending=s,s=pu(r),Bc(r,null,o),s}return ol(r,c,s,o),pu(r)}function _l(r,s,o){if(s=s.updateQueue,s!==null&&(s=s.shared,(o&4194048)!==0)){var c=s.lanes;c&=r.pendingLanes,o|=c,s.lanes=o,Zs(r,o)}}function Eu(r,s){var o=r.updateQueue,c=r.alternate;if(c!==null&&(c=c.updateQueue,o===c)){var g=null,M=null;if(o=o.firstBaseUpdate,o!==null){do{var j={lane:o.lane,tag:o.tag,payload:o.payload,callback:null,next:null};M===null?g=M=j:M=M.next=j,o=o.next}while(o!==null);M===null?g=M=s:M=M.next=s}else g=M=s;o={baseState:c.baseState,firstBaseUpdate:g,lastBaseUpdate:M,shared:c.shared,callbacks:c.callbacks},r.updateQueue=o;return}r=o.lastBaseUpdate,r===null?o.firstBaseUpdate=s:r.next=s,o.lastBaseUpdate=s}var sd=!1;function gl(){if(sd){var r=bo;if(r!==null)throw r}}function wo(r,s,o,c){sd=!1;var g=r.updateQueue;ei=!1;var M=g.firstBaseUpdate,j=g.lastBaseUpdate,Y=g.shared.pending;if(Y!==null){g.shared.pending=null;var he=Y,$e=he.next;he.next=null,j===null?M=$e:j.next=$e,j=he;var Ze=r.alternate;Ze!==null&&(Ze=Ze.updateQueue,Y=Ze.lastBaseUpdate,Y!==j&&(Y===null?Ze.firstBaseUpdate=$e:Y.next=$e,Ze.lastBaseUpdate=he))}if(M!==null){var tt=g.baseState;j=0,Ze=$e=he=null,Y=M;do{var Le=Y.lane&-536870913,Fe=Le!==Y.lane;if(Fe?(pn&Le)===Le:(c&Le)===Le){Le!==0&&Le===ji&&(sd=!0),Ze!==null&&(Ze=Ze.next={lane:0,tag:Y.tag,payload:Y.payload,callback:null,next:null});e:{var Jt=r,Gt=Y;Le=s;var Qn=o;switch(Gt.tag){case 1:if(Jt=Gt.payload,typeof Jt=="function"){tt=Jt.call(Qn,tt,Le);break e}tt=Jt;break e;case 3:Jt.flags=Jt.flags&-65537|128;case 0:if(Jt=Gt.payload,Le=typeof Jt=="function"?Jt.call(Qn,tt,Le):Jt,Le==null)break e;tt=_({},tt,Le);break e;case 2:ei=!0}}Le=Y.callback,Le!==null&&(r.flags|=64,Fe&&(r.flags|=8192),Fe=g.callbacks,Fe===null?g.callbacks=[Le]:Fe.push(Le))}else Fe={lane:Le,tag:Y.tag,payload:Y.payload,callback:Y.callback,next:null},Ze===null?($e=Ze=Fe,he=tt):Ze=Ze.next=Fe,j|=Le;if(Y=Y.next,Y===null){if(Y=g.shared.pending,Y===null)break;Fe=Y,Y=Fe.next,Fe.next=null,g.lastBaseUpdate=Fe,g.shared.pending=null}}while(!0);Ze===null&&(he=tt),g.baseState=he,g.firstBaseUpdate=$e,g.lastBaseUpdate=Ze,M===null&&(g.shared.lanes=0),ci|=j,r.lanes=j,r.memoizedState=tt}}function xf(r,s){if(typeof r!="function")throw Error(a(191,r));r.call(s)}function Tf(r,s){var o=r.callbacks;if(o!==null)for(r.callbacks=null,r=0;r<o.length;r++)xf(o[r],s)}var Ni=B(null),Su=B(0);function Ef(r,s){r=$a,Q(Su,r),Q(Ni,s),$a=r|s.baseLanes}function Cu(){Q(Su,$a),Q(Ni,Ni.current)}function ad(){$a=Su.current,R(Ni),R(Su)}var ri=0,sn=null,Fn=null,Sr=null,Mo=!1,xo=!1,Ui=!1,yl=0,To=0,Eo=null,Sf=0;function yr(){throw Error(a(321))}function id(r,s){if(s===null)return!1;for(var o=0;o<s.length&&o<r.length;o++)if(!Hr(r[o],s[o]))return!1;return!0}function So(r,s,o,c,g,M){return ri=M,sn=s,s.memoizedState=null,s.updateQueue=null,s.lanes=0,W.H=r===null||r.memoizedState===null?sh:ah,Ui=!1,M=o(c,g),Ui=!1,xo&&(M=Cf(s,o,c,g)),od(r),M}function od(r){W.H=ju;var s=Fn!==null&&Fn.next!==null;if(ri=0,Sr=Fn=sn=null,Mo=!1,To=0,Eo=null,s)throw Error(a(300));r===null||Nr||(r=r.dependencies,r!==null&&vu(r)&&(Nr=!0))}function Cf(r,s,o,c){sn=r;var g=0;do{if(xo&&(Eo=null),To=0,xo=!1,25<=g)throw Error(a(301));if(g+=1,Sr=Fn=null,r.updateQueue!=null){var M=r.updateQueue;M.lastEffect=null,M.events=null,M.stores=null,M.memoCache!=null&&(M.memoCache.index=0)}W.H=nm,M=s(o,c)}while(xo);return M}function Zp(){var r=W.H,s=r.useState()[0];return s=typeof s.then=="function"?vl(s):s,r=r.useState()[0],(Fn!==null?Fn.memoizedState:null)!==r&&(sn.flags|=1024),s}function ld(){var r=yl!==0;return yl=0,r}function Pu(r,s,o){s.updateQueue=r.updateQueue,s.flags&=-2053,r.lanes&=~o}function ud(r){if(Mo){for(r=r.memoizedState;r!==null;){var s=r.queue;s!==null&&(s.pending=null),r=r.next}Mo=!1}ri=0,Sr=Fn=sn=null,xo=!1,To=yl=0,Eo=null}function ds(){var r={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Sr===null?sn.memoizedState=Sr=r:Sr=Sr.next=r,Sr}function Cr(){if(Fn===null){var r=sn.alternate;r=r!==null?r.memoizedState:null}else r=Fn.next;var s=Sr===null?sn.memoizedState:Sr.next;if(s!==null)Sr=s,Fn=r;else{if(r===null)throw sn.alternate===null?Error(a(467)):Error(a(310));Fn=r,r={memoizedState:Fn.memoizedState,baseState:Fn.baseState,baseQueue:Fn.baseQueue,queue:Fn.queue,next:null},Sr===null?sn.memoizedState=Sr=r:Sr=Sr.next=r}return Sr}function Au(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function vl(r){var s=To;return To+=1,Eo===null&&(Eo=[]),r=nd(Eo,r,s),s=sn,(Sr===null?s.memoizedState:Sr.next)===null&&(s=s.alternate,W.H=s===null||s.memoizedState===null?sh:ah),r}function ku(r){if(r!==null&&typeof r=="object"){if(typeof r.then=="function")return vl(r);if(r.$$typeof===I)return Jr(r)}throw Error(a(438,String(r)))}function Ou(r){var s=null,o=sn.updateQueue;if(o!==null&&(s=o.memoCache),s==null){var c=sn.alternate;c!==null&&(c=c.updateQueue,c!==null&&(c=c.memoCache,c!=null&&(s={data:c.data.map(function(g){return g.slice()}),index:0})))}if(s==null&&(s={data:[],index:0}),o===null&&(o=Au(),sn.updateQueue=o),o.memoCache=s,o=s.data[s.index],o===void 0)for(o=s.data[s.index]=Array(r),c=0;c<r;c++)o[c]=U;return s.index++,o}function Pa(r,s){return typeof s=="function"?s(r):s}function $u(r){var s=Cr();return cd(s,Fn,r)}function cd(r,s,o){var c=r.queue;if(c===null)throw Error(a(311));c.lastRenderedReducer=o;var g=r.baseQueue,M=c.pending;if(M!==null){if(g!==null){var j=g.next;g.next=M.next,M.next=j}s.baseQueue=g=M,c.pending=null}if(M=r.baseState,g===null)r.memoizedState=M;else{s=g.next;var Y=j=null,he=null,$e=s,Ze=!1;do{var tt=$e.lane&-536870913;if(tt!==$e.lane?(pn&tt)===tt:(ri&tt)===tt){var Le=$e.revertLane;if(Le===0)he!==null&&(he=he.next={lane:0,revertLane:0,action:$e.action,hasEagerState:$e.hasEagerState,eagerState:$e.eagerState,next:null}),tt===ji&&(Ze=!0);else if((ri&Le)===Le){$e=$e.next,Le===ji&&(Ze=!0);continue}else tt={lane:0,revertLane:$e.revertLane,action:$e.action,hasEagerState:$e.hasEagerState,eagerState:$e.eagerState,next:null},he===null?(Y=he=tt,j=M):he=he.next=tt,sn.lanes|=Le,ci|=Le;tt=$e.action,Ui&&o(M,tt),M=$e.hasEagerState?$e.eagerState:o(M,tt)}else Le={lane:tt,revertLane:$e.revertLane,action:$e.action,hasEagerState:$e.hasEagerState,eagerState:$e.eagerState,next:null},he===null?(Y=he=Le,j=M):he=he.next=Le,sn.lanes|=tt,ci|=tt;$e=$e.next}while($e!==null&&$e!==s);if(he===null?j=M:he.next=Y,!Hr(M,r.memoizedState)&&(Nr=!0,Ze&&(o=bo,o!==null)))throw o;r.memoizedState=M,r.baseState=j,r.baseQueue=he,c.lastRenderedState=M}return g===null&&(c.lanes=0),[r.memoizedState,c.dispatch]}function Du(r){var s=Cr(),o=s.queue;if(o===null)throw Error(a(311));o.lastRenderedReducer=r;var c=o.dispatch,g=o.pending,M=s.memoizedState;if(g!==null){o.pending=null;var j=g=g.next;do M=r(M,j.action),j=j.next;while(j!==g);Hr(M,s.memoizedState)||(Nr=!0),s.memoizedState=M,s.baseQueue===null&&(s.baseState=M),o.lastRenderedState=M}return[M,c]}function Pf(r,s,o){var c=sn,g=Cr(),M=bn;if(M){if(o===void 0)throw Error(a(407));o=o()}else o=s();var j=!Hr((Fn||g).memoizedState,o);j&&(g.memoizedState=o,Nr=!0),g=g.queue;var Y=kf.bind(null,c,g,r);if(bl(2048,8,Y,[r]),g.getSnapshot!==s||j||Sr!==null&&Sr.memoizedState.tag&1){if(c.flags|=2048,si(9,Lu(),dd.bind(null,c,g,o,s),null),Gn===null)throw Error(a(349));M||(ri&124)!==0||Af(c,s,o)}return o}function Af(r,s,o){r.flags|=16384,r={getSnapshot:s,value:o},s=sn.updateQueue,s===null?(s=Au(),sn.updateQueue=s,s.stores=[r]):(o=s.stores,o===null?s.stores=[r]:o.push(r))}function dd(r,s,o,c){s.value=o,s.getSnapshot=c,Of(s)&&fd(r)}function kf(r,s,o){return o(function(){Of(s)&&fd(r)})}function Of(r){var s=r.getSnapshot;r=r.value;try{var o=s();return!Hr(r,o)}catch{return!0}}function fd(r){var s=_o(r,2);s!==null&&zs(s,r,2)}function hd(r){var s=ds();if(typeof r=="function"){var o=r;if(r=o(),Ui){pt(!0);try{o()}finally{pt(!1)}}}return s.memoizedState=s.baseState=r,s.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Pa,lastRenderedState:r},s}function $f(r,s,o,c){return r.baseState=o,cd(r,Fn,typeof c=="function"?c:Pa)}function pd(r,s,o,c,g){if(Bu(r))throw Error(a(485));if(r=s.action,r!==null){var M={payload:g,action:r,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(j){M.listeners.push(j)}};W.T!==null?o(!0):M.isTransition=!1,c(M),o=s.pending,o===null?(M.next=s.pending=M,Df(s,M)):(M.next=o.next,s.pending=o.next=M)}}function Df(r,s){var o=s.action,c=s.payload,g=r.state;if(s.isTransition){var M=W.T,j={};W.T=j;try{var Y=o(g,c),he=W.S;he!==null&&he(j,Y),If(r,s,Y)}catch($e){Iu(r,s,$e)}finally{W.T=M}}else try{M=o(g,c),If(r,s,M)}catch($e){Iu(r,s,$e)}}function If(r,s,o){o!==null&&typeof o=="object"&&typeof o.then=="function"?o.then(function(c){Lf(r,s,c)},function(c){return Iu(r,s,c)}):Lf(r,s,o)}function Lf(r,s,o){s.status="fulfilled",s.value=o,zf(s),r.state=o,s=r.pending,s!==null&&(o=s.next,o===s?r.pending=null:(o=o.next,s.next=o,Df(r,o)))}function Iu(r,s,o){var c=r.pending;if(r.pending=null,c!==null){c=c.next;do s.status="rejected",s.reason=o,zf(s),s=s.next;while(s!==c)}r.action=null}function zf(r){r=r.listeners;for(var s=0;s<r.length;s++)(0,r[s])()}function Ff(r,s){return s}function md(r,s){if(bn){var o=Gn.formState;if(o!==null){e:{var c=sn;if(bn){if(cr){t:{for(var g=cr,M=aa;g.nodeType!==8;){if(!M){g=null;break t}if(g=es(g.nextSibling),g===null){g=null;break t}}M=g.data,g=M==="F!"||M==="F"?g:null}if(g){cr=es(g.nextSibling),c=g.data==="F!";break e}}Bi(c)}c=!1}c&&(s=o[0])}}return o=ds(),o.memoizedState=o.baseState=s,c={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ff,lastRenderedState:s},o.queue=c,o=th.bind(null,sn,c),c.dispatch=o,c=hd(!1),M=bd.bind(null,sn,!1,c.queue),c=ds(),g={state:s,dispatch:null,action:r,pending:null},c.queue=g,o=pd.bind(null,sn,g,M,o),g.dispatch=o,c.memoizedState=r,[s,o,!1]}function Rf(r){var s=Cr();return Bf(s,Fn,r)}function Bf(r,s,o){if(s=cd(r,s,Ff)[0],r=$u(Pa)[0],typeof s=="object"&&s!==null&&typeof s.then=="function")try{var c=vl(s)}catch(j){throw j===pl?Mu:j}else c=s;s=Cr();var g=s.queue,M=g.dispatch;return o!==s.memoizedState&&(sn.flags|=2048,si(9,Lu(),Jp.bind(null,g,o),null)),[c,M,r]}function Jp(r,s){r.action=s}function jf(r){var s=Cr(),o=Fn;if(o!==null)return Bf(s,o,r);Cr(),s=s.memoizedState,o=Cr();var c=o.queue.dispatch;return o.memoizedState=r,[s,c,!1]}function si(r,s,o,c){return r={tag:r,create:o,deps:c,inst:s,next:null},s=sn.updateQueue,s===null&&(s=Au(),sn.updateQueue=s),o=s.lastEffect,o===null?s.lastEffect=r.next=r:(c=o.next,o.next=r,r.next=c,s.lastEffect=r),r}function Lu(){return{destroy:void 0,resource:void 0}}function Nf(){return Cr().memoizedState}function zu(r,s,o,c){var g=ds();c=c===void 0?null:c,sn.flags|=r,g.memoizedState=si(1|s,Lu(),o,c)}function bl(r,s,o,c){var g=Cr();c=c===void 0?null:c;var M=g.memoizedState.inst;Fn!==null&&c!==null&&id(c,Fn.memoizedState.deps)?g.memoizedState=si(s,M,o,c):(sn.flags|=r,g.memoizedState=si(1|s,M,o,c))}function Uf(r,s){zu(8390656,8,r,s)}function Vf(r,s){bl(2048,8,r,s)}function Gf(r,s){return bl(4,2,r,s)}function Wf(r,s){return bl(4,4,r,s)}function Hf(r,s){if(typeof s=="function"){r=r();var o=s(r);return function(){typeof o=="function"?o():s(null)}}if(s!=null)return r=r(),s.current=r,function(){s.current=null}}function _d(r,s,o){o=o!=null?o.concat([r]):null,bl(4,4,Hf.bind(null,s,r),o)}function gd(){}function Kf(r,s){var o=Cr();s=s===void 0?null:s;var c=o.memoizedState;return s!==null&&id(s,c[1])?c[0]:(o.memoizedState=[r,s],r)}function yd(r,s){var o=Cr();s=s===void 0?null:s;var c=o.memoizedState;if(s!==null&&id(s,c[1]))return c[0];if(c=r(),Ui){pt(!0);try{r()}finally{pt(!1)}}return o.memoizedState=[c,s],c}function vd(r,s,o){return o===void 0||(ri&1073741824)!==0?r.memoizedState=s:(r.memoizedState=o,r=Hh(),sn.lanes|=r,ci|=r,o)}function qf(r,s,o,c){return Hr(o,s)?o:Ni.current!==null?(r=vd(r,o,c),Hr(r,s)||(Nr=!0),r):(ri&42)===0?(Nr=!0,r.memoizedState=o):(r=Hh(),sn.lanes|=r,ci|=r,s)}function Qf(r,s,o,c,g){var M=te.p;te.p=M!==0&&8>M?M:8;var j=W.T,Y={};W.T=Y,bd(r,!1,s,o);try{var he=g(),$e=W.S;if($e!==null&&$e(Y,he),he!==null&&typeof he=="object"&&typeof he.then=="function"){var Ze=Yp(he,c);Co(r,s,Ze,bs(r))}else Co(r,s,c,bs(r))}catch(tt){Co(r,s,{then:function(){},status:"rejected",reason:tt},bs())}finally{te.p=M,W.T=j}}function em(){}function Fu(r,s,o,c){if(r.tag!==5)throw Error(a(476));var g=Xf(r).queue;Qf(r,g,s,ie,o===null?em:function(){return Yf(r),o(c)})}function Xf(r){var s=r.memoizedState;if(s!==null)return s;s={memoizedState:ie,baseState:ie,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Pa,lastRenderedState:ie},next:null};var o={};return s.next={memoizedState:o,baseState:o,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Pa,lastRenderedState:o},next:null},r.memoizedState=s,r=r.alternate,r!==null&&(r.memoizedState=s),s}function Yf(r){var s=Xf(r).next.queue;Co(r,s,{},bs())}function Ru(){return Jr(up)}function Zf(){return Cr().memoizedState}function Jf(){return Cr().memoizedState}function eh(r){for(var s=r.return;s!==null;){switch(s.tag){case 24:case 3:var o=bs();r=ti(o);var c=ni(s,r,o);c!==null&&(zs(c,s,o),_l(c,s,o)),s={cache:Xc()},r.payload=s;return}s=s.return}}function tm(r,s,o){var c=bs();o={lane:c,revertLane:0,action:o,hasEagerState:!1,eagerState:null,next:null},Bu(r)?nh(s,o):(o=Rc(r,s,o,c),o!==null&&(zs(o,r,c),rh(o,s,c)))}function th(r,s,o){var c=bs();Co(r,s,o,c)}function Co(r,s,o,c){var g={lane:c,revertLane:0,action:o,hasEagerState:!1,eagerState:null,next:null};if(Bu(r))nh(s,g);else{var M=r.alternate;if(r.lanes===0&&(M===null||M.lanes===0)&&(M=s.lastRenderedReducer,M!==null))try{var j=s.lastRenderedState,Y=M(j,o);if(g.hasEagerState=!0,g.eagerState=Y,Hr(Y,j))return ol(r,s,g,0),Gn===null&&hu(),!1}catch{}finally{}if(o=Rc(r,s,g,c),o!==null)return zs(o,r,c),rh(o,s,c),!0}return!1}function bd(r,s,o,c){if(c={lane:2,revertLane:sp(),action:c,hasEagerState:!1,eagerState:null,next:null},Bu(r)){if(s)throw Error(a(479))}else s=Rc(r,o,c,2),s!==null&&zs(s,r,2)}function Bu(r){var s=r.alternate;return r===sn||s!==null&&s===sn}function nh(r,s){xo=Mo=!0;var o=r.pending;o===null?s.next=s:(s.next=o.next,o.next=s),r.pending=s}function rh(r,s,o){if((o&4194048)!==0){var c=s.lanes;c&=r.pendingLanes,o|=c,s.lanes=o,Zs(r,o)}}var ju={readContext:Jr,use:ku,useCallback:yr,useContext:yr,useEffect:yr,useImperativeHandle:yr,useLayoutEffect:yr,useInsertionEffect:yr,useMemo:yr,useReducer:yr,useRef:yr,useState:yr,useDebugValue:yr,useDeferredValue:yr,useTransition:yr,useSyncExternalStore:yr,useId:yr,useHostTransitionStatus:yr,useFormState:yr,useActionState:yr,useOptimistic:yr,useMemoCache:yr,useCacheRefresh:yr},sh={readContext:Jr,use:ku,useCallback:function(r,s){return ds().memoizedState=[r,s===void 0?null:s],r},useContext:Jr,useEffect:Uf,useImperativeHandle:function(r,s,o){o=o!=null?o.concat([r]):null,zu(4194308,4,Hf.bind(null,s,r),o)},useLayoutEffect:function(r,s){return zu(4194308,4,r,s)},useInsertionEffect:function(r,s){zu(4,2,r,s)},useMemo:function(r,s){var o=ds();s=s===void 0?null:s;var c=r();if(Ui){pt(!0);try{r()}finally{pt(!1)}}return o.memoizedState=[c,s],c},useReducer:function(r,s,o){var c=ds();if(o!==void 0){var g=o(s);if(Ui){pt(!0);try{o(s)}finally{pt(!1)}}}else g=s;return c.memoizedState=c.baseState=g,r={pending:null,lanes:0,dispatch:null,lastRenderedReducer:r,lastRenderedState:g},c.queue=r,r=r.dispatch=tm.bind(null,sn,r),[c.memoizedState,r]},useRef:function(r){var s=ds();return r={current:r},s.memoizedState=r},useState:function(r){r=hd(r);var s=r.queue,o=th.bind(null,sn,s);return s.dispatch=o,[r.memoizedState,o]},useDebugValue:gd,useDeferredValue:function(r,s){var o=ds();return vd(o,r,s)},useTransition:function(){var r=hd(!1);return r=Qf.bind(null,sn,r.queue,!0,!1),ds().memoizedState=r,[!1,r]},useSyncExternalStore:function(r,s,o){var c=sn,g=ds();if(bn){if(o===void 0)throw Error(a(407));o=o()}else{if(o=s(),Gn===null)throw Error(a(349));(pn&124)!==0||Af(c,s,o)}g.memoizedState=o;var M={value:o,getSnapshot:s};return g.queue=M,Uf(kf.bind(null,c,M,r),[r]),c.flags|=2048,si(9,Lu(),dd.bind(null,c,M,o,s),null),o},useId:function(){var r=ds(),s=Gn.identifierPrefix;if(bn){var o=Sa,c=Ea;o=(c&~(1<<32-lt(c)-1)).toString(32)+o,s=""+s+"R"+o,o=yl++,0<o&&(s+="H"+o.toString(32)),s+=""}else o=Sf++,s=""+s+"r"+o.toString(32)+"";return r.memoizedState=s},useHostTransitionStatus:Ru,useFormState:md,useActionState:md,useOptimistic:function(r){var s=ds();s.memoizedState=s.baseState=r;var o={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return s.queue=o,s=bd.bind(null,sn,!0,o),o.dispatch=s,[r,s]},useMemoCache:Ou,useCacheRefresh:function(){return ds().memoizedState=eh.bind(null,sn)}},ah={readContext:Jr,use:ku,useCallback:Kf,useContext:Jr,useEffect:Vf,useImperativeHandle:_d,useInsertionEffect:Gf,useLayoutEffect:Wf,useMemo:yd,useReducer:$u,useRef:Nf,useState:function(){return $u(Pa)},useDebugValue:gd,useDeferredValue:function(r,s){var o=Cr();return qf(o,Fn.memoizedState,r,s)},useTransition:function(){var r=$u(Pa)[0],s=Cr().memoizedState;return[typeof r=="boolean"?r:vl(r),s]},useSyncExternalStore:Pf,useId:Zf,useHostTransitionStatus:Ru,useFormState:Rf,useActionState:Rf,useOptimistic:function(r,s){var o=Cr();return $f(o,Fn,r,s)},useMemoCache:Ou,useCacheRefresh:Jf},nm={readContext:Jr,use:ku,useCallback:Kf,useContext:Jr,useEffect:Vf,useImperativeHandle:_d,useInsertionEffect:Gf,useLayoutEffect:Wf,useMemo:yd,useReducer:Du,useRef:Nf,useState:function(){return Du(Pa)},useDebugValue:gd,useDeferredValue:function(r,s){var o=Cr();return Fn===null?vd(o,r,s):qf(o,Fn.memoizedState,r,s)},useTransition:function(){var r=Du(Pa)[0],s=Cr().memoizedState;return[typeof r=="boolean"?r:vl(r),s]},useSyncExternalStore:Pf,useId:Zf,useHostTransitionStatus:Ru,useFormState:jf,useActionState:jf,useOptimistic:function(r,s){var o=Cr();return Fn!==null?$f(o,Fn,r,s):(o.baseState=r,[r,o.queue.dispatch])},useMemoCache:Ou,useCacheRefresh:Jf},Vi=null,wl=0;function Nu(r){var s=wl;return wl+=1,Vi===null&&(Vi=[]),nd(Vi,r,s)}function Ml(r,s){s=s.props.ref,r.ref=s!==void 0?s:null}function Uu(r,s){throw s.$$typeof===m?Error(a(525)):(r=Object.prototype.toString.call(s),Error(a(31,r==="[object Object]"?"object with keys {"+Object.keys(s).join(", ")+"}":r)))}function ih(r){var s=r._init;return s(r._payload)}function oh(r){function s(Me,ve){if(r){var Pe=Me.deletions;Pe===null?(Me.deletions=[ve],Me.flags|=16):Pe.push(ve)}}function o(Me,ve){if(!r)return null;for(;ve!==null;)s(Me,ve),ve=ve.sibling;return null}function c(Me){for(var ve=new Map;Me!==null;)Me.key!==null?ve.set(Me.key,Me):ve.set(Me.index,Me),Me=Me.sibling;return ve}function g(Me,ve){return Me=sa(Me,ve),Me.index=0,Me.sibling=null,Me}function M(Me,ve,Pe){return Me.index=Pe,r?(Pe=Me.alternate,Pe!==null?(Pe=Pe.index,Pe<ve?(Me.flags|=67108866,ve):Pe):(Me.flags|=67108866,ve)):(Me.flags|=1048576,ve)}function j(Me){return r&&Me.alternate===null&&(Me.flags|=67108866),Me}function Y(Me,ve,Pe,Je){return ve===null||ve.tag!==6?(ve=Nc(Pe,Me.mode,Je),ve.return=Me,ve):(ve=g(ve,Pe),ve.return=Me,ve)}function he(Me,ve,Pe,Je){var Dt=Pe.type;return Dt===v?Ze(Me,ve,Pe.props.children,Je,Pe.key):ve!==null&&(ve.elementType===Dt||typeof Dt=="object"&&Dt!==null&&Dt.$$typeof===D&&ih(Dt)===ve.type)?(ve=g(ve,Pe.props),Ml(ve,Pe),ve.return=Me,ve):(ve=mu(Pe.type,Pe.key,Pe.props,null,Me.mode,Je),Ml(ve,Pe),ve.return=Me,ve)}function $e(Me,ve,Pe,Je){return ve===null||ve.tag!==4||ve.stateNode.containerInfo!==Pe.containerInfo||ve.stateNode.implementation!==Pe.implementation?(ve=Uc(Pe,Me.mode,Je),ve.return=Me,ve):(ve=g(ve,Pe.children||[]),ve.return=Me,ve)}function Ze(Me,ve,Pe,Je,Dt){return ve===null||ve.tag!==7?(ve=Ka(Pe,Me.mode,Je,Dt),ve.return=Me,ve):(ve=g(ve,Pe),ve.return=Me,ve)}function tt(Me,ve,Pe){if(typeof ve=="string"&&ve!==""||typeof ve=="number"||typeof ve=="bigint")return ve=Nc(""+ve,Me.mode,Pe),ve.return=Me,ve;if(typeof ve=="object"&&ve!==null){switch(ve.$$typeof){case p:return Pe=mu(ve.type,ve.key,ve.props,null,Me.mode,Pe),Ml(Pe,ve),Pe.return=Me,Pe;case y:return ve=Uc(ve,Me.mode,Pe),ve.return=Me,ve;case D:var Je=ve._init;return ve=Je(ve._payload),tt(Me,ve,Pe)}if(ae(ve)||ee(ve))return ve=Ka(ve,Me.mode,Pe,null),ve.return=Me,ve;if(typeof ve.then=="function")return tt(Me,Nu(ve),Pe);if(ve.$$typeof===I)return tt(Me,bu(Me,ve),Pe);Uu(Me,ve)}return null}function Le(Me,ve,Pe,Je){var Dt=ve!==null?ve.key:null;if(typeof Pe=="string"&&Pe!==""||typeof Pe=="number"||typeof Pe=="bigint")return Dt!==null?null:Y(Me,ve,""+Pe,Je);if(typeof Pe=="object"&&Pe!==null){switch(Pe.$$typeof){case p:return Pe.key===Dt?he(Me,ve,Pe,Je):null;case y:return Pe.key===Dt?$e(Me,ve,Pe,Je):null;case D:return Dt=Pe._init,Pe=Dt(Pe._payload),Le(Me,ve,Pe,Je)}if(ae(Pe)||ee(Pe))return Dt!==null?null:Ze(Me,ve,Pe,Je,null);if(typeof Pe.then=="function")return Le(Me,ve,Nu(Pe),Je);if(Pe.$$typeof===I)return Le(Me,ve,bu(Me,Pe),Je);Uu(Me,Pe)}return null}function Fe(Me,ve,Pe,Je,Dt){if(typeof Je=="string"&&Je!==""||typeof Je=="number"||typeof Je=="bigint")return Me=Me.get(Pe)||null,Y(ve,Me,""+Je,Dt);if(typeof Je=="object"&&Je!==null){switch(Je.$$typeof){case p:return Me=Me.get(Je.key===null?Pe:Je.key)||null,he(ve,Me,Je,Dt);case y:return Me=Me.get(Je.key===null?Pe:Je.key)||null,$e(ve,Me,Je,Dt);case D:var hn=Je._init;return Je=hn(Je._payload),Fe(Me,ve,Pe,Je,Dt)}if(ae(Je)||ee(Je))return Me=Me.get(Pe)||null,Ze(ve,Me,Je,Dt,null);if(typeof Je.then=="function")return Fe(Me,ve,Pe,Nu(Je),Dt);if(Je.$$typeof===I)return Fe(Me,ve,Pe,bu(ve,Je),Dt);Uu(ve,Je)}return null}function Jt(Me,ve,Pe,Je){for(var Dt=null,hn=null,Rt=ve,Ht=ve=0,is=null;Rt!==null&&Ht<Pe.length;Ht++){Rt.index>Ht?(is=Rt,Rt=null):is=Rt.sibling;var zn=Le(Me,Rt,Pe[Ht],Je);if(zn===null){Rt===null&&(Rt=is);break}r&&Rt&&zn.alternate===null&&s(Me,Rt),ve=M(zn,ve,Ht),hn===null?Dt=zn:hn.sibling=zn,hn=zn,Rt=is}if(Ht===Pe.length)return o(Me,Rt),bn&&Qa(Me,Ht),Dt;if(Rt===null){for(;Ht<Pe.length;Ht++)Rt=tt(Me,Pe[Ht],Je),Rt!==null&&(ve=M(Rt,ve,Ht),hn===null?Dt=Rt:hn.sibling=Rt,hn=Rt);return bn&&Qa(Me,Ht),Dt}for(Rt=c(Rt);Ht<Pe.length;Ht++)is=Fe(Rt,Me,Ht,Pe[Ht],Je),is!==null&&(r&&is.alternate!==null&&Rt.delete(is.key===null?Ht:is.key),ve=M(is,ve,Ht),hn===null?Dt=is:hn.sibling=is,hn=is);return r&&Rt.forEach(function(Rl){return s(Me,Rl)}),bn&&Qa(Me,Ht),Dt}function Gt(Me,ve,Pe,Je){if(Pe==null)throw Error(a(151));for(var Dt=null,hn=null,Rt=ve,Ht=ve=0,is=null,zn=Pe.next();Rt!==null&&!zn.done;Ht++,zn=Pe.next()){Rt.index>Ht?(is=Rt,Rt=null):is=Rt.sibling;var Rl=Le(Me,Rt,zn.value,Je);if(Rl===null){Rt===null&&(Rt=is);break}r&&Rt&&Rl.alternate===null&&s(Me,Rt),ve=M(Rl,ve,Ht),hn===null?Dt=Rl:hn.sibling=Rl,hn=Rl,Rt=is}if(zn.done)return o(Me,Rt),bn&&Qa(Me,Ht),Dt;if(Rt===null){for(;!zn.done;Ht++,zn=Pe.next())zn=tt(Me,zn.value,Je),zn!==null&&(ve=M(zn,ve,Ht),hn===null?Dt=zn:hn.sibling=zn,hn=zn);return bn&&Qa(Me,Ht),Dt}for(Rt=c(Rt);!zn.done;Ht++,zn=Pe.next())zn=Fe(Rt,Me,Ht,zn.value,Je),zn!==null&&(r&&zn.alternate!==null&&Rt.delete(zn.key===null?Ht:zn.key),ve=M(zn,ve,Ht),hn===null?Dt=zn:hn.sibling=zn,hn=zn);return r&&Rt.forEach(function(dC){return s(Me,dC)}),bn&&Qa(Me,Ht),Dt}function Qn(Me,ve,Pe,Je){if(typeof Pe=="object"&&Pe!==null&&Pe.type===v&&Pe.key===null&&(Pe=Pe.props.children),typeof Pe=="object"&&Pe!==null){switch(Pe.$$typeof){case p:e:{for(var Dt=Pe.key;ve!==null;){if(ve.key===Dt){if(Dt=Pe.type,Dt===v){if(ve.tag===7){o(Me,ve.sibling),Je=g(ve,Pe.props.children),Je.return=Me,Me=Je;break e}}else if(ve.elementType===Dt||typeof Dt=="object"&&Dt!==null&&Dt.$$typeof===D&&ih(Dt)===ve.type){o(Me,ve.sibling),Je=g(ve,Pe.props),Ml(Je,Pe),Je.return=Me,Me=Je;break e}o(Me,ve);break}else s(Me,ve);ve=ve.sibling}Pe.type===v?(Je=Ka(Pe.props.children,Me.mode,Je,Pe.key),Je.return=Me,Me=Je):(Je=mu(Pe.type,Pe.key,Pe.props,null,Me.mode,Je),Ml(Je,Pe),Je.return=Me,Me=Je)}return j(Me);case y:e:{for(Dt=Pe.key;ve!==null;){if(ve.key===Dt)if(ve.tag===4&&ve.stateNode.containerInfo===Pe.containerInfo&&ve.stateNode.implementation===Pe.implementation){o(Me,ve.sibling),Je=g(ve,Pe.children||[]),Je.return=Me,Me=Je;break e}else{o(Me,ve);break}else s(Me,ve);ve=ve.sibling}Je=Uc(Pe,Me.mode,Je),Je.return=Me,Me=Je}return j(Me);case D:return Dt=Pe._init,Pe=Dt(Pe._payload),Qn(Me,ve,Pe,Je)}if(ae(Pe))return Jt(Me,ve,Pe,Je);if(ee(Pe)){if(Dt=ee(Pe),typeof Dt!="function")throw Error(a(150));return Pe=Dt.call(Pe),Gt(Me,ve,Pe,Je)}if(typeof Pe.then=="function")return Qn(Me,ve,Nu(Pe),Je);if(Pe.$$typeof===I)return Qn(Me,ve,bu(Me,Pe),Je);Uu(Me,Pe)}return typeof Pe=="string"&&Pe!==""||typeof Pe=="number"||typeof Pe=="bigint"?(Pe=""+Pe,ve!==null&&ve.tag===6?(o(Me,ve.sibling),Je=g(ve,Pe),Je.return=Me,Me=Je):(o(Me,ve),Je=Nc(Pe,Me.mode,Je),Je.return=Me,Me=Je),j(Me)):o(Me,ve)}return function(Me,ve,Pe,Je){try{wl=0;var Dt=Qn(Me,ve,Pe,Je);return Vi=null,Dt}catch(Rt){if(Rt===pl||Rt===Mu)throw Rt;var hn=_s(29,Rt,null,Me.mode);return hn.lanes=Je,hn.return=Me,hn}finally{}}}var Gi=oh(!0),lh=oh(!1),Is=B(null),Hs=null;function ai(r){var s=r.alternate;Q(zr,zr.current&1),Q(Is,r),Hs===null&&(s===null||Ni.current!==null||s.memoizedState!==null)&&(Hs=r)}function uh(r){if(r.tag===22){if(Q(zr,zr.current),Q(Is,r),Hs===null){var s=r.alternate;s!==null&&s.memoizedState!==null&&(Hs=r)}}else fs()}function fs(){Q(zr,zr.current),Q(Is,Is.current)}function Aa(r){R(Is),Hs===r&&(Hs=null),R(zr)}var zr=B(0);function Vu(r){for(var s=r;s!==null;){if(s.tag===13){var o=s.memoizedState;if(o!==null&&(o=o.dehydrated,o===null||o.data==="$?"||Mr(o)))return s}else if(s.tag===19&&s.memoizedProps.revealOrder!==void 0){if((s.flags&128)!==0)return s}else if(s.child!==null){s.child.return=s,s=s.child;continue}if(s===r)break;for(;s.sibling===null;){if(s.return===null||s.return===r)return null;s=s.return}s.sibling.return=s.return,s=s.sibling}return null}function wd(r,s,o,c){s=r.memoizedState,o=o(c,s),o=o==null?s:_({},s,o),r.memoizedState=o,r.lanes===0&&(r.updateQueue.baseState=o)}var Gu={enqueueSetState:function(r,s,o){r=r._reactInternals;var c=bs(),g=ti(c);g.payload=s,o!=null&&(g.callback=o),s=ni(r,g,c),s!==null&&(zs(s,r,c),_l(s,r,c))},enqueueReplaceState:function(r,s,o){r=r._reactInternals;var c=bs(),g=ti(c);g.tag=1,g.payload=s,o!=null&&(g.callback=o),s=ni(r,g,c),s!==null&&(zs(s,r,c),_l(s,r,c))},enqueueForceUpdate:function(r,s){r=r._reactInternals;var o=bs(),c=ti(o);c.tag=2,s!=null&&(c.callback=s),s=ni(r,c,o),s!==null&&(zs(s,r,o),_l(s,r,o))}};function ch(r,s,o,c,g,M,j){return r=r.stateNode,typeof r.shouldComponentUpdate=="function"?r.shouldComponentUpdate(c,M,j):s.prototype&&s.prototype.isPureReactComponent?!Ha(o,c)||!Ha(g,M):!0}function dh(r,s,o,c){r=s.state,typeof s.componentWillReceiveProps=="function"&&s.componentWillReceiveProps(o,c),typeof s.UNSAFE_componentWillReceiveProps=="function"&&s.UNSAFE_componentWillReceiveProps(o,c),s.state!==r&&Gu.enqueueReplaceState(s,s.state,null)}function Wi(r,s){var o=s;if("ref"in s){o={};for(var c in s)c!=="ref"&&(o[c]=s[c])}if(r=r.defaultProps){o===s&&(o=_({},o));for(var g in r)o[g]===void 0&&(o[g]=r[g])}return o}var Wu=typeof reportError=="function"?reportError:function(r){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var s=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof r=="object"&&r!==null&&typeof r.message=="string"?String(r.message):String(r),error:r});if(!window.dispatchEvent(s))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",r);return}console.error(r)};function Hu(r){Wu(r)}function fh(r){console.error(r)}function hh(r){Wu(r)}function Ku(r,s){try{var o=r.onUncaughtError;o(s.value,{componentStack:s.stack})}catch(c){setTimeout(function(){throw c})}}function xl(r,s,o){try{var c=r.onCaughtError;c(o.value,{componentStack:o.stack,errorBoundary:s.tag===1?s.stateNode:null})}catch(g){setTimeout(function(){throw g})}}function Md(r,s,o){return o=ti(o),o.tag=3,o.payload={element:null},o.callback=function(){Ku(r,s)},o}function ph(r){return r=ti(r),r.tag=3,r}function mh(r,s,o,c){var g=o.type.getDerivedStateFromError;if(typeof g=="function"){var M=c.value;r.payload=function(){return g(M)},r.callback=function(){xl(s,o,c)}}var j=o.stateNode;j!==null&&typeof j.componentDidCatch=="function"&&(r.callback=function(){xl(s,o,c),typeof g!="function"&&(di===null?di=new Set([this]):di.add(this));var Y=c.stack;this.componentDidCatch(c.value,{componentStack:Y!==null?Y:""})})}function rm(r,s,o,c,g){if(o.flags|=32768,c!==null&&typeof c=="object"&&typeof c.then=="function"){if(s=o.alternate,s!==null&&fl(s,o,g,!0),o=Is.current,o!==null){switch(o.tag){case 13:return Hs===null?Ud():o.alternate===null&&dr===0&&(dr=3),o.flags&=-257,o.flags|=65536,o.lanes=g,c===td?o.flags|=16384:(s=o.updateQueue,s===null?o.updateQueue=new Set([c]):s.add(c),tp(r,c,g)),!1;case 22:return o.flags|=65536,c===td?o.flags|=16384:(s=o.updateQueue,s===null?(s={transitions:null,markerInstances:null,retryQueue:new Set([c])},o.updateQueue=s):(o=s.retryQueue,o===null?s.retryQueue=new Set([c]):o.add(c)),tp(r,c,g)),!1}throw Error(a(435,o.tag))}return tp(r,c,g),Ud(),!1}if(bn)return s=Is.current,s!==null?((s.flags&65536)===0&&(s.flags|=256),s.flags|=65536,s.lanes=g,c!==yu&&(r=Error(a(422),{cause:c}),dl(Pn(r,o)))):(c!==yu&&(s=Error(a(423),{cause:c}),dl(Pn(s,o))),r=r.current.alternate,r.flags|=65536,g&=-g,r.lanes|=g,c=Pn(c,o),g=Md(r.stateNode,c,g),Eu(r,g),dr!==4&&(dr=2)),!1;var M=Error(a(520),{cause:c});if(M=Pn(M,o),fn===null?fn=[M]:fn.push(M),dr!==4&&(dr=2),s===null)return!0;c=Pn(c,o),o=s;do{switch(o.tag){case 3:return o.flags|=65536,r=g&-g,o.lanes|=r,r=Md(o.stateNode,c,r),Eu(o,r),!1;case 1:if(s=o.type,M=o.stateNode,(o.flags&128)===0&&(typeof s.getDerivedStateFromError=="function"||M!==null&&typeof M.componentDidCatch=="function"&&(di===null||!di.has(M))))return o.flags|=65536,g&=-g,o.lanes|=g,g=ph(g),mh(g,r,o,c),Eu(o,g),!1}o=o.return}while(o!==null);return!1}var qu=Error(a(461)),Nr=!1;function Kr(r,s,o,c){s.child=r===null?lh(s,null,o,c):Gi(s,r.child,o,c)}function _h(r,s,o,c,g){o=o.render;var M=s.ref;if("ref"in c){var j={};for(var Y in c)Y!=="ref"&&(j[Y]=c[Y])}else j=c;return Za(s),c=So(r,s,o,j,M,g),Y=ld(),r!==null&&!Nr?(Pu(r,s,g),oa(r,s,g)):(bn&&Y&&Vc(s),s.flags|=1,Kr(r,s,c,g),s.child)}function sm(r,s,o,c,g){if(r===null){var M=o.type;return typeof M=="function"&&!jc(M)&&M.defaultProps===void 0&&o.compare===null?(s.tag=15,s.type=M,gh(r,s,M,c,g)):(r=mu(o.type,null,c,s,s.mode,g),r.ref=s.ref,r.return=s,s.child=r)}if(M=r.child,!Ad(r,g)){var j=M.memoizedProps;if(o=o.compare,o=o!==null?o:Ha,o(j,c)&&r.ref===s.ref)return oa(r,s,g)}return s.flags|=1,r=sa(M,c),r.ref=s.ref,r.return=s,s.child=r}function gh(r,s,o,c,g){if(r!==null){var M=r.memoizedProps;if(Ha(M,c)&&r.ref===s.ref)if(Nr=!1,s.pendingProps=c=M,Ad(r,g))(r.flags&131072)!==0&&(Nr=!0);else return s.lanes=r.lanes,oa(r,s,g)}return xd(r,s,o,c,g)}function yh(r,s,o){var c=s.pendingProps,g=c.children,M=r!==null?r.memoizedState:null;if(c.mode==="hidden"){if((s.flags&128)!==0){if(c=M!==null?M.baseLanes|o:o,r!==null){for(g=s.child=r.child,M=0;g!==null;)M=M|g.lanes|g.childLanes,g=g.sibling;s.childLanes=M&~c}else s.childLanes=0,s.child=null;return vh(r,s,c,o)}if((o&536870912)!==0)s.memoizedState={baseLanes:0,cachePool:null},r!==null&&wu(s,M!==null?M.cachePool:null),M!==null?Ef(s,M):Cu(),uh(s);else return s.lanes=s.childLanes=536870912,vh(r,s,M!==null?M.baseLanes|o:o,o)}else M!==null?(wu(s,M.cachePool),Ef(s,M),fs(),s.memoizedState=null):(r!==null&&wu(s,null),Cu(),fs());return Kr(r,s,g,o),s.child}function vh(r,s,o,c){var g=Jc();return g=g===null?null:{parent:Lr._currentValue,pool:g},s.memoizedState={baseLanes:o,cachePool:g},r!==null&&wu(s,null),Cu(),uh(s),r!==null&&fl(r,s,c,!0),null}function ii(r,s){var o=s.ref;if(o===null)r!==null&&r.ref!==null&&(s.flags|=4194816);else{if(typeof o!="function"&&typeof o!="object")throw Error(a(284));(r===null||r.ref!==o)&&(s.flags|=4194816)}}function xd(r,s,o,c,g){return Za(s),o=So(r,s,o,c,void 0,g),c=ld(),r!==null&&!Nr?(Pu(r,s,g),oa(r,s,g)):(bn&&c&&Vc(s),s.flags|=1,Kr(r,s,o,g),s.child)}function bh(r,s,o,c,g,M){return Za(s),s.updateQueue=null,o=Cf(s,c,o,g),od(r),c=ld(),r!==null&&!Nr?(Pu(r,s,M),oa(r,s,M)):(bn&&c&&Vc(s),s.flags|=1,Kr(r,s,o,M),s.child)}function wh(r,s,o,c,g){if(Za(s),s.stateNode===null){var M=go,j=o.contextType;typeof j=="object"&&j!==null&&(M=Jr(j)),M=new o(c,M),s.memoizedState=M.state!==null&&M.state!==void 0?M.state:null,M.updater=Gu,s.stateNode=M,M._reactInternals=s,M=s.stateNode,M.props=c,M.state=s.memoizedState,M.refs={},Tu(s),j=o.contextType,M.context=typeof j=="object"&&j!==null?Jr(j):go,M.state=s.memoizedState,j=o.getDerivedStateFromProps,typeof j=="function"&&(wd(s,o,j,c),M.state=s.memoizedState),typeof o.getDerivedStateFromProps=="function"||typeof M.getSnapshotBeforeUpdate=="function"||typeof M.UNSAFE_componentWillMount!="function"&&typeof M.componentWillMount!="function"||(j=M.state,typeof M.componentWillMount=="function"&&M.componentWillMount(),typeof M.UNSAFE_componentWillMount=="function"&&M.UNSAFE_componentWillMount(),j!==M.state&&Gu.enqueueReplaceState(M,M.state,null),wo(s,c,M,g),gl(),M.state=s.memoizedState),typeof M.componentDidMount=="function"&&(s.flags|=4194308),c=!0}else if(r===null){M=s.stateNode;var Y=s.memoizedProps,he=Wi(o,Y);M.props=he;var $e=M.context,Ze=o.contextType;j=go,typeof Ze=="object"&&Ze!==null&&(j=Jr(Ze));var tt=o.getDerivedStateFromProps;Ze=typeof tt=="function"||typeof M.getSnapshotBeforeUpdate=="function",Y=s.pendingProps!==Y,Ze||typeof M.UNSAFE_componentWillReceiveProps!="function"&&typeof M.componentWillReceiveProps!="function"||(Y||$e!==j)&&dh(s,M,c,j),ei=!1;var Le=s.memoizedState;M.state=Le,wo(s,c,M,g),gl(),$e=s.memoizedState,Y||Le!==$e||ei?(typeof tt=="function"&&(wd(s,o,tt,c),$e=s.memoizedState),(he=ei||ch(s,o,he,c,Le,$e,j))?(Ze||typeof M.UNSAFE_componentWillMount!="function"&&typeof M.componentWillMount!="function"||(typeof M.componentWillMount=="function"&&M.componentWillMount(),typeof M.UNSAFE_componentWillMount=="function"&&M.UNSAFE_componentWillMount()),typeof M.componentDidMount=="function"&&(s.flags|=4194308)):(typeof M.componentDidMount=="function"&&(s.flags|=4194308),s.memoizedProps=c,s.memoizedState=$e),M.props=c,M.state=$e,M.context=j,c=he):(typeof M.componentDidMount=="function"&&(s.flags|=4194308),c=!1)}else{M=s.stateNode,rd(r,s),j=s.memoizedProps,Ze=Wi(o,j),M.props=Ze,tt=s.pendingProps,Le=M.context,$e=o.contextType,he=go,typeof $e=="object"&&$e!==null&&(he=Jr($e)),Y=o.getDerivedStateFromProps,($e=typeof Y=="function"||typeof M.getSnapshotBeforeUpdate=="function")||typeof M.UNSAFE_componentWillReceiveProps!="function"&&typeof M.componentWillReceiveProps!="function"||(j!==tt||Le!==he)&&dh(s,M,c,he),ei=!1,Le=s.memoizedState,M.state=Le,wo(s,c,M,g),gl();var Fe=s.memoizedState;j!==tt||Le!==Fe||ei||r!==null&&r.dependencies!==null&&vu(r.dependencies)?(typeof Y=="function"&&(wd(s,o,Y,c),Fe=s.memoizedState),(Ze=ei||ch(s,o,Ze,c,Le,Fe,he)||r!==null&&r.dependencies!==null&&vu(r.dependencies))?($e||typeof M.UNSAFE_componentWillUpdate!="function"&&typeof M.componentWillUpdate!="function"||(typeof M.componentWillUpdate=="function"&&M.componentWillUpdate(c,Fe,he),typeof M.UNSAFE_componentWillUpdate=="function"&&M.UNSAFE_componentWillUpdate(c,Fe,he)),typeof M.componentDidUpdate=="function"&&(s.flags|=4),typeof M.getSnapshotBeforeUpdate=="function"&&(s.flags|=1024)):(typeof M.componentDidUpdate!="function"||j===r.memoizedProps&&Le===r.memoizedState||(s.flags|=4),typeof M.getSnapshotBeforeUpdate!="function"||j===r.memoizedProps&&Le===r.memoizedState||(s.flags|=1024),s.memoizedProps=c,s.memoizedState=Fe),M.props=c,M.state=Fe,M.context=he,c=Ze):(typeof M.componentDidUpdate!="function"||j===r.memoizedProps&&Le===r.memoizedState||(s.flags|=4),typeof M.getSnapshotBeforeUpdate!="function"||j===r.memoizedProps&&Le===r.memoizedState||(s.flags|=1024),c=!1)}return M=c,ii(r,s),c=(s.flags&128)!==0,M||c?(M=s.stateNode,o=c&&typeof o.getDerivedStateFromError!="function"?null:M.render(),s.flags|=1,r!==null&&c?(s.child=Gi(s,r.child,null,g),s.child=Gi(s,null,o,g)):Kr(r,s,o,g),s.memoizedState=M.state,r=s.child):r=oa(r,s,g),r}function Mh(r,s,o,c){return cl(),s.flags|=256,Kr(r,s,o,c),s.child}var Td={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Ed(r){return{baseLanes:r,cachePool:vf()}}function Sd(r,s,o){return r=r!==null?r.childLanes&~o:0,s&&(r|=Ls),r}function Qu(r,s,o){var c=s.pendingProps,g=!1,M=(s.flags&128)!==0,j;if((j=M)||(j=r!==null&&r.memoizedState===null?!1:(zr.current&2)!==0),j&&(g=!0,s.flags&=-129),j=(s.flags&32)!==0,s.flags&=-33,r===null){if(bn){if(g?ai(s):fs(),bn){var Y=cr,he;if(he=Y){e:{for(he=Y,Y=aa;he.nodeType!==8;){if(!Y){Y=null;break e}if(he=es(he.nextSibling),he===null){Y=null;break e}}Y=he}Y!==null?(s.memoizedState={dehydrated:Y,treeContext:qa!==null?{id:Ea,overflow:Sa}:null,retryLane:536870912,hydrationErrors:null},he=_s(18,null,null,0),he.stateNode=Y,he.return=s,s.child=he,rs=s,cr=null,he=!0):he=!1}he||Bi(s)}if(Y=s.memoizedState,Y!==null&&(Y=Y.dehydrated,Y!==null))return Mr(Y)?s.lanes=32:s.lanes=536870912,null;Aa(s)}return Y=c.children,c=c.fallback,g?(fs(),g=s.mode,Y=Xu({mode:"hidden",children:Y},g),c=Ka(c,g,o,null),Y.return=s,c.return=s,Y.sibling=c,s.child=Y,g=s.child,g.memoizedState=Ed(o),g.childLanes=Sd(r,j,o),s.memoizedState=Td,c):(ai(s),xh(s,Y))}if(he=r.memoizedState,he!==null&&(Y=he.dehydrated,Y!==null)){if(M)s.flags&256?(ai(s),s.flags&=-257,s=Cd(r,s,o)):s.memoizedState!==null?(fs(),s.child=r.child,s.flags|=128,s=null):(fs(),g=c.fallback,Y=s.mode,c=Xu({mode:"visible",children:c.children},Y),g=Ka(g,Y,o,null),g.flags|=2,c.return=s,g.return=s,c.sibling=g,s.child=c,Gi(s,r.child,null,o),c=s.child,c.memoizedState=Ed(o),c.childLanes=Sd(r,j,o),s.memoizedState=Td,s=g);else if(ai(s),Mr(Y)){if(j=Y.nextSibling&&Y.nextSibling.dataset,j)var $e=j.dgst;j=$e,c=Error(a(419)),c.stack="",c.digest=j,dl({value:c,source:null,stack:null}),s=Cd(r,s,o)}else if(Nr||fl(r,s,o,!1),j=(o&r.childLanes)!==0,Nr||j){if(j=Gn,j!==null&&(c=o&-o,c=(c&42)!==0?1:En(c),c=(c&(j.suspendedLanes|o))!==0?0:c,c!==0&&c!==he.retryLane))throw he.retryLane=c,_o(r,c),zs(j,r,c),qu;Y.data==="$?"||Ud(),s=Cd(r,s,o)}else Y.data==="$?"?(s.flags|=192,s.child=r.child,s=null):(r=he.treeContext,cr=es(Y.nextSibling),rs=s,bn=!0,Ri=null,aa=!1,r!==null&&($s[Ds++]=Ea,$s[Ds++]=Sa,$s[Ds++]=qa,Ea=r.id,Sa=r.overflow,qa=s),s=xh(s,c.children),s.flags|=4096);return s}return g?(fs(),g=c.fallback,Y=s.mode,he=r.child,$e=he.sibling,c=sa(he,{mode:"hidden",children:c.children}),c.subtreeFlags=he.subtreeFlags&65011712,$e!==null?g=sa($e,g):(g=Ka(g,Y,o,null),g.flags|=2),g.return=s,c.return=s,c.sibling=g,s.child=c,c=g,g=s.child,Y=r.child.memoizedState,Y===null?Y=Ed(o):(he=Y.cachePool,he!==null?($e=Lr._currentValue,he=he.parent!==$e?{parent:$e,pool:$e}:he):he=vf(),Y={baseLanes:Y.baseLanes|o,cachePool:he}),g.memoizedState=Y,g.childLanes=Sd(r,j,o),s.memoizedState=Td,c):(ai(s),o=r.child,r=o.sibling,o=sa(o,{mode:"visible",children:c.children}),o.return=s,o.sibling=null,r!==null&&(j=s.deletions,j===null?(s.deletions=[r],s.flags|=16):j.push(r)),s.child=o,s.memoizedState=null,o)}function xh(r,s){return s=Xu({mode:"visible",children:s},r.mode),s.return=r,r.child=s}function Xu(r,s){return r=_s(22,r,null,s),r.lanes=0,r.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},r}function Cd(r,s,o){return Gi(s,r.child,null,o),r=xh(s,s.pendingProps.children),r.flags|=2,s.memoizedState=null,r}function Th(r,s,o){r.lanes|=s;var c=r.alternate;c!==null&&(c.lanes|=s),Kc(r.return,s,o)}function Pd(r,s,o,c,g){var M=r.memoizedState;M===null?r.memoizedState={isBackwards:s,rendering:null,renderingStartTime:0,last:c,tail:o,tailMode:g}:(M.isBackwards=s,M.rendering=null,M.renderingStartTime=0,M.last=c,M.tail=o,M.tailMode=g)}function Eh(r,s,o){var c=s.pendingProps,g=c.revealOrder,M=c.tail;if(Kr(r,s,c.children,o),c=zr.current,(c&2)!==0)c=c&1|2,s.flags|=128;else{if(r!==null&&(r.flags&128)!==0)e:for(r=s.child;r!==null;){if(r.tag===13)r.memoizedState!==null&&Th(r,o,s);else if(r.tag===19)Th(r,o,s);else if(r.child!==null){r.child.return=r,r=r.child;continue}if(r===s)break e;for(;r.sibling===null;){if(r.return===null||r.return===s)break e;r=r.return}r.sibling.return=r.return,r=r.sibling}c&=1}switch(Q(zr,c),g){case"forwards":for(o=s.child,g=null;o!==null;)r=o.alternate,r!==null&&Vu(r)===null&&(g=o),o=o.sibling;o=g,o===null?(g=s.child,s.child=null):(g=o.sibling,o.sibling=null),Pd(s,!1,g,o,M);break;case"backwards":for(o=null,g=s.child,s.child=null;g!==null;){if(r=g.alternate,r!==null&&Vu(r)===null){s.child=g;break}r=g.sibling,g.sibling=o,o=g,g=r}Pd(s,!0,o,null,M);break;case"together":Pd(s,!1,null,null,void 0);break;default:s.memoizedState=null}return s.child}function oa(r,s,o){if(r!==null&&(s.dependencies=r.dependencies),ci|=s.lanes,(o&s.childLanes)===0)if(r!==null){if(fl(r,s,o,!1),(o&s.childLanes)===0)return null}else return null;if(r!==null&&s.child!==r.child)throw Error(a(153));if(s.child!==null){for(r=s.child,o=sa(r,r.pendingProps),s.child=o,o.return=s;r.sibling!==null;)r=r.sibling,o=o.sibling=sa(r,r.pendingProps),o.return=s;o.sibling=null}return s.child}function Ad(r,s){return(r.lanes&s)!==0?!0:(r=r.dependencies,!!(r!==null&&vu(r)))}function am(r,s,o){switch(s.tag){case 3:Ue(s,s.stateNode.containerInfo),Ya(s,Lr,r.memoizedState.cache),cl();break;case 27:case 5:je(s);break;case 4:Ue(s,s.stateNode.containerInfo);break;case 10:Ya(s,s.type,s.memoizedProps.value);break;case 13:var c=s.memoizedState;if(c!==null)return c.dehydrated!==null?(ai(s),s.flags|=128,null):(o&s.child.childLanes)!==0?Qu(r,s,o):(ai(s),r=oa(r,s,o),r!==null?r.sibling:null);ai(s);break;case 19:var g=(r.flags&128)!==0;if(c=(o&s.childLanes)!==0,c||(fl(r,s,o,!1),c=(o&s.childLanes)!==0),g){if(c)return Eh(r,s,o);s.flags|=128}if(g=s.memoizedState,g!==null&&(g.rendering=null,g.tail=null,g.lastEffect=null),Q(zr,zr.current),c)break;return null;case 22:case 23:return s.lanes=0,yh(r,s,o);case 24:Ya(s,Lr,r.memoizedState.cache)}return oa(r,s,o)}function kd(r,s,o){if(r!==null)if(r.memoizedProps!==s.pendingProps)Nr=!0;else{if(!Ad(r,o)&&(s.flags&128)===0)return Nr=!1,am(r,s,o);Nr=(r.flags&131072)!==0}else Nr=!1,bn&&(s.flags&1048576)!==0&&mf(s,ll,s.index);switch(s.lanes=0,s.tag){case 16:e:{r=s.pendingProps;var c=s.elementType,g=c._init;if(c=g(c._payload),s.type=c,typeof c=="function")jc(c)?(r=Wi(c,r),s.tag=1,s=wh(null,s,c,r,o)):(s.tag=0,s=xd(null,s,c,r,o));else{if(c!=null){if(g=c.$$typeof,g===P){s.tag=11,s=_h(null,s,c,r,o);break e}else if(g===C){s.tag=14,s=sm(null,s,c,r,o);break e}}throw s=oe(c)||c,Error(a(306,s,""))}}return s;case 0:return xd(r,s,s.type,s.pendingProps,o);case 1:return c=s.type,g=Wi(c,s.pendingProps),wh(r,s,c,g,o);case 3:e:{if(Ue(s,s.stateNode.containerInfo),r===null)throw Error(a(387));c=s.pendingProps;var M=s.memoizedState;g=M.element,rd(r,s),wo(s,c,null,o);var j=s.memoizedState;if(c=j.cache,Ya(s,Lr,c),c!==M.cache&&qc(s,[Lr],o,!0),gl(),c=j.element,M.isDehydrated)if(M={element:c,isDehydrated:!1,cache:j.cache},s.updateQueue.baseState=M,s.memoizedState=M,s.flags&256){s=Mh(r,s,c,o);break e}else if(c!==g){g=Pn(Error(a(424)),s),dl(g),s=Mh(r,s,c,o);break e}else{switch(r=s.stateNode.containerInfo,r.nodeType){case 9:r=r.body;break;default:r=r.nodeName==="HTML"?r.ownerDocument.body:r}for(cr=es(r.firstChild),rs=s,bn=!0,Ri=null,aa=!0,o=lh(s,null,c,o),s.child=o;o;)o.flags=o.flags&-3|4096,o=o.sibling}else{if(cl(),c===g){s=oa(r,s,o);break e}Kr(r,s,c,o)}s=s.child}return s;case 26:return ii(r,s),r===null?(o=uv(s.type,null,s.pendingProps,null))?s.memoizedState=o:bn||(o=s.type,r=s.pendingProps,c=Hn(Te.current).createElement(o),c[X]=s,c[ue]=r,Ct(c,o,r),Sn(c),s.stateNode=c):s.memoizedState=uv(s.type,r.memoizedProps,s.pendingProps,r.memoizedState),null;case 27:return je(s),r===null&&bn&&(c=s.stateNode=Qd(s.type,s.pendingProps,Te.current),rs=s,aa=!0,g=cr,Rs(s.type)?(Yi=g,cr=es(c.firstChild)):cr=g),Kr(r,s,s.pendingProps.children,o),ii(r,s),r===null&&(s.flags|=4194304),s.child;case 5:return r===null&&bn&&((g=c=cr)&&(c=Y_(c,s.type,s.pendingProps,aa),c!==null?(s.stateNode=c,rs=s,cr=es(c.firstChild),aa=!1,g=!0):g=!1),g||Bi(s)),je(s),g=s.type,M=s.pendingProps,j=r!==null?r.memoizedProps:null,c=M.children,ar(g,M)?c=null:j!==null&&ar(g,j)&&(s.flags|=32),s.memoizedState!==null&&(g=So(r,s,Zp,null,null,o),up._currentValue=g),ii(r,s),Kr(r,s,c,o),s.child;case 6:return r===null&&bn&&((r=o=cr)&&(o=qn(o,s.pendingProps,aa),o!==null?(s.stateNode=o,rs=s,cr=null,r=!0):r=!1),r||Bi(s)),null;case 13:return Qu(r,s,o);case 4:return Ue(s,s.stateNode.containerInfo),c=s.pendingProps,r===null?s.child=Gi(s,null,c,o):Kr(r,s,c,o),s.child;case 11:return _h(r,s,s.type,s.pendingProps,o);case 7:return Kr(r,s,s.pendingProps,o),s.child;case 8:return Kr(r,s,s.pendingProps.children,o),s.child;case 12:return Kr(r,s,s.pendingProps.children,o),s.child;case 10:return c=s.pendingProps,Ya(s,s.type,c.value),Kr(r,s,c.children,o),s.child;case 9:return g=s.type._context,c=s.pendingProps.children,Za(s),g=Jr(g),c=c(g),s.flags|=1,Kr(r,s,c,o),s.child;case 14:return sm(r,s,s.type,s.pendingProps,o);case 15:return gh(r,s,s.type,s.pendingProps,o);case 19:return Eh(r,s,o);case 31:return c=s.pendingProps,o=s.mode,c={mode:c.mode,children:c.children},r===null?(o=Xu(c,o),o.ref=s.ref,s.child=o,o.return=s,s=o):(o=sa(r.child,c),o.ref=s.ref,s.child=o,o.return=s,s=o),s;case 22:return yh(r,s,o);case 24:return Za(s),c=Jr(Lr),r===null?(g=Jc(),g===null&&(g=Gn,M=Xc(),g.pooledCache=M,M.refCount++,M!==null&&(g.pooledCacheLanes|=o),g=M),s.memoizedState={parent:c,cache:g},Tu(s),Ya(s,Lr,g)):((r.lanes&o)!==0&&(rd(r,s),wo(s,null,null,o),gl()),g=r.memoizedState,M=s.memoizedState,g.parent!==c?(g={parent:c,cache:c},s.memoizedState=g,s.lanes===0&&(s.memoizedState=s.updateQueue.baseState=g),Ya(s,Lr,c)):(c=M.cache,Ya(s,Lr,c),c!==g.cache&&qc(s,[Lr],o,!0))),Kr(r,s,s.pendingProps.children,o),s.child;case 29:throw s.pendingProps}throw Error(a(156,s.tag))}function ka(r){r.flags|=4}function Sh(r,s){if(s.type!=="stylesheet"||(s.state.loading&4)!==0)r.flags&=-16777217;else if(r.flags|=16777216,!pv(s)){if(s=Is.current,s!==null&&((pn&4194048)===pn?Hs!==null:(pn&62914560)!==pn&&(pn&536870912)===0||s!==Hs))throw ml=td,ed;r.flags|=8192}}function Tl(r,s){s!==null&&(r.flags|=4),r.flags&16384&&(s=r.tag!==22?ja():536870912,r.lanes|=s,Oo|=s)}function El(r,s){if(!bn)switch(r.tailMode){case"hidden":s=r.tail;for(var o=null;s!==null;)s.alternate!==null&&(o=s),s=s.sibling;o===null?r.tail=null:o.sibling=null;break;case"collapsed":o=r.tail;for(var c=null;o!==null;)o.alternate!==null&&(c=o),o=o.sibling;c===null?s||r.tail===null?r.tail=null:r.tail.sibling=null:c.sibling=null}}function sr(r){var s=r.alternate!==null&&r.alternate.child===r.child,o=0,c=0;if(s)for(var g=r.child;g!==null;)o|=g.lanes|g.childLanes,c|=g.subtreeFlags&65011712,c|=g.flags&65011712,g.return=r,g=g.sibling;else for(g=r.child;g!==null;)o|=g.lanes|g.childLanes,c|=g.subtreeFlags,c|=g.flags,g.return=r,g=g.sibling;return r.subtreeFlags|=c,r.childLanes=o,s}function Ch(r,s,o){var c=s.pendingProps;switch(gu(s),s.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return sr(s),null;case 1:return sr(s),null;case 3:return o=s.stateNode,c=null,r!==null&&(c=r.memoizedState.cache),s.memoizedState.cache!==c&&(s.flags|=2048),ia(Lr),ft(),o.pendingContext&&(o.context=o.pendingContext,o.pendingContext=null),(r===null||r.child===null)&&(ul(s)?ka(s):r===null||r.memoizedState.isDehydrated&&(s.flags&256)===0||(s.flags|=1024,Wc())),sr(s),null;case 26:return o=s.memoizedState,r===null?(ka(s),o!==null?(sr(s),Sh(s,o)):(sr(s),s.flags&=-16777217)):o?o!==r.memoizedState?(ka(s),sr(s),Sh(s,o)):(sr(s),s.flags&=-16777217):(r.memoizedProps!==c&&ka(s),sr(s),s.flags&=-16777217),null;case 27:le(s),o=Te.current;var g=s.type;if(r!==null&&s.stateNode!=null)r.memoizedProps!==c&&ka(s);else{if(!c){if(s.stateNode===null)throw Error(a(166));return sr(s),null}r=G.current,ul(s)?_f(s):(r=Qd(g,c,o),s.stateNode=r,ka(s))}return sr(s),null;case 5:if(le(s),o=s.type,r!==null&&s.stateNode!=null)r.memoizedProps!==c&&ka(s);else{if(!c){if(s.stateNode===null)throw Error(a(166));return sr(s),null}if(r=G.current,ul(s))_f(s);else{switch(g=Hn(Te.current),r){case 1:r=g.createElementNS("http://www.w3.org/2000/svg",o);break;case 2:r=g.createElementNS("http://www.w3.org/1998/Math/MathML",o);break;default:switch(o){case"svg":r=g.createElementNS("http://www.w3.org/2000/svg",o);break;case"math":r=g.createElementNS("http://www.w3.org/1998/Math/MathML",o);break;case"script":r=g.createElement("div"),r.innerHTML="<script><\/script>",r=r.removeChild(r.firstChild);break;case"select":r=typeof c.is=="string"?g.createElement("select",{is:c.is}):g.createElement("select"),c.multiple?r.multiple=!0:c.size&&(r.size=c.size);break;default:r=typeof c.is=="string"?g.createElement(o,{is:c.is}):g.createElement(o)}}r[X]=s,r[ue]=c;e:for(g=s.child;g!==null;){if(g.tag===5||g.tag===6)r.appendChild(g.stateNode);else if(g.tag!==4&&g.tag!==27&&g.child!==null){g.child.return=g,g=g.child;continue}if(g===s)break e;for(;g.sibling===null;){if(g.return===null||g.return===s)break e;g=g.return}g.sibling.return=g.return,g=g.sibling}s.stateNode=r;e:switch(Ct(r,o,c),o){case"button":case"input":case"select":case"textarea":r=!!c.autoFocus;break e;case"img":r=!0;break e;default:r=!1}r&&ka(s)}}return sr(s),s.flags&=-16777217,null;case 6:if(r&&s.stateNode!=null)r.memoizedProps!==c&&ka(s);else{if(typeof c!="string"&&s.stateNode===null)throw Error(a(166));if(r=Te.current,ul(s)){if(r=s.stateNode,o=s.memoizedProps,c=null,g=rs,g!==null)switch(g.tag){case 27:case 5:c=g.memoizedProps}r[X]=s,r=!!(r.nodeValue===o||c!==null&&c.suppressHydrationWarning===!0||Yt(r.nodeValue,o)),r||Bi(s)}else r=Hn(r).createTextNode(c),r[X]=s,s.stateNode=r}return sr(s),null;case 13:if(c=s.memoizedState,r===null||r.memoizedState!==null&&r.memoizedState.dehydrated!==null){if(g=ul(s),c!==null&&c.dehydrated!==null){if(r===null){if(!g)throw Error(a(318));if(g=s.memoizedState,g=g!==null?g.dehydrated:null,!g)throw Error(a(317));g[X]=s}else cl(),(s.flags&128)===0&&(s.memoizedState=null),s.flags|=4;sr(s),g=!1}else g=Wc(),r!==null&&r.memoizedState!==null&&(r.memoizedState.hydrationErrors=g),g=!0;if(!g)return s.flags&256?(Aa(s),s):(Aa(s),null)}if(Aa(s),(s.flags&128)!==0)return s.lanes=o,s;if(o=c!==null,r=r!==null&&r.memoizedState!==null,o){c=s.child,g=null,c.alternate!==null&&c.alternate.memoizedState!==null&&c.alternate.memoizedState.cachePool!==null&&(g=c.alternate.memoizedState.cachePool.pool);var M=null;c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(M=c.memoizedState.cachePool.pool),M!==g&&(c.flags|=2048)}return o!==r&&o&&(s.child.flags|=8192),Tl(s,s.updateQueue),sr(s),null;case 4:return ft(),r===null&&O(s.stateNode.containerInfo),sr(s),null;case 10:return ia(s.type),sr(s),null;case 19:if(R(zr),g=s.memoizedState,g===null)return sr(s),null;if(c=(s.flags&128)!==0,M=g.rendering,M===null)if(c)El(g,!1);else{if(dr!==0||r!==null&&(r.flags&128)!==0)for(r=s.child;r!==null;){if(M=Vu(r),M!==null){for(s.flags|=128,El(g,!1),r=M.updateQueue,s.updateQueue=r,Tl(s,r),s.subtreeFlags=0,r=o,o=s.child;o!==null;)pf(o,r),o=o.sibling;return Q(zr,zr.current&1|2),s.child}r=r.sibling}g.tail!==null&&xe()>jd&&(s.flags|=128,c=!0,El(g,!1),s.lanes=4194304)}else{if(!c)if(r=Vu(M),r!==null){if(s.flags|=128,c=!0,r=r.updateQueue,s.updateQueue=r,Tl(s,r),El(g,!0),g.tail===null&&g.tailMode==="hidden"&&!M.alternate&&!bn)return sr(s),null}else 2*xe()-g.renderingStartTime>jd&&o!==536870912&&(s.flags|=128,c=!0,El(g,!1),s.lanes=4194304);g.isBackwards?(M.sibling=s.child,s.child=M):(r=g.last,r!==null?r.sibling=M:s.child=M,g.last=M)}return g.tail!==null?(s=g.tail,g.rendering=s,g.tail=s.sibling,g.renderingStartTime=xe(),s.sibling=null,r=zr.current,Q(zr,c?r&1|2:r&1),s):(sr(s),null);case 22:case 23:return Aa(s),ad(),c=s.memoizedState!==null,r!==null?r.memoizedState!==null!==c&&(s.flags|=8192):c&&(s.flags|=8192),c?(o&536870912)!==0&&(s.flags&128)===0&&(sr(s),s.subtreeFlags&6&&(s.flags|=8192)):sr(s),o=s.updateQueue,o!==null&&Tl(s,o.retryQueue),o=null,r!==null&&r.memoizedState!==null&&r.memoizedState.cachePool!==null&&(o=r.memoizedState.cachePool.pool),c=null,s.memoizedState!==null&&s.memoizedState.cachePool!==null&&(c=s.memoizedState.cachePool.pool),c!==o&&(s.flags|=2048),r!==null&&R(Ja),null;case 24:return o=null,r!==null&&(o=r.memoizedState.cache),s.memoizedState.cache!==o&&(s.flags|=2048),ia(Lr),sr(s),null;case 25:return null;case 30:return null}throw Error(a(156,s.tag))}function im(r,s){switch(gu(s),s.tag){case 1:return r=s.flags,r&65536?(s.flags=r&-65537|128,s):null;case 3:return ia(Lr),ft(),r=s.flags,(r&65536)!==0&&(r&128)===0?(s.flags=r&-65537|128,s):null;case 26:case 27:case 5:return le(s),null;case 13:if(Aa(s),r=s.memoizedState,r!==null&&r.dehydrated!==null){if(s.alternate===null)throw Error(a(340));cl()}return r=s.flags,r&65536?(s.flags=r&-65537|128,s):null;case 19:return R(zr),null;case 4:return ft(),null;case 10:return ia(s.type),null;case 22:case 23:return Aa(s),ad(),r!==null&&R(Ja),r=s.flags,r&65536?(s.flags=r&-65537|128,s):null;case 24:return ia(Lr),null;case 25:return null;default:return null}}function Ph(r,s){switch(gu(s),s.tag){case 3:ia(Lr),ft();break;case 26:case 27:case 5:le(s);break;case 4:ft();break;case 13:Aa(s);break;case 19:R(zr);break;case 10:ia(s.type);break;case 22:case 23:Aa(s),ad(),r!==null&&R(Ja);break;case 24:ia(Lr)}}function Hi(r,s){try{var o=s.updateQueue,c=o!==null?o.lastEffect:null;if(c!==null){var g=c.next;o=g;do{if((o.tag&r)===r){c=void 0;var M=o.create,j=o.inst;c=M(),j.destroy=c}o=o.next}while(o!==g)}}catch(Y){Wn(s,s.return,Y)}}function oi(r,s,o){try{var c=s.updateQueue,g=c!==null?c.lastEffect:null;if(g!==null){var M=g.next;c=M;do{if((c.tag&r)===r){var j=c.inst,Y=j.destroy;if(Y!==void 0){j.destroy=void 0,g=s;var he=o,$e=Y;try{$e()}catch(Ze){Wn(g,he,Ze)}}}c=c.next}while(c!==M)}}catch(Ze){Wn(s,s.return,Ze)}}function Ah(r){var s=r.updateQueue;if(s!==null){var o=r.stateNode;try{Tf(s,o)}catch(c){Wn(r,r.return,c)}}}function kh(r,s,o){o.props=Wi(r.type,r.memoizedProps),o.state=r.memoizedState;try{o.componentWillUnmount()}catch(c){Wn(r,s,c)}}function Sl(r,s){try{var o=r.ref;if(o!==null){switch(r.tag){case 26:case 27:case 5:var c=r.stateNode;break;case 30:c=r.stateNode;break;default:c=r.stateNode}typeof o=="function"?r.refCleanup=o(c):o.current=c}}catch(g){Wn(r,s,g)}}function Ks(r,s){var o=r.ref,c=r.refCleanup;if(o!==null)if(typeof c=="function")try{c()}catch(g){Wn(r,s,g)}finally{r.refCleanup=null,r=r.alternate,r!=null&&(r.refCleanup=null)}else if(typeof o=="function")try{o(null)}catch(g){Wn(r,s,g)}else o.current=null}function Yu(r){var s=r.type,o=r.memoizedProps,c=r.stateNode;try{e:switch(s){case"button":case"input":case"select":case"textarea":o.autoFocus&&c.focus();break e;case"img":o.src?c.src=o.src:o.srcSet&&(c.srcset=o.srcSet)}}catch(g){Wn(r,r.return,g)}}function Oh(r,s,o){try{var c=r.stateNode;Lt(c,r.type,o,s),c[ue]=s}catch(g){Wn(r,r.return,g)}}function $h(r){return r.tag===5||r.tag===3||r.tag===26||r.tag===27&&Rs(r.type)||r.tag===4}function Od(r){e:for(;;){for(;r.sibling===null;){if(r.return===null||$h(r.return))return null;r=r.return}for(r.sibling.return=r.return,r=r.sibling;r.tag!==5&&r.tag!==6&&r.tag!==18;){if(r.tag===27&&Rs(r.type)||r.flags&2||r.child===null||r.tag===4)continue e;r.child.return=r,r=r.child}if(!(r.flags&2))return r.stateNode}}function Zu(r,s,o){var c=r.tag;if(c===5||c===6)r=r.stateNode,s?(o.nodeType===9?o.body:o.nodeName==="HTML"?o.ownerDocument.body:o).insertBefore(r,s):(s=o.nodeType===9?o.body:o.nodeName==="HTML"?o.ownerDocument.body:o,s.appendChild(r),o=o._reactRootContainer,o!=null||s.onclick!==null||(s.onclick=Wt));else if(c!==4&&(c===27&&Rs(r.type)&&(o=r.stateNode,s=null),r=r.child,r!==null))for(Zu(r,s,o),r=r.sibling;r!==null;)Zu(r,s,o),r=r.sibling}function Ju(r,s,o){var c=r.tag;if(c===5||c===6)r=r.stateNode,s?o.insertBefore(r,s):o.appendChild(r);else if(c!==4&&(c===27&&Rs(r.type)&&(o=r.stateNode),r=r.child,r!==null))for(Ju(r,s,o),r=r.sibling;r!==null;)Ju(r,s,o),r=r.sibling}function Dh(r){var s=r.stateNode,o=r.memoizedProps;try{for(var c=r.type,g=s.attributes;g.length;)s.removeAttributeNode(g[0]);Ct(s,c,o),s[X]=r,s[ue]=o}catch(M){Wn(r,r.return,M)}}var la=!1,vr=!1,$d=!1,Dd=typeof WeakSet=="function"?WeakSet:Set,qr=null;function U_(r,s){if(r=r.containerInfo,cn=Dm,r=ho(r),po(r)){if("selectionStart"in r)var o={start:r.selectionStart,end:r.selectionEnd};else e:{o=(o=r.ownerDocument)&&o.defaultView||window;var c=o.getSelection&&o.getSelection();if(c&&c.rangeCount!==0){o=c.anchorNode;var g=c.anchorOffset,M=c.focusNode;c=c.focusOffset;try{o.nodeType,M.nodeType}catch{o=null;break e}var j=0,Y=-1,he=-1,$e=0,Ze=0,tt=r,Le=null;t:for(;;){for(var Fe;tt!==o||g!==0&&tt.nodeType!==3||(Y=j+g),tt!==M||c!==0&&tt.nodeType!==3||(he=j+c),tt.nodeType===3&&(j+=tt.nodeValue.length),(Fe=tt.firstChild)!==null;)Le=tt,tt=Fe;for(;;){if(tt===r)break t;if(Le===o&&++$e===g&&(Y=j),Le===M&&++Ze===c&&(he=j),(Fe=tt.nextSibling)!==null)break;tt=Le,Le=tt.parentNode}tt=Fe}o=Y===-1||he===-1?null:{start:Y,end:he}}else o=null}o=o||{start:0,end:0}}else o=null;for(Ln={focusedElem:r,selectionRange:o},Dm=!1,qr=s;qr!==null;)if(s=qr,r=s.child,(s.subtreeFlags&1024)!==0&&r!==null)r.return=s,qr=r;else for(;qr!==null;){switch(s=qr,M=s.alternate,r=s.flags,s.tag){case 0:break;case 11:case 15:break;case 1:if((r&1024)!==0&&M!==null){r=void 0,o=s,g=M.memoizedProps,M=M.memoizedState,c=o.stateNode;try{var Jt=Wi(o.type,g,o.elementType===o.type);r=c.getSnapshotBeforeUpdate(Jt,M),c.__reactInternalSnapshotBeforeUpdate=r}catch(Gt){Wn(o,o.return,Gt)}}break;case 3:if((r&1024)!==0){if(r=s.stateNode.containerInfo,o=r.nodeType,o===9)Ro(r);else if(o===1)switch(r.nodeName){case"HEAD":case"HTML":case"BODY":Ro(r);break;default:r.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((r&1024)!==0)throw Error(a(163))}if(r=s.sibling,r!==null){r.return=s.return,qr=r;break}qr=s.return}}function Id(r,s,o){var c=o.flags;switch(o.tag){case 0:case 11:case 15:li(r,o),c&4&&Hi(5,o);break;case 1:if(li(r,o),c&4)if(r=o.stateNode,s===null)try{r.componentDidMount()}catch(j){Wn(o,o.return,j)}else{var g=Wi(o.type,s.memoizedProps);s=s.memoizedState;try{r.componentDidUpdate(g,s,r.__reactInternalSnapshotBeforeUpdate)}catch(j){Wn(o,o.return,j)}}c&64&&Ah(o),c&512&&Sl(o,o.return);break;case 3:if(li(r,o),c&64&&(r=o.updateQueue,r!==null)){if(s=null,o.child!==null)switch(o.child.tag){case 27:case 5:s=o.child.stateNode;break;case 1:s=o.child.stateNode}try{Tf(r,s)}catch(j){Wn(o,o.return,j)}}break;case 27:s===null&&c&4&&Dh(o);case 26:case 5:li(r,o),s===null&&c&4&&Yu(o),c&512&&Sl(o,o.return);break;case 12:li(r,o);break;case 13:li(r,o),c&4&&Ih(r,o),c&64&&(r=o.memoizedState,r!==null&&(r=r.dehydrated,r!==null&&(o=W_.bind(null,o),Xi(r,o))));break;case 22:if(c=o.memoizedState!==null||la,!c){s=s!==null&&s.memoizedState!==null||vr,g=la;var M=vr;la=c,(vr=s)&&!M?ui(r,o,(o.subtreeFlags&8772)!==0):li(r,o),la=g,vr=M}break;case 30:break;default:li(r,o)}}function ec(r){var s=r.alternate;s!==null&&(r.alternate=null,ec(s)),r.child=null,r.deletions=null,r.sibling=null,r.tag===5&&(s=r.stateNode,s!==null&&Zt(s)),r.stateNode=null,r.return=null,r.dependencies=null,r.memoizedProps=null,r.memoizedState=null,r.pendingProps=null,r.stateNode=null,r.updateQueue=null}var Zn=null,hs=!1;function Oa(r,s,o){for(o=o.child;o!==null;)tc(r,s,o),o=o.sibling}function tc(r,s,o){if(ct&&typeof ct.onCommitFiberUnmount=="function")try{ct.onCommitFiberUnmount(nt,o)}catch{}switch(o.tag){case 26:vr||Ks(o,s),Oa(r,s,o),o.memoizedState?o.memoizedState.count--:o.stateNode&&(o=o.stateNode,o.parentNode.removeChild(o));break;case 27:vr||Ks(o,s);var c=Zn,g=hs;Rs(o.type)&&(Zn=o.stateNode,hs=!1),Oa(r,s,o),Bo(o.stateNode),Zn=c,hs=g;break;case 5:vr||Ks(o,s);case 6:if(c=Zn,g=hs,Zn=null,Oa(r,s,o),Zn=c,hs=g,Zn!==null)if(hs)try{(Zn.nodeType===9?Zn.body:Zn.nodeName==="HTML"?Zn.ownerDocument.body:Zn).removeChild(o.stateNode)}catch(M){Wn(o,s,M)}else try{Zn.removeChild(o.stateNode)}catch(M){Wn(o,s,M)}break;case 18:Zn!==null&&(hs?(r=Zn,uc(r.nodeType===9?r.body:r.nodeName==="HTML"?r.ownerDocument.body:r,o.stateNode),hp(r)):uc(Zn,o.stateNode));break;case 4:c=Zn,g=hs,Zn=o.stateNode.containerInfo,hs=!0,Oa(r,s,o),Zn=c,hs=g;break;case 0:case 11:case 14:case 15:vr||oi(2,o,s),vr||oi(4,o,s),Oa(r,s,o);break;case 1:vr||(Ks(o,s),c=o.stateNode,typeof c.componentWillUnmount=="function"&&kh(o,s,c)),Oa(r,s,o);break;case 21:Oa(r,s,o);break;case 22:vr=(c=vr)||o.memoizedState!==null,Oa(r,s,o),vr=c;break;default:Oa(r,s,o)}}function Ih(r,s){if(s.memoizedState===null&&(r=s.alternate,r!==null&&(r=r.memoizedState,r!==null&&(r=r.dehydrated,r!==null))))try{hp(r)}catch(o){Wn(s,s.return,o)}}function om(r){switch(r.tag){case 13:case 19:var s=r.stateNode;return s===null&&(s=r.stateNode=new Dd),s;case 22:return r=r.stateNode,s=r._retryCache,s===null&&(s=r._retryCache=new Dd),s;default:throw Error(a(435,r.tag))}}function Ld(r,s){var o=om(r);s.forEach(function(c){var g=H_.bind(null,r,c);o.has(c)||(o.add(c),c.then(g,g))})}function ss(r,s){var o=s.deletions;if(o!==null)for(var c=0;c<o.length;c++){var g=o[c],M=r,j=s,Y=j;e:for(;Y!==null;){switch(Y.tag){case 27:if(Rs(Y.type)){Zn=Y.stateNode,hs=!1;break e}break;case 5:Zn=Y.stateNode,hs=!1;break e;case 3:case 4:Zn=Y.stateNode.containerInfo,hs=!0;break e}Y=Y.return}if(Zn===null)throw Error(a(160));tc(M,j,g),Zn=null,hs=!1,M=g.alternate,M!==null&&(M.return=null),g.return=null}if(s.subtreeFlags&13878)for(s=s.child;s!==null;)Lh(s,r),s=s.sibling}var qs=null;function Lh(r,s){var o=r.alternate,c=r.flags;switch(r.tag){case 0:case 11:case 14:case 15:ss(s,r),gs(r),c&4&&(oi(3,r,r.return),Hi(3,r),oi(5,r,r.return));break;case 1:ss(s,r),gs(r),c&512&&(vr||o===null||Ks(o,o.return)),c&64&&la&&(r=r.updateQueue,r!==null&&(c=r.callbacks,c!==null&&(o=r.shared.hiddenCallbacks,r.shared.hiddenCallbacks=o===null?c:o.concat(c))));break;case 26:var g=qs;if(ss(s,r),gs(r),c&512&&(vr||o===null||Ks(o,o.return)),c&4){var M=o!==null?o.memoizedState:null;if(c=r.memoizedState,o===null)if(c===null)if(r.stateNode===null){e:{c=r.type,o=r.memoizedProps,g=g.ownerDocument||g;t:switch(c){case"title":M=g.getElementsByTagName("title")[0],(!M||M[mt]||M[X]||M.namespaceURI==="http://www.w3.org/2000/svg"||M.hasAttribute("itemprop"))&&(M=g.createElement(c),g.head.insertBefore(M,g.querySelector("head > title"))),Ct(M,c,o),M[X]=r,Sn(M),c=M;break e;case"link":var j=fv("link","href",g).get(c+(o.href||""));if(j){for(var Y=0;Y<j.length;Y++)if(M=j[Y],M.getAttribute("href")===(o.href==null||o.href===""?null:o.href)&&M.getAttribute("rel")===(o.rel==null?null:o.rel)&&M.getAttribute("title")===(o.title==null?null:o.title)&&M.getAttribute("crossorigin")===(o.crossOrigin==null?null:o.crossOrigin)){j.splice(Y,1);break t}}M=g.createElement(c),Ct(M,c,o),g.head.appendChild(M);break;case"meta":if(j=fv("meta","content",g).get(c+(o.content||""))){for(Y=0;Y<j.length;Y++)if(M=j[Y],M.getAttribute("content")===(o.content==null?null:""+o.content)&&M.getAttribute("name")===(o.name==null?null:o.name)&&M.getAttribute("property")===(o.property==null?null:o.property)&&M.getAttribute("http-equiv")===(o.httpEquiv==null?null:o.httpEquiv)&&M.getAttribute("charset")===(o.charSet==null?null:o.charSet)){j.splice(Y,1);break t}}M=g.createElement(c),Ct(M,c,o),g.head.appendChild(M);break;default:throw Error(a(468,c))}M[X]=r,Sn(M),c=M}r.stateNode=c}else hv(g,r.type,r.stateNode);else r.stateNode=dv(g,c,r.memoizedProps);else M!==c?(M===null?o.stateNode!==null&&(o=o.stateNode,o.parentNode.removeChild(o)):M.count--,c===null?hv(g,r.type,r.stateNode):dv(g,c,r.memoizedProps)):c===null&&r.stateNode!==null&&Oh(r,r.memoizedProps,o.memoizedProps)}break;case 27:ss(s,r),gs(r),c&512&&(vr||o===null||Ks(o,o.return)),o!==null&&c&4&&Oh(r,r.memoizedProps,o.memoizedProps);break;case 5:if(ss(s,r),gs(r),c&512&&(vr||o===null||Ks(o,o.return)),r.flags&32){g=r.stateNode;try{de(g,"")}catch(Fe){Wn(r,r.return,Fe)}}c&4&&r.stateNode!=null&&(g=r.memoizedProps,Oh(r,g,o!==null?o.memoizedProps:g)),c&1024&&($d=!0);break;case 6:if(ss(s,r),gs(r),c&4){if(r.stateNode===null)throw Error(a(162));c=r.memoizedProps,o=r.stateNode;try{o.nodeValue=c}catch(Fe){Wn(r,r.return,Fe)}}break;case 3:if(km=null,g=qs,qs=Dl(s.containerInfo),ss(s,r),qs=g,gs(r),c&4&&o!==null&&o.memoizedState.isDehydrated)try{hp(s.containerInfo)}catch(Fe){Wn(r,r.return,Fe)}$d&&($d=!1,nc(r));break;case 4:c=qs,qs=Dl(r.stateNode.containerInfo),ss(s,r),gs(r),qs=c;break;case 12:ss(s,r),gs(r);break;case 13:ss(s,r),gs(r),r.child.flags&8192&&r.memoizedState!==null!=(o!==null&&o.memoizedState!==null)&&(Vh=xe()),c&4&&(c=r.updateQueue,c!==null&&(r.updateQueue=null,Ld(r,c)));break;case 22:g=r.memoizedState!==null;var he=o!==null&&o.memoizedState!==null,$e=la,Ze=vr;if(la=$e||g,vr=Ze||he,ss(s,r),vr=Ze,la=$e,gs(r),c&8192)e:for(s=r.stateNode,s._visibility=g?s._visibility&-2:s._visibility|1,g&&(o===null||he||la||vr||Ki(r)),o=null,s=r;;){if(s.tag===5||s.tag===26){if(o===null){he=o=s;try{if(M=he.stateNode,g)j=M.style,typeof j.setProperty=="function"?j.setProperty("display","none","important"):j.display="none";else{Y=he.stateNode;var tt=he.memoizedProps.style,Le=tt!=null&&tt.hasOwnProperty("display")?tt.display:null;Y.style.display=Le==null||typeof Le=="boolean"?"":(""+Le).trim()}}catch(Fe){Wn(he,he.return,Fe)}}}else if(s.tag===6){if(o===null){he=s;try{he.stateNode.nodeValue=g?"":he.memoizedProps}catch(Fe){Wn(he,he.return,Fe)}}}else if((s.tag!==22&&s.tag!==23||s.memoizedState===null||s===r)&&s.child!==null){s.child.return=s,s=s.child;continue}if(s===r)break e;for(;s.sibling===null;){if(s.return===null||s.return===r)break e;o===s&&(o=null),s=s.return}o===s&&(o=null),s.sibling.return=s.return,s=s.sibling}c&4&&(c=r.updateQueue,c!==null&&(o=c.retryQueue,o!==null&&(c.retryQueue=null,Ld(r,o))));break;case 19:ss(s,r),gs(r),c&4&&(c=r.updateQueue,c!==null&&(r.updateQueue=null,Ld(r,c)));break;case 30:break;case 21:break;default:ss(s,r),gs(r)}}function gs(r){var s=r.flags;if(s&2){try{for(var o,c=r.return;c!==null;){if($h(c)){o=c;break}c=c.return}if(o==null)throw Error(a(160));switch(o.tag){case 27:var g=o.stateNode,M=Od(r);Ju(r,M,g);break;case 5:var j=o.stateNode;o.flags&32&&(de(j,""),o.flags&=-33);var Y=Od(r);Ju(r,Y,j);break;case 3:case 4:var he=o.stateNode.containerInfo,$e=Od(r);Zu(r,$e,he);break;default:throw Error(a(161))}}catch(Ze){Wn(r,r.return,Ze)}r.flags&=-3}s&4096&&(r.flags&=-4097)}function nc(r){if(r.subtreeFlags&1024)for(r=r.child;r!==null;){var s=r;nc(s),s.tag===5&&s.flags&1024&&s.stateNode.reset(),r=r.sibling}}function li(r,s){if(s.subtreeFlags&8772)for(s=s.child;s!==null;)Id(r,s.alternate,s),s=s.sibling}function Ki(r){for(r=r.child;r!==null;){var s=r;switch(s.tag){case 0:case 11:case 14:case 15:oi(4,s,s.return),Ki(s);break;case 1:Ks(s,s.return);var o=s.stateNode;typeof o.componentWillUnmount=="function"&&kh(s,s.return,o),Ki(s);break;case 27:Bo(s.stateNode);case 26:case 5:Ks(s,s.return),Ki(s);break;case 22:s.memoizedState===null&&Ki(s);break;case 30:Ki(s);break;default:Ki(s)}r=r.sibling}}function ui(r,s,o){for(o=o&&(s.subtreeFlags&8772)!==0,s=s.child;s!==null;){var c=s.alternate,g=r,M=s,j=M.flags;switch(M.tag){case 0:case 11:case 15:ui(g,M,o),Hi(4,M);break;case 1:if(ui(g,M,o),c=M,g=c.stateNode,typeof g.componentDidMount=="function")try{g.componentDidMount()}catch($e){Wn(c,c.return,$e)}if(c=M,g=c.updateQueue,g!==null){var Y=c.stateNode;try{var he=g.shared.hiddenCallbacks;if(he!==null)for(g.shared.hiddenCallbacks=null,g=0;g<he.length;g++)xf(he[g],Y)}catch($e){Wn(c,c.return,$e)}}o&&j&64&&Ah(M),Sl(M,M.return);break;case 27:Dh(M);case 26:case 5:ui(g,M,o),o&&c===null&&j&4&&Yu(M),Sl(M,M.return);break;case 12:ui(g,M,o);break;case 13:ui(g,M,o),o&&j&4&&Ih(g,M);break;case 22:M.memoizedState===null&&ui(g,M,o),Sl(M,M.return);break;case 30:break;default:ui(g,M,o)}s=s.sibling}}function zd(r,s){var o=null;r!==null&&r.memoizedState!==null&&r.memoizedState.cachePool!==null&&(o=r.memoizedState.cachePool.pool),r=null,s.memoizedState!==null&&s.memoizedState.cachePool!==null&&(r=s.memoizedState.cachePool.pool),r!==o&&(r!=null&&r.refCount++,o!=null&&vo(o))}function Fd(r,s){r=null,s.alternate!==null&&(r=s.alternate.memoizedState.cache),s=s.memoizedState.cache,s!==r&&(s.refCount++,r!=null&&vo(r))}function ua(r,s,o,c){if(s.subtreeFlags&10256)for(s=s.child;s!==null;)zh(r,s,o,c),s=s.sibling}function zh(r,s,o,c){var g=s.flags;switch(s.tag){case 0:case 11:case 15:ua(r,s,o,c),g&2048&&Hi(9,s);break;case 1:ua(r,s,o,c);break;case 3:ua(r,s,o,c),g&2048&&(r=null,s.alternate!==null&&(r=s.alternate.memoizedState.cache),s=s.memoizedState.cache,s!==r&&(s.refCount++,r!=null&&vo(r)));break;case 12:if(g&2048){ua(r,s,o,c),r=s.stateNode;try{var M=s.memoizedProps,j=M.id,Y=M.onPostCommit;typeof Y=="function"&&Y(j,s.alternate===null?"mount":"update",r.passiveEffectDuration,-0)}catch(he){Wn(s,s.return,he)}}else ua(r,s,o,c);break;case 13:ua(r,s,o,c);break;case 23:break;case 22:M=s.stateNode,j=s.alternate,s.memoizedState!==null?M._visibility&2?ua(r,s,o,c):Cl(r,s):M._visibility&2?ua(r,s,o,c):(M._visibility|=2,Po(r,s,o,c,(s.subtreeFlags&10256)!==0)),g&2048&&zd(j,s);break;case 24:ua(r,s,o,c),g&2048&&Fd(s.alternate,s);break;default:ua(r,s,o,c)}}function Po(r,s,o,c,g){for(g=g&&(s.subtreeFlags&10256)!==0,s=s.child;s!==null;){var M=r,j=s,Y=o,he=c,$e=j.flags;switch(j.tag){case 0:case 11:case 15:Po(M,j,Y,he,g),Hi(8,j);break;case 23:break;case 22:var Ze=j.stateNode;j.memoizedState!==null?Ze._visibility&2?Po(M,j,Y,he,g):Cl(M,j):(Ze._visibility|=2,Po(M,j,Y,he,g)),g&&$e&2048&&zd(j.alternate,j);break;case 24:Po(M,j,Y,he,g),g&&$e&2048&&Fd(j.alternate,j);break;default:Po(M,j,Y,he,g)}s=s.sibling}}function Cl(r,s){if(s.subtreeFlags&10256)for(s=s.child;s!==null;){var o=r,c=s,g=c.flags;switch(c.tag){case 22:Cl(o,c),g&2048&&zd(c.alternate,c);break;case 24:Cl(o,c),g&2048&&Fd(c.alternate,c);break;default:Cl(o,c)}s=s.sibling}}var Pl=8192;function qi(r){if(r.subtreeFlags&Pl)for(r=r.child;r!==null;)Fh(r),r=r.sibling}function Fh(r){switch(r.tag){case 26:qi(r),r.flags&Pl&&r.memoizedState!==null&&tC(qs,r.memoizedState,r.memoizedProps);break;case 5:qi(r);break;case 3:case 4:var s=qs;qs=Dl(r.stateNode.containerInfo),qi(r),qs=s;break;case 22:r.memoizedState===null&&(s=r.alternate,s!==null&&s.memoizedState!==null?(s=Pl,Pl=16777216,qi(r),Pl=s):qi(r));break;default:qi(r)}}function Rh(r){var s=r.alternate;if(s!==null&&(r=s.child,r!==null)){s.child=null;do s=r.sibling,r.sibling=null,r=s;while(r!==null)}}function Ao(r){var s=r.deletions;if((r.flags&16)!==0){if(s!==null)for(var o=0;o<s.length;o++){var c=s[o];qr=c,jh(c,r)}Rh(r)}if(r.subtreeFlags&10256)for(r=r.child;r!==null;)Bh(r),r=r.sibling}function Bh(r){switch(r.tag){case 0:case 11:case 15:Ao(r),r.flags&2048&&oi(9,r,r.return);break;case 3:Ao(r);break;case 12:Ao(r);break;case 22:var s=r.stateNode;r.memoizedState!==null&&s._visibility&2&&(r.return===null||r.return.tag!==13)?(s._visibility&=-3,rc(r)):Ao(r);break;default:Ao(r)}}function rc(r){var s=r.deletions;if((r.flags&16)!==0){if(s!==null)for(var o=0;o<s.length;o++){var c=s[o];qr=c,jh(c,r)}Rh(r)}for(r=r.child;r!==null;){switch(s=r,s.tag){case 0:case 11:case 15:oi(8,s,s.return),rc(s);break;case 22:o=s.stateNode,o._visibility&2&&(o._visibility&=-3,rc(s));break;default:rc(s)}r=r.sibling}}function jh(r,s){for(;qr!==null;){var o=qr;switch(o.tag){case 0:case 11:case 15:oi(8,o,s);break;case 23:case 22:if(o.memoizedState!==null&&o.memoizedState.cachePool!==null){var c=o.memoizedState.cachePool.pool;c!=null&&c.refCount++}break;case 24:vo(o.memoizedState.cache)}if(c=o.child,c!==null)c.return=o,qr=c;else e:for(o=r;qr!==null;){c=qr;var g=c.sibling,M=c.return;if(ec(c),c===o){qr=null;break e}if(g!==null){g.return=M,qr=g;break e}qr=M}}}var Nh={getCacheForType:function(r){var s=Jr(Lr),o=s.data.get(r);return o===void 0&&(o=r(),s.data.set(r,o)),o}},lm=typeof WeakMap=="function"?WeakMap:Map,xn=0,Gn=null,ln=null,pn=0,In=0,ys=null,ca=!1,ko=!1,Rd=!1,$a=0,dr=0,ci=0,Da=0,Bd=0,Ls=0,Oo=0,fn=null,vs=null,Uh=!1,Vh=0,jd=1/0,Al=null,di=null,Qr=0,fi=null,$o=null,Qi=0,sc=0,Gh=null,Wh=null,kl=0,ac=null;function bs(){if((xn&2)!==0&&pn!==0)return pn&-pn;if(W.T!==null){var r=ji;return r!==0?r:sp()}return Js()}function Hh(){Ls===0&&(Ls=(pn&536870912)===0||bn?jr():536870912);var r=Is.current;return r!==null&&(r.flags|=32),Ls}function zs(r,s,o){(r===Gn&&(In===2||In===9)||r.cancelPendingCommit!==null)&&(Do(r,0),Fs(r,pn,Ls,!1)),Es(r,o),((xn&2)===0||r!==Gn)&&(r===Gn&&((xn&2)===0&&(Da|=o),dr===4&&Fs(r,pn,Ls,!1)),Ia(r))}function Kh(r,s,o){if((xn&6)!==0)throw Error(a(327));var c=!o&&(s&124)===0&&(s&r.expiredLanes)===0||$r(r,s),g=c?cm(r,s):Vd(r,s,!0),M=c;do{if(g===0){ko&&!c&&Fs(r,s,0,!1);break}else{if(o=r.current.alternate,M&&!um(o)){g=Vd(r,s,!1),M=!1;continue}if(g===2){if(M=s,r.errorRecoveryDisabledLanes&M)var j=0;else j=r.pendingLanes&-536870913,j=j!==0?j:j&536870912?536870912:0;if(j!==0){s=j;e:{var Y=r;g=fn;var he=Y.current.memoizedState.isDehydrated;if(he&&(Do(Y,j).flags|=256),j=Vd(Y,j,!1),j!==2){if(Rd&&!he){Y.errorRecoveryDisabledLanes|=M,Da|=M,g=4;break e}M=vs,vs=g,M!==null&&(vs===null?vs=M:vs.push.apply(vs,M))}g=j}if(M=!1,g!==2)continue}}if(g===1){Do(r,0),Fs(r,s,0,!0);break}e:{switch(c=r,M=g,M){case 0:case 1:throw Error(a(345));case 4:if((s&4194048)!==s)break;case 6:Fs(c,s,Ls,!ca);break e;case 2:vs=null;break;case 3:case 5:break;default:throw Error(a(329))}if((s&62914560)===s&&(g=Vh+300-xe(),10<g)){if(Fs(c,s,Ls,!ca),Br(c,0,!0)!==0)break e;c.timeoutHandle=Rr(qh.bind(null,c,o,vs,Al,Uh,s,Ls,Da,Oo,ca,M,2,-0,0),g);break e}qh(c,o,vs,Al,Uh,s,Ls,Da,Oo,ca,M,0,-0,0)}}break}while(!0);Ia(r)}function qh(r,s,o,c,g,M,j,Y,he,$e,Ze,tt,Le,Fe){if(r.timeoutHandle=-1,tt=s.subtreeFlags,(tt&8192||(tt&16785408)===16785408)&&(lp={stylesheets:null,count:0,unsuspend:eC},Fh(s),tt=nC(),tt!==null)){r.cancelPendingCommit=tt(ep.bind(null,r,s,M,o,c,g,j,Y,he,Ze,1,Le,Fe)),Fs(r,M,j,!$e);return}ep(r,s,M,o,c,g,j,Y,he)}function um(r){for(var s=r;;){var o=s.tag;if((o===0||o===11||o===15)&&s.flags&16384&&(o=s.updateQueue,o!==null&&(o=o.stores,o!==null)))for(var c=0;c<o.length;c++){var g=o[c],M=g.getSnapshot;g=g.value;try{if(!Hr(M(),g))return!1}catch{return!1}}if(o=s.child,s.subtreeFlags&16384&&o!==null)o.return=s,s=o;else{if(s===r)break;for(;s.sibling===null;){if(s.return===null||s.return===r)return!0;s=s.return}s.sibling.return=s.return,s=s.sibling}}return!0}function Fs(r,s,o,c){s&=~Bd,s&=~Da,r.suspendedLanes|=s,r.pingedLanes&=~s,c&&(r.warmLanes|=s),c=r.expirationTimes;for(var g=s;0<g;){var M=31-lt(g),j=1<<M;c[M]=-1,g&=~j}o!==0&&zt(r,o,s)}function ic(){return(xn&6)===0?(lc(0),!1):!0}function Nd(){if(ln!==null){if(In===0)var r=ln.return;else r=ln,Ca=Xa=null,ud(r),Vi=null,wl=0,r=ln;for(;r!==null;)Ph(r.alternate,r),r=r.return;ln=null}}function Do(r,s){var o=r.timeoutHandle;o!==-1&&(r.timeoutHandle=-1,Fo(o)),o=r.cancelPendingCommit,o!==null&&(r.cancelPendingCommit=null,o()),Nd(),Gn=r,ln=o=sa(r.current,null),pn=s,In=0,ys=null,ca=!1,ko=$r(r,s),Rd=!1,Oo=Ls=Bd=Da=ci=dr=0,vs=fn=null,Uh=!1,(s&8)!==0&&(s|=s&32);var c=r.entangledLanes;if(c!==0)for(r=r.entanglements,c&=s;0<c;){var g=31-lt(c),M=1<<g;s|=r[g],c&=~M}return $a=s,hu(),o}function Qh(r,s){sn=null,W.H=ju,s===pl||s===Mu?(s=wf(),In=3):s===ed?(s=wf(),In=4):In=s===qu?8:s!==null&&typeof s=="object"&&typeof s.then=="function"?6:1,ys=s,ln===null&&(dr=1,Ku(r,Pn(s,r.current)))}function Xh(){var r=W.H;return W.H=ju,r===null?ju:r}function Yh(){var r=W.A;return W.A=Nh,r}function Ud(){dr=4,ca||(pn&4194048)!==pn&&Is.current!==null||(ko=!0),(ci&134217727)===0&&(Da&134217727)===0||Gn===null||Fs(Gn,pn,Ls,!1)}function Vd(r,s,o){var c=xn;xn|=2;var g=Xh(),M=Yh();(Gn!==r||pn!==s)&&(Al=null,Do(r,s)),s=!1;var j=dr;e:do try{if(In!==0&&ln!==null){var Y=ln,he=ys;switch(In){case 8:Nd(),j=6;break e;case 3:case 2:case 9:case 6:Is.current===null&&(s=!0);var $e=In;if(In=0,ys=null,Io(r,Y,he,$e),o&&ko){j=0;break e}break;default:$e=In,In=0,ys=null,Io(r,Y,he,$e)}}V_(),j=dr;break}catch(Ze){Qh(r,Ze)}while(!0);return s&&r.shellSuspendCounter++,Ca=Xa=null,xn=c,W.H=g,W.A=M,ln===null&&(Gn=null,pn=0,hu()),j}function V_(){for(;ln!==null;)Zh(ln)}function cm(r,s){var o=xn;xn|=2;var c=Xh(),g=Yh();Gn!==r||pn!==s?(Al=null,jd=xe()+500,Do(r,s)):ko=$r(r,s);e:do try{if(In!==0&&ln!==null){s=ln;var M=ys;t:switch(In){case 1:In=0,ys=null,Io(r,s,M,1);break;case 2:case 9:if(bf(M)){In=0,ys=null,Jh(s);break}s=function(){In!==2&&In!==9||Gn!==r||(In=7),Ia(r)},M.then(s,s);break e;case 3:In=7;break e;case 4:In=5;break e;case 7:bf(M)?(In=0,ys=null,Jh(s)):(In=0,ys=null,Io(r,s,M,7));break;case 5:var j=null;switch(ln.tag){case 26:j=ln.memoizedState;case 5:case 27:var Y=ln;if(!j||pv(j)){In=0,ys=null;var he=Y.sibling;if(he!==null)ln=he;else{var $e=Y.return;$e!==null?(ln=$e,oc($e)):ln=null}break t}}In=0,ys=null,Io(r,s,M,5);break;case 6:In=0,ys=null,Io(r,s,M,6);break;case 8:Nd(),dr=6;break e;default:throw Error(a(462))}}dm();break}catch(Ze){Qh(r,Ze)}while(!0);return Ca=Xa=null,W.H=c,W.A=g,xn=o,ln!==null?0:(Gn=null,pn=0,hu(),dr)}function dm(){for(;ln!==null&&!Ne();)Zh(ln)}function Zh(r){var s=kd(r.alternate,r,$a);r.memoizedProps=r.pendingProps,s===null?oc(r):ln=s}function Jh(r){var s=r,o=s.alternate;switch(s.tag){case 15:case 0:s=bh(o,s,s.pendingProps,s.type,void 0,pn);break;case 11:s=bh(o,s,s.pendingProps,s.type.render,s.ref,pn);break;case 5:ud(s);default:Ph(o,s),s=ln=pf(s,$a),s=kd(o,s,$a)}r.memoizedProps=r.pendingProps,s===null?oc(r):ln=s}function Io(r,s,o,c){Ca=Xa=null,ud(s),Vi=null,wl=0;var g=s.return;try{if(rm(r,g,s,o,pn)){dr=1,Ku(r,Pn(o,r.current)),ln=null;return}}catch(M){if(g!==null)throw ln=g,M;dr=1,Ku(r,Pn(o,r.current)),ln=null;return}s.flags&32768?(bn||c===1?r=!0:ko||(pn&536870912)!==0?r=!1:(ca=r=!0,(c===2||c===9||c===3||c===6)&&(c=Is.current,c!==null&&c.tag===13&&(c.flags|=16384))),fm(s,r)):oc(s)}function oc(r){var s=r;do{if((s.flags&32768)!==0){fm(s,ca);return}r=s.return;var o=Ch(s.alternate,s,$a);if(o!==null){ln=o;return}if(s=s.sibling,s!==null){ln=s;return}ln=s=r}while(s!==null);dr===0&&(dr=5)}function fm(r,s){do{var o=im(r.alternate,r);if(o!==null){o.flags&=32767,ln=o;return}if(o=r.return,o!==null&&(o.flags|=32768,o.subtreeFlags=0,o.deletions=null),!s&&(r=r.sibling,r!==null)){ln=r;return}ln=r=o}while(r!==null);dr=6,ln=null}function ep(r,s,o,c,g,M,j,Y,he){r.cancelPendingCommit=null;do Gd();while(Qr!==0);if((xn&6)!==0)throw Error(a(327));if(s!==null){if(s===r.current)throw Error(a(177));if(M=s.lanes|s.childLanes,M|=Fc,Ss(r,o,M,j,Y,he),r===Gn&&(ln=Gn=null,pn=0),$o=s,fi=r,Qi=o,sc=M,Gh=g,Wh=c,(s.subtreeFlags&10256)!==0||(s.flags&10256)!==0?(r.callbackNode=null,r.callbackPriority=0,K_(Ye,function(){return gm(),null})):(r.callbackNode=null,r.callbackPriority=0),c=(s.flags&13878)!==0,(s.subtreeFlags&13878)!==0||c){c=W.T,W.T=null,g=te.p,te.p=2,j=xn,xn|=4;try{U_(r,s,o)}finally{xn=j,te.p=g,W.T=c}}Qr=1,hm(),pm(),mm()}}function hm(){if(Qr===1){Qr=0;var r=fi,s=$o,o=(s.flags&13878)!==0;if((s.subtreeFlags&13878)!==0||o){o=W.T,W.T=null;var c=te.p;te.p=2;var g=xn;xn|=4;try{Lh(s,r);var M=Ln,j=ho(r.containerInfo),Y=M.focusedElem,he=M.selectionRange;if(j!==Y&&Y&&Y.ownerDocument&&fo(Y.ownerDocument.documentElement,Y)){if(he!==null&&po(Y)){var $e=he.start,Ze=he.end;if(Ze===void 0&&(Ze=$e),"selectionStart"in Y)Y.selectionStart=$e,Y.selectionEnd=Math.min(Ze,Y.value.length);else{var tt=Y.ownerDocument||document,Le=tt&&tt.defaultView||window;if(Le.getSelection){var Fe=Le.getSelection(),Jt=Y.textContent.length,Gt=Math.min(he.start,Jt),Qn=he.end===void 0?Gt:Math.min(he.end,Jt);!Fe.extend&&Gt>Qn&&(j=Qn,Qn=Gt,Gt=j);var Me=al(Y,Gt),ve=al(Y,Qn);if(Me&&ve&&(Fe.rangeCount!==1||Fe.anchorNode!==Me.node||Fe.anchorOffset!==Me.offset||Fe.focusNode!==ve.node||Fe.focusOffset!==ve.offset)){var Pe=tt.createRange();Pe.setStart(Me.node,Me.offset),Fe.removeAllRanges(),Gt>Qn?(Fe.addRange(Pe),Fe.extend(ve.node,ve.offset)):(Pe.setEnd(ve.node,ve.offset),Fe.addRange(Pe))}}}}for(tt=[],Fe=Y;Fe=Fe.parentNode;)Fe.nodeType===1&&tt.push({element:Fe,left:Fe.scrollLeft,top:Fe.scrollTop});for(typeof Y.focus=="function"&&Y.focus(),Y=0;Y<tt.length;Y++){var Je=tt[Y];Je.element.scrollLeft=Je.left,Je.element.scrollTop=Je.top}}Dm=!!cn,Ln=cn=null}finally{xn=g,te.p=c,W.T=o}}r.current=s,Qr=2}}function pm(){if(Qr===2){Qr=0;var r=fi,s=$o,o=(s.flags&8772)!==0;if((s.subtreeFlags&8772)!==0||o){o=W.T,W.T=null;var c=te.p;te.p=2;var g=xn;xn|=4;try{Id(r,s.alternate,s)}finally{xn=g,te.p=c,W.T=o}}Qr=3}}function mm(){if(Qr===4||Qr===3){Qr=0,De();var r=fi,s=$o,o=Qi,c=Wh;(s.subtreeFlags&10256)!==0||(s.flags&10256)!==0?Qr=5:(Qr=0,$o=fi=null,_m(r,r.pendingLanes));var g=r.pendingLanes;if(g===0&&(di=null),Kt(o),s=s.stateNode,ct&&typeof ct.onCommitFiberRoot=="function")try{ct.onCommitFiberRoot(nt,s,void 0,(s.current.flags&128)===128)}catch{}if(c!==null){s=W.T,g=te.p,te.p=2,W.T=null;try{for(var M=r.onRecoverableError,j=0;j<c.length;j++){var Y=c[j];M(Y.value,{componentStack:Y.stack})}}finally{W.T=s,te.p=g}}(Qi&3)!==0&&Gd(),Ia(r),g=r.pendingLanes,(o&4194090)!==0&&(g&42)!==0?r===ac?kl++:(kl=0,ac=r):kl=0,lc(0)}}function _m(r,s){(r.pooledCacheLanes&=s)===0&&(s=r.pooledCache,s!=null&&(r.pooledCache=null,vo(s)))}function Gd(r){return hm(),pm(),mm(),gm()}function gm(){if(Qr!==5)return!1;var r=fi,s=sc;sc=0;var o=Kt(Qi),c=W.T,g=te.p;try{te.p=32>o?32:o,W.T=null,o=Gh,Gh=null;var M=fi,j=Qi;if(Qr=0,$o=fi=null,Qi=0,(xn&6)!==0)throw Error(a(331));var Y=xn;if(xn|=4,Bh(M.current),zh(M,M.current,j,o),xn=Y,lc(0,!1),ct&&typeof ct.onPostCommitFiberRoot=="function")try{ct.onPostCommitFiberRoot(nt,M)}catch{}return!0}finally{te.p=g,W.T=c,_m(r,s)}}function ym(r,s,o){s=Pn(o,s),s=Md(r.stateNode,s,2),r=ni(r,s,2),r!==null&&(Es(r,2),Ia(r))}function Wn(r,s,o){if(r.tag===3)ym(r,r,o);else for(;s!==null;){if(s.tag===3){ym(s,r,o);break}else if(s.tag===1){var c=s.stateNode;if(typeof s.type.getDerivedStateFromError=="function"||typeof c.componentDidCatch=="function"&&(di===null||!di.has(c))){r=Pn(o,r),o=ph(2),c=ni(s,o,2),c!==null&&(mh(o,c,s,r),Es(c,2),Ia(c));break}}s=s.return}}function tp(r,s,o){var c=r.pingCache;if(c===null){c=r.pingCache=new lm;var g=new Set;c.set(s,g)}else g=c.get(s),g===void 0&&(g=new Set,c.set(s,g));g.has(o)||(Rd=!0,g.add(o),r=G_.bind(null,r,s,o),s.then(r,r))}function G_(r,s,o){var c=r.pingCache;c!==null&&c.delete(s),r.pingedLanes|=r.suspendedLanes&o,r.warmLanes&=~o,Gn===r&&(pn&o)===o&&(dr===4||dr===3&&(pn&62914560)===pn&&300>xe()-Vh?(xn&2)===0&&Do(r,0):Bd|=o,Oo===pn&&(Oo=0)),Ia(r)}function vm(r,s){s===0&&(s=ja()),r=_o(r,s),r!==null&&(Es(r,s),Ia(r))}function W_(r){var s=r.memoizedState,o=0;s!==null&&(o=s.retryLane),vm(r,o)}function H_(r,s){var o=0;switch(r.tag){case 13:var c=r.stateNode,g=r.memoizedState;g!==null&&(o=g.retryLane);break;case 19:c=r.stateNode;break;case 22:c=r.stateNode._retryCache;break;default:throw Error(a(314))}c!==null&&c.delete(s),vm(r,o)}function K_(r,s){return be(r,s)}var Wd=null,Ol=null,np=!1,Hd=!1,rp=!1,Lo=0;function Ia(r){r!==Ol&&r.next===null&&(Ol===null?Wd=Ol=r:Ol=Ol.next=r),Hd=!0,np||(np=!0,Q_())}function lc(r,s){if(!rp&&Hd){rp=!0;do for(var o=!1,c=Wd;c!==null;){if(r!==0){var g=c.pendingLanes;if(g===0)var M=0;else{var j=c.suspendedLanes,Y=c.pingedLanes;M=(1<<31-lt(42|r)+1)-1,M&=g&~(j&~Y),M=M&201326741?M&201326741|1:M?M|2:0}M!==0&&(o=!0,xm(c,M))}else M=pn,M=Br(c,c===Gn?M:0,c.cancelPendingCommit!==null||c.timeoutHandle!==-1),(M&3)===0||$r(c,M)||(o=!0,xm(c,M));c=c.next}while(o);rp=!1}}function q_(){bm()}function bm(){Hd=np=!1;var r=0;Lo!==0&&(ir()&&(r=Lo),Lo=0);for(var s=xe(),o=null,c=Wd;c!==null;){var g=c.next,M=wm(c,s);M===0?(c.next=null,o===null?Wd=g:o.next=g,g===null&&(Ol=o)):(o=c,(r!==0||(M&3)!==0)&&(Hd=!0)),c=g}lc(r)}function wm(r,s){for(var o=r.suspendedLanes,c=r.pingedLanes,g=r.expirationTimes,M=r.pendingLanes&-62914561;0<M;){var j=31-lt(M),Y=1<<j,he=g[j];he===-1?((Y&o)===0||(Y&c)!==0)&&(g[j]=er(Y,s)):he<=s&&(r.expiredLanes|=Y),M&=~Y}if(s=Gn,o=pn,o=Br(r,r===s?o:0,r.cancelPendingCommit!==null||r.timeoutHandle!==-1),c=r.callbackNode,o===0||r===s&&(In===2||In===9)||r.cancelPendingCommit!==null)return c!==null&&c!==null&&Ae(c),r.callbackNode=null,r.callbackPriority=0;if((o&3)===0||$r(r,o)){if(s=o&-o,s===r.callbackPriority)return s;switch(c!==null&&Ae(c),Kt(o)){case 2:case 8:o=Ge;break;case 32:o=Ye;break;case 268435456:o=Re;break;default:o=Ye}return c=Mm.bind(null,r),o=be(o,c),r.callbackPriority=s,r.callbackNode=o,s}return c!==null&&c!==null&&Ae(c),r.callbackPriority=2,r.callbackNode=null,2}function Mm(r,s){if(Qr!==0&&Qr!==5)return r.callbackNode=null,r.callbackPriority=0,null;var o=r.callbackNode;if(Gd()&&r.callbackNode!==o)return null;var c=pn;return c=Br(r,r===Gn?c:0,r.cancelPendingCommit!==null||r.timeoutHandle!==-1),c===0?null:(Kh(r,c,s),wm(r,xe()),r.callbackNode!=null&&r.callbackNode===o?Mm.bind(null,r):null)}function xm(r,s){if(Gd())return null;Kh(r,s,!0)}function Q_(){da(function(){(xn&6)!==0?be(Ee,q_):bm()})}function sp(){return Lo===0&&(Lo=jr()),Lo}function Tm(r){return r==null||typeof r=="symbol"||typeof r=="boolean"?null:typeof r=="function"?r:dt(""+r)}function Em(r,s){var o=s.ownerDocument.createElement("input");return o.name=s.name,o.value=s.value,r.id&&o.setAttribute("form",r.id),s.parentNode.insertBefore(o,s),r=new FormData(r),o.parentNode.removeChild(o),r}function X_(r,s,o,c,g){if(s==="submit"&&o&&o.stateNode===g){var M=Tm((g[ue]||null).action),j=c.submitter;j&&(s=(s=j[ue]||null)?Tm(s.formAction):j.getAttribute("formAction"),s!==null&&(M=s,j=null));var Y=new Yn("action","action",null,c,g);r.push({event:Y,listeners:[{instance:null,listener:function(){if(c.defaultPrevented){if(Lo!==0){var he=j?Em(g,j):new FormData(g);Fu(o,{pending:!0,data:he,method:g.method,action:M},null,he)}}else typeof M=="function"&&(Y.preventDefault(),he=j?Em(g,j):new FormData(g),Fu(o,{pending:!0,data:he,method:g.method,action:M},M,he))},currentTarget:g}]})}}for(var Nt=0;Nt<jt.length;Nt++){var Kd=jt[Nt],Fr=Kd.toLowerCase(),Ur=Kd[0].toUpperCase()+Kd.slice(1);Xt(Fr,"on"+Ur)}Xt(N,"onAnimationEnd"),Xt(K,"onAnimationIteration"),Xt(re,"onAnimationStart"),Xt("dblclick","onDoubleClick"),Xt("focusin","onFocus"),Xt("focusout","onBlur"),Xt(ye,"onTransitionRun"),Xt(He,"onTransitionStart"),Xt(at,"onTransitionCancel"),Xt(yt,"onTransitionEnd"),lr("onMouseEnter",["mouseout","mouseover"]),lr("onMouseLeave",["mouseout","mouseover"]),lr("onPointerEnter",["pointerout","pointerover"]),lr("onPointerLeave",["pointerout","pointerover"]),pr("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),pr("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),pr("onBeforeInput",["compositionend","keypress","textInput","paste"]),pr("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),pr("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),pr("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Pr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),zo=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Pr));function Sm(r,s){s=(s&4)!==0;for(var o=0;o<r.length;o++){var c=r[o],g=c.event;c=c.listeners;e:{var M=void 0;if(s)for(var j=c.length-1;0<=j;j--){var Y=c[j],he=Y.instance,$e=Y.currentTarget;if(Y=Y.listener,he!==M&&g.isPropagationStopped())break e;M=Y,g.currentTarget=$e;try{M(g)}catch(Ze){Wu(Ze)}g.currentTarget=null,M=he}else for(j=0;j<c.length;j++){if(Y=c[j],he=Y.instance,$e=Y.currentTarget,Y=Y.listener,he!==M&&g.isPropagationStopped())break e;M=Y,g.currentTarget=$e;try{M(g)}catch(Ze){Wu(Ze)}g.currentTarget=null,M=he}}}}function un(r,s){var o=s[ke];o===void 0&&(o=s[ke]=new Set);var c=r+"__bubble";o.has(c)||(Z(s,r,2,!1),o.add(c))}function qd(r,s,o){var c=0;s&&(c|=4),Z(o,r,c,s)}var A="_reactListening"+Math.random().toString(36).slice(2);function O(r){if(!r[A]){r[A]=!0,Bn.forEach(function(o){o!=="selectionchange"&&(zo.has(o)||qd(o,!1,r),qd(o,!0,r))});var s=r.nodeType===9?r:r.ownerDocument;s===null||s[A]||(s[A]=!0,qd("selectionchange",!1,s))}}function Z(r,s,o,c){switch(bv(s)){case 2:var g=aC;break;case 8:g=iC;break;default:g=ag}o=g.bind(null,s,o,r),g=void 0,!_r||s!=="touchstart"&&s!=="touchmove"&&s!=="wheel"||(g=!0),c?g!==void 0?r.addEventListener(s,o,{capture:!0,passive:g}):r.addEventListener(s,o,!0):g!==void 0?r.addEventListener(s,o,{passive:g}):r.addEventListener(s,o,!1)}function ge(r,s,o,c,g){var M=c;if((s&1)===0&&(s&2)===0&&c!==null)e:for(;;){if(c===null)return;var j=c.tag;if(j===3||j===4){var Y=c.stateNode.containerInfo;if(Y===g)break;if(j===4)for(j=c.return;j!==null;){var he=j.tag;if((he===3||he===4)&&j.stateNode.containerInfo===g)return;j=j.return}for(;Y!==null;){if(j=qt(Y),j===null)return;if(he=j.tag,he===5||he===6||he===26||he===27){c=M=j;continue e}Y=Y.parentNode}}c=c.return}Cn(function(){var $e=M,Ze=Ut(o),tt=[];e:{var Le=Pt.get(r);if(Le!==void 0){var Fe=Yn,Jt=r;switch(r){case"keypress":if(ms(o)===0)break e;case"keydown":case"keyup":Fe=tu;break;case"focusin":Jt="focus",Fe=Qo;break;case"focusout":Jt="blur",Fe=Qo;break;case"beforeblur":case"afterblur":Fe=Qo;break;case"click":if(o.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Fe=Ql;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Fe=Pc;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Fe=Ic;break;case N:case K:case re:Fe=kc;break;case yt:Fe=ff;break;case"scroll":case"scrollend":Fe=cs;break;case"wheel":Fe=Zo;break;case"copy":case"cut":case"paste":Fe=$c;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Fe=nu;break;case"toggle":case"beforetoggle":Fe=Jo}var Gt=(s&4)!==0,Qn=!Gt&&(r==="scroll"||r==="scrollend"),Me=Gt?Le!==null?Le+"Capture":null:Le;Gt=[];for(var ve=$e,Pe;ve!==null;){var Je=ve;if(Pe=Je.stateNode,Je=Je.tag,Je!==5&&Je!==26&&Je!==27||Pe===null||Me===null||(Je=Wr(ve,Me),Je!=null&&Gt.push(Se(ve,Je,Pe))),Qn)break;ve=ve.return}0<Gt.length&&(Le=new Fe(Le,Jt,null,o,Ze),tt.push({event:Le,listeners:Gt}))}}if((s&7)===0){e:{if(Le=r==="mouseover"||r==="pointerover",Fe=r==="mouseout"||r==="pointerout",Le&&o!==Qt&&(Jt=o.relatedTarget||o.fromElement)&&(qt(Jt)||Jt[pe]))break e;if((Fe||Le)&&(Le=Ze.window===Ze?Ze:(Le=Ze.ownerDocument)?Le.defaultView||Le.parentWindow:window,Fe?(Jt=o.relatedTarget||o.toElement,Fe=$e,Jt=Jt?qt(Jt):null,Jt!==null&&(Qn=l(Jt),Gt=Jt.tag,Jt!==Qn||Gt!==5&&Gt!==27&&Gt!==6)&&(Jt=null)):(Fe=null,Jt=$e),Fe!==Jt)){if(Gt=Ql,Je="onMouseLeave",Me="onMouseEnter",ve="mouse",(r==="pointerout"||r==="pointerover")&&(Gt=nu,Je="onPointerLeave",Me="onPointerEnter",ve="pointer"),Qn=Fe==null?Le:wn(Fe),Pe=Jt==null?Le:wn(Jt),Le=new Gt(Je,ve+"leave",Fe,o,Ze),Le.target=Qn,Le.relatedTarget=Pe,Je=null,qt(Ze)===$e&&(Gt=new Gt(Me,ve+"enter",Jt,o,Ze),Gt.target=Pe,Gt.relatedTarget=Qn,Je=Gt),Qn=Je,Fe&&Jt)t:{for(Gt=Fe,Me=Jt,ve=0,Pe=Gt;Pe;Pe=Xe(Pe))ve++;for(Pe=0,Je=Me;Je;Je=Xe(Je))Pe++;for(;0<ve-Pe;)Gt=Xe(Gt),ve--;for(;0<Pe-ve;)Me=Xe(Me),Pe--;for(;ve--;){if(Gt===Me||Me!==null&&Gt===Me.alternate)break t;Gt=Xe(Gt),Me=Xe(Me)}Gt=null}else Gt=null;Fe!==null&&it(tt,Le,Fe,Gt,!1),Jt!==null&&Qn!==null&&it(tt,Qn,Jt,Gt,!0)}}e:{if(Le=$e?wn($e):window,Fe=Le.nodeName&&Le.nodeName.toLowerCase(),Fe==="select"||Fe==="input"&&Le.type==="file")var Dt=rl;else if(Oi(Le))if(sl)Dt=ks;else{Dt=du;var hn=lo}else Fe=Le.nodeName,!Fe||Fe.toLowerCase()!=="input"||Le.type!=="checkbox"&&Le.type!=="radio"?$e&&gt($e.elementType)&&(Dt=rl):Dt=uo;if(Dt&&(Dt=Dt(r,$e))){ta(tt,Dt,o,Ze);break e}hn&&hn(r,Le,$e),r==="focusout"&&$e&&Le.type==="number"&&$e.memoizedProps.value!=null&&Si(Le,"number",Le.value)}switch(hn=$e?wn($e):window,r){case"focusin":(Oi(hn)||hn.contentEditable==="true")&&(Os=hn,Li=$e,xa=null);break;case"focusout":xa=Li=Os=null;break;case"mousedown":zi=!0;break;case"contextmenu":case"mouseup":case"dragend":zi=!1,il(tt,o,Ze);break;case"selectionchange":if(fu)break;case"keydown":case"keyup":il(tt,o,Ze)}var Rt;if(el)e:{switch(r){case"compositionstart":var Ht="onCompositionStart";break e;case"compositionend":Ht="onCompositionEnd";break e;case"compositionupdate":Ht="onCompositionUpdate";break e}Ht=void 0}else Ma?ki(r,o)&&(Ht="onCompositionEnd"):r==="keydown"&&o.keyCode===229&&(Ht="onCompositionStart");Ht&&(au&&o.locale!=="ko"&&(Ma||Ht!=="onCompositionStart"?Ht==="onCompositionEnd"&&Ma&&(Rt=ps()):(vn=Ze,nr="value"in vn?vn.value:vn.textContent,Ma=!0)),hn=Oe($e,Ht),0<hn.length&&(Ht=new Xl(Ht,r,null,o,Ze),tt.push({event:Ht,listeners:hn}),Rt?Ht.data=Rt:(Rt=wa(o),Rt!==null&&(Ht.data=Rt)))),(Rt=zc?tl(r,o):lu(r,o))&&(Ht=Oe($e,"onBeforeInput"),0<Ht.length&&(hn=new Xl("onBeforeInput","beforeinput",null,o,Ze),tt.push({event:hn,listeners:Ht}),hn.data=Rt)),X_(tt,r,$e,o,Ze)}Sm(tt,s)})}function Se(r,s,o){return{instance:r,listener:s,currentTarget:o}}function Oe(r,s){for(var o=s+"Capture",c=[];r!==null;){var g=r,M=g.stateNode;if(g=g.tag,g!==5&&g!==26&&g!==27||M===null||(g=Wr(r,o),g!=null&&c.unshift(Se(r,g,M)),g=Wr(r,s),g!=null&&c.push(Se(r,g,M))),r.tag===3)return c;r=r.return}return[]}function Xe(r){if(r===null)return null;do r=r.return;while(r&&r.tag!==5&&r.tag!==27);return r||null}function it(r,s,o,c,g){for(var M=s._reactName,j=[];o!==null&&o!==c;){var Y=o,he=Y.alternate,$e=Y.stateNode;if(Y=Y.tag,he!==null&&he===c)break;Y!==5&&Y!==26&&Y!==27||$e===null||(he=$e,g?($e=Wr(o,M),$e!=null&&j.unshift(Se(o,$e,he))):g||($e=Wr(o,M),$e!=null&&j.push(Se(o,$e,he)))),o=o.return}j.length!==0&&r.push({event:s,listeners:j})}var ht=/\r\n?/g,St=/\u0000|\uFFFD/g;function Vt(r){return(typeof r=="string"?r:""+r).replace(ht,`
`).replace(St,"")}function Yt(r,s){return s=Vt(s),Vt(r)===s}function Wt(){}function bt(r,s,o,c,g,M){switch(o){case"children":typeof c=="string"?s==="body"||s==="textarea"&&c===""||de(r,c):(typeof c=="number"||typeof c=="bigint")&&s!=="body"&&de(r,""+c);break;case"className":ur(r,"class",c);break;case"tabIndex":ur(r,"tabindex",c);break;case"dir":case"role":case"viewBox":case"width":case"height":ur(r,o,c);break;case"style":Ke(r,c,M);break;case"data":if(s!=="object"){ur(r,"data",c);break}case"src":case"href":if(c===""&&(s!=="a"||o!=="href")){r.removeAttribute(o);break}if(c==null||typeof c=="function"||typeof c=="symbol"||typeof c=="boolean"){r.removeAttribute(o);break}c=dt(""+c),r.setAttribute(o,c);break;case"action":case"formAction":if(typeof c=="function"){r.setAttribute(o,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof M=="function"&&(o==="formAction"?(s!=="input"&&bt(r,s,"name",g.name,g,null),bt(r,s,"formEncType",g.formEncType,g,null),bt(r,s,"formMethod",g.formMethod,g,null),bt(r,s,"formTarget",g.formTarget,g,null)):(bt(r,s,"encType",g.encType,g,null),bt(r,s,"method",g.method,g,null),bt(r,s,"target",g.target,g,null)));if(c==null||typeof c=="symbol"||typeof c=="boolean"){r.removeAttribute(o);break}c=dt(""+c),r.setAttribute(o,c);break;case"onClick":c!=null&&(r.onclick=Wt);break;case"onScroll":c!=null&&un("scroll",r);break;case"onScrollEnd":c!=null&&un("scrollend",r);break;case"dangerouslySetInnerHTML":if(c!=null){if(typeof c!="object"||!("__html"in c))throw Error(a(61));if(o=c.__html,o!=null){if(g.children!=null)throw Error(a(60));r.innerHTML=o}}break;case"multiple":r.multiple=c&&typeof c!="function"&&typeof c!="symbol";break;case"muted":r.muted=c&&typeof c!="function"&&typeof c!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(c==null||typeof c=="function"||typeof c=="boolean"||typeof c=="symbol"){r.removeAttribute("xlink:href");break}o=dt(""+c),r.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",o);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":c!=null&&typeof c!="function"&&typeof c!="symbol"?r.setAttribute(o,""+c):r.removeAttribute(o);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":c&&typeof c!="function"&&typeof c!="symbol"?r.setAttribute(o,""):r.removeAttribute(o);break;case"capture":case"download":c===!0?r.setAttribute(o,""):c!==!1&&c!=null&&typeof c!="function"&&typeof c!="symbol"?r.setAttribute(o,c):r.removeAttribute(o);break;case"cols":case"rows":case"size":case"span":c!=null&&typeof c!="function"&&typeof c!="symbol"&&!isNaN(c)&&1<=c?r.setAttribute(o,c):r.removeAttribute(o);break;case"rowSpan":case"start":c==null||typeof c=="function"||typeof c=="symbol"||isNaN(c)?r.removeAttribute(o):r.setAttribute(o,c);break;case"popover":un("beforetoggle",r),un("toggle",r),Vr(r,"popover",c);break;case"xlinkActuate":mr(r,"http://www.w3.org/1999/xlink","xlink:actuate",c);break;case"xlinkArcrole":mr(r,"http://www.w3.org/1999/xlink","xlink:arcrole",c);break;case"xlinkRole":mr(r,"http://www.w3.org/1999/xlink","xlink:role",c);break;case"xlinkShow":mr(r,"http://www.w3.org/1999/xlink","xlink:show",c);break;case"xlinkTitle":mr(r,"http://www.w3.org/1999/xlink","xlink:title",c);break;case"xlinkType":mr(r,"http://www.w3.org/1999/xlink","xlink:type",c);break;case"xmlBase":mr(r,"http://www.w3.org/XML/1998/namespace","xml:base",c);break;case"xmlLang":mr(r,"http://www.w3.org/XML/1998/namespace","xml:lang",c);break;case"xmlSpace":mr(r,"http://www.w3.org/XML/1998/namespace","xml:space",c);break;case"is":Vr(r,"is",c);break;case"innerText":case"textContent":break;default:(!(2<o.length)||o[0]!=="o"&&o[0]!=="O"||o[1]!=="n"&&o[1]!=="N")&&(o=vt.get(o)||o,Vr(r,o,c))}}function yn(r,s,o,c,g,M){switch(o){case"style":Ke(r,c,M);break;case"dangerouslySetInnerHTML":if(c!=null){if(typeof c!="object"||!("__html"in c))throw Error(a(61));if(o=c.__html,o!=null){if(g.children!=null)throw Error(a(60));r.innerHTML=o}}break;case"children":typeof c=="string"?de(r,c):(typeof c=="number"||typeof c=="bigint")&&de(r,""+c);break;case"onScroll":c!=null&&un("scroll",r);break;case"onScrollEnd":c!=null&&un("scrollend",r);break;case"onClick":c!=null&&(r.onclick=Wt);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!hr.hasOwnProperty(o))e:{if(o[0]==="o"&&o[1]==="n"&&(g=o.endsWith("Capture"),s=o.slice(2,g?o.length-7:void 0),M=r[ue]||null,M=M!=null?M[o]:null,typeof M=="function"&&r.removeEventListener(s,M,g),typeof c=="function")){typeof M!="function"&&M!==null&&(o in r?r[o]=null:r.hasAttribute(o)&&r.removeAttribute(o)),r.addEventListener(s,c,g);break e}o in r?r[o]=c:c===!0?r.setAttribute(o,""):Vr(r,o,c)}}}function Ct(r,s,o){switch(s){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":un("error",r),un("load",r);var c=!1,g=!1,M;for(M in o)if(o.hasOwnProperty(M)){var j=o[M];if(j!=null)switch(M){case"src":c=!0;break;case"srcSet":g=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(a(137,s));default:bt(r,s,M,j,o,null)}}g&&bt(r,s,"srcSet",o.srcSet,o,null),c&&bt(r,s,"src",o.src,o,null);return;case"input":un("invalid",r);var Y=M=j=g=null,he=null,$e=null;for(c in o)if(o.hasOwnProperty(c)){var Ze=o[c];if(Ze!=null)switch(c){case"name":g=Ze;break;case"type":j=Ze;break;case"checked":he=Ze;break;case"defaultChecked":$e=Ze;break;case"value":M=Ze;break;case"defaultValue":Y=Ze;break;case"children":case"dangerouslySetInnerHTML":if(Ze!=null)throw Error(a(137,s));break;default:bt(r,s,c,Ze,o,null)}}Ei(r,M,Y,he,$e,j,g,!1),$n(r);return;case"select":un("invalid",r),c=j=M=null;for(g in o)if(o.hasOwnProperty(g)&&(Y=o[g],Y!=null))switch(g){case"value":M=Y;break;case"defaultValue":j=Y;break;case"multiple":c=Y;default:bt(r,s,g,Y,o,null)}s=M,o=j,r.multiple=!!c,s!=null?we(r,!!c,s,!1):o!=null&&we(r,!!c,o,!0);return;case"textarea":un("invalid",r),M=g=c=null;for(j in o)if(o.hasOwnProperty(j)&&(Y=o[j],Y!=null))switch(j){case"value":c=Y;break;case"defaultValue":g=Y;break;case"children":M=Y;break;case"dangerouslySetInnerHTML":if(Y!=null)throw Error(a(91));break;default:bt(r,s,j,Y,o,null)}se(r,c,g,M),$n(r);return;case"option":for(he in o)if(o.hasOwnProperty(he)&&(c=o[he],c!=null))switch(he){case"selected":r.selected=c&&typeof c!="function"&&typeof c!="symbol";break;default:bt(r,s,he,c,o,null)}return;case"dialog":un("beforetoggle",r),un("toggle",r),un("cancel",r),un("close",r);break;case"iframe":case"object":un("load",r);break;case"video":case"audio":for(c=0;c<Pr.length;c++)un(Pr[c],r);break;case"image":un("error",r),un("load",r);break;case"details":un("toggle",r);break;case"embed":case"source":case"link":un("error",r),un("load",r);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for($e in o)if(o.hasOwnProperty($e)&&(c=o[$e],c!=null))switch($e){case"children":case"dangerouslySetInnerHTML":throw Error(a(137,s));default:bt(r,s,$e,c,o,null)}return;default:if(gt(s)){for(Ze in o)o.hasOwnProperty(Ze)&&(c=o[Ze],c!==void 0&&yn(r,s,Ze,c,o,void 0));return}}for(Y in o)o.hasOwnProperty(Y)&&(c=o[Y],c!=null&&bt(r,s,Y,c,o,null))}function Lt(r,s,o,c){switch(s){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var g=null,M=null,j=null,Y=null,he=null,$e=null,Ze=null;for(Fe in o){var tt=o[Fe];if(o.hasOwnProperty(Fe)&&tt!=null)switch(Fe){case"checked":break;case"value":break;case"defaultValue":he=tt;default:c.hasOwnProperty(Fe)||bt(r,s,Fe,null,c,tt)}}for(var Le in c){var Fe=c[Le];if(tt=o[Le],c.hasOwnProperty(Le)&&(Fe!=null||tt!=null))switch(Le){case"type":M=Fe;break;case"name":g=Fe;break;case"checked":$e=Fe;break;case"defaultChecked":Ze=Fe;break;case"value":j=Fe;break;case"defaultValue":Y=Fe;break;case"children":case"dangerouslySetInnerHTML":if(Fe!=null)throw Error(a(137,s));break;default:Fe!==tt&&bt(r,s,Le,Fe,c,tt)}}Ua(r,j,Y,he,$e,Ze,M,g);return;case"select":Fe=j=Y=Le=null;for(M in o)if(he=o[M],o.hasOwnProperty(M)&&he!=null)switch(M){case"value":break;case"multiple":Fe=he;default:c.hasOwnProperty(M)||bt(r,s,M,null,c,he)}for(g in c)if(M=c[g],he=o[g],c.hasOwnProperty(g)&&(M!=null||he!=null))switch(g){case"value":Le=M;break;case"defaultValue":Y=M;break;case"multiple":j=M;default:M!==he&&bt(r,s,g,M,c,he)}s=Y,o=j,c=Fe,Le!=null?we(r,!!o,Le,!1):!!c!=!!o&&(s!=null?we(r,!!o,s,!0):we(r,!!o,o?[]:"",!1));return;case"textarea":Fe=Le=null;for(Y in o)if(g=o[Y],o.hasOwnProperty(Y)&&g!=null&&!c.hasOwnProperty(Y))switch(Y){case"value":break;case"children":break;default:bt(r,s,Y,null,c,g)}for(j in c)if(g=c[j],M=o[j],c.hasOwnProperty(j)&&(g!=null||M!=null))switch(j){case"value":Le=g;break;case"defaultValue":Fe=g;break;case"children":break;case"dangerouslySetInnerHTML":if(g!=null)throw Error(a(91));break;default:g!==M&&bt(r,s,j,g,c,M)}F(r,Le,Fe);return;case"option":for(var Jt in o)if(Le=o[Jt],o.hasOwnProperty(Jt)&&Le!=null&&!c.hasOwnProperty(Jt))switch(Jt){case"selected":r.selected=!1;break;default:bt(r,s,Jt,null,c,Le)}for(he in c)if(Le=c[he],Fe=o[he],c.hasOwnProperty(he)&&Le!==Fe&&(Le!=null||Fe!=null))switch(he){case"selected":r.selected=Le&&typeof Le!="function"&&typeof Le!="symbol";break;default:bt(r,s,he,Le,c,Fe)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Gt in o)Le=o[Gt],o.hasOwnProperty(Gt)&&Le!=null&&!c.hasOwnProperty(Gt)&&bt(r,s,Gt,null,c,Le);for($e in c)if(Le=c[$e],Fe=o[$e],c.hasOwnProperty($e)&&Le!==Fe&&(Le!=null||Fe!=null))switch($e){case"children":case"dangerouslySetInnerHTML":if(Le!=null)throw Error(a(137,s));break;default:bt(r,s,$e,Le,c,Fe)}return;default:if(gt(s)){for(var Qn in o)Le=o[Qn],o.hasOwnProperty(Qn)&&Le!==void 0&&!c.hasOwnProperty(Qn)&&yn(r,s,Qn,void 0,c,Le);for(Ze in c)Le=c[Ze],Fe=o[Ze],!c.hasOwnProperty(Ze)||Le===Fe||Le===void 0&&Fe===void 0||yn(r,s,Ze,Le,c,Fe);return}}for(var Me in o)Le=o[Me],o.hasOwnProperty(Me)&&Le!=null&&!c.hasOwnProperty(Me)&&bt(r,s,Me,null,c,Le);for(tt in c)Le=c[tt],Fe=o[tt],!c.hasOwnProperty(tt)||Le===Fe||Le==null&&Fe==null||bt(r,s,tt,Le,c,Fe)}var cn=null,Ln=null;function Hn(r){return r.nodeType===9?r:r.ownerDocument}function br(r){switch(r){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function wr(r,s){if(r===0)switch(s){case"svg":return 1;case"math":return 2;default:return 0}return r===1&&s==="foreignObject"?0:r}function ar(r,s){return r==="textarea"||r==="noscript"||typeof s.children=="string"||typeof s.children=="number"||typeof s.children=="bigint"||typeof s.dangerouslySetInnerHTML=="object"&&s.dangerouslySetInnerHTML!==null&&s.dangerouslySetInnerHTML.__html!=null}var nn=null;function ir(){var r=window.event;return r&&r.type==="popstate"?r===nn?!1:(nn=r,!0):(nn=null,!1)}var Rr=typeof setTimeout=="function"?setTimeout:void 0,Fo=typeof clearTimeout=="function"?clearTimeout:void 0,as=typeof Promise=="function"?Promise:void 0,da=typeof queueMicrotask=="function"?queueMicrotask:typeof as<"u"?function(r){return as.resolve(null).then(r).catch($l)}:Rr;function $l(r){setTimeout(function(){throw r})}function Rs(r){return r==="head"}function uc(r,s){var o=s,c=0,g=0;do{var M=o.nextSibling;if(r.removeChild(o),M&&M.nodeType===8)if(o=M.data,o==="/$"){if(0<c&&8>c){o=c;var j=r.ownerDocument;if(o&1&&Bo(j.documentElement),o&2&&Bo(j.body),o&4)for(o=j.head,Bo(o),j=o.firstChild;j;){var Y=j.nextSibling,he=j.nodeName;j[mt]||he==="SCRIPT"||he==="STYLE"||he==="LINK"&&j.rel.toLowerCase()==="stylesheet"||o.removeChild(j),j=Y}}if(g===0){r.removeChild(M),hp(s);return}g--}else o==="$"||o==="$?"||o==="$!"?g++:c=o.charCodeAt(0)-48;else c=0;o=M}while(o);hp(s)}function Ro(r){var s=r.firstChild;for(s&&s.nodeType===10&&(s=s.nextSibling);s;){var o=s;switch(s=s.nextSibling,o.nodeName){case"HTML":case"HEAD":case"BODY":Ro(o),Zt(o);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(o.rel.toLowerCase()==="stylesheet")continue}r.removeChild(o)}}function Y_(r,s,o,c){for(;r.nodeType===1;){var g=o;if(r.nodeName.toLowerCase()!==s.toLowerCase()){if(!c&&(r.nodeName!=="INPUT"||r.type!=="hidden"))break}else if(c){if(!r[mt])switch(s){case"meta":if(!r.hasAttribute("itemprop"))break;return r;case"link":if(M=r.getAttribute("rel"),M==="stylesheet"&&r.hasAttribute("data-precedence"))break;if(M!==g.rel||r.getAttribute("href")!==(g.href==null||g.href===""?null:g.href)||r.getAttribute("crossorigin")!==(g.crossOrigin==null?null:g.crossOrigin)||r.getAttribute("title")!==(g.title==null?null:g.title))break;return r;case"style":if(r.hasAttribute("data-precedence"))break;return r;case"script":if(M=r.getAttribute("src"),(M!==(g.src==null?null:g.src)||r.getAttribute("type")!==(g.type==null?null:g.type)||r.getAttribute("crossorigin")!==(g.crossOrigin==null?null:g.crossOrigin))&&M&&r.hasAttribute("async")&&!r.hasAttribute("itemprop"))break;return r;default:return r}}else if(s==="input"&&r.type==="hidden"){var M=g.name==null?null:""+g.name;if(g.type==="hidden"&&r.getAttribute("name")===M)return r}else return r;if(r=es(r.nextSibling),r===null)break}return null}function qn(r,s,o){if(s==="")return null;for(;r.nodeType!==3;)if((r.nodeType!==1||r.nodeName!=="INPUT"||r.type!=="hidden")&&!o||(r=es(r.nextSibling),r===null))return null;return r}function Mr(r){return r.data==="$!"||r.data==="$?"&&r.ownerDocument.readyState==="complete"}function Xi(r,s){var o=r.ownerDocument;if(r.data!=="$?"||o.readyState==="complete")s();else{var c=function(){s(),o.removeEventListener("DOMContentLoaded",c)};o.addEventListener("DOMContentLoaded",c),r._reactRetry=c}}function es(r){for(;r!=null;r=r.nextSibling){var s=r.nodeType;if(s===1||s===3)break;if(s===8){if(s=r.data,s==="$"||s==="$!"||s==="$?"||s==="F!"||s==="F")break;if(s==="/$")return null}}return r}var Yi=null;function cc(r){r=r.previousSibling;for(var s=0;r;){if(r.nodeType===8){var o=r.data;if(o==="$"||o==="$!"||o==="$?"){if(s===0)return r;s--}else o==="/$"&&s++}r=r.previousSibling}return null}function Qd(r,s,o){switch(s=Hn(o),r){case"html":if(r=s.documentElement,!r)throw Error(a(452));return r;case"head":if(r=s.head,!r)throw Error(a(453));return r;case"body":if(r=s.body,!r)throw Error(a(454));return r;default:throw Error(a(451))}}function Bo(r){for(var s=r.attributes;s.length;)r.removeAttributeNode(s[0]);Zt(r)}var ws=new Map,Cm=new Set;function Dl(r){return typeof r.getRootNode=="function"?r.getRootNode():r.nodeType===9?r:r.ownerDocument}var Qs=te.d;te.d={f:ap,r:Pm,D:Z_,C:J_,L:eg,m:jo,X:XS,S:fa,M:YS};function ap(){var r=Qs.f(),s=ic();return r||s}function Pm(r){var s=On(r);s!==null&&s.tag===5&&s.type==="form"?Yf(s):Qs.r(r)}var Zi=typeof document>"u"?null:document;function dc(r,s,o){var c=Zi;if(c&&typeof s=="string"&&s){var g=Gr(s);g='link[rel="'+r+'"][href="'+g+'"]',typeof o=="string"&&(g+='[crossorigin="'+o+'"]'),Cm.has(g)||(Cm.add(g),r={rel:r,crossOrigin:o,href:s},c.querySelector(g)===null&&(s=c.createElement("link"),Ct(s,"link",r),Sn(s),c.head.appendChild(s)))}}function Z_(r){Qs.D(r),dc("dns-prefetch",r,null)}function J_(r,s){Qs.C(r,s),dc("preconnect",r,s)}function eg(r,s,o){Qs.L(r,s,o);var c=Zi;if(c&&r&&s){var g='link[rel="preload"][as="'+Gr(s)+'"]';s==="image"&&o&&o.imageSrcSet?(g+='[imagesrcset="'+Gr(o.imageSrcSet)+'"]',typeof o.imageSizes=="string"&&(g+='[imagesizes="'+Gr(o.imageSizes)+'"]')):g+='[href="'+Gr(r)+'"]';var M=g;switch(s){case"style":M=Xd(r);break;case"script":M=Yd(r)}ws.has(M)||(r=_({rel:"preload",href:s==="image"&&o&&o.imageSrcSet?void 0:r,as:s},o),ws.set(M,r),c.querySelector(g)!==null||s==="style"&&c.querySelector(ip(M))||s==="script"&&c.querySelector(op(M))||(s=c.createElement("link"),Ct(s,"link",r),Sn(s),c.head.appendChild(s)))}}function jo(r,s){Qs.m(r,s);var o=Zi;if(o&&r){var c=s&&typeof s.as=="string"?s.as:"script",g='link[rel="modulepreload"][as="'+Gr(c)+'"][href="'+Gr(r)+'"]',M=g;switch(c){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":M=Yd(r)}if(!ws.has(M)&&(r=_({rel:"modulepreload",href:r},s),ws.set(M,r),o.querySelector(g)===null)){switch(c){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(o.querySelector(op(M)))return}c=o.createElement("link"),Ct(c,"link",r),Sn(c),o.head.appendChild(c)}}}function fa(r,s,o){Qs.S(r,s,o);var c=Zi;if(c&&r){var g=Un(c).hoistableStyles,M=Xd(r);s=s||"default";var j=g.get(M);if(!j){var Y={loading:0,preload:null};if(j=c.querySelector(ip(M)))Y.loading=5;else{r=_({rel:"stylesheet",href:r,"data-precedence":s},o),(o=ws.get(M))&&tg(r,o);var he=j=c.createElement("link");Sn(he),Ct(he,"link",r),he._p=new Promise(function($e,Ze){he.onload=$e,he.onerror=Ze}),he.addEventListener("load",function(){Y.loading|=1}),he.addEventListener("error",function(){Y.loading|=2}),Y.loading|=4,Am(j,s,c)}j={type:"stylesheet",instance:j,count:1,state:Y},g.set(M,j)}}}function XS(r,s){Qs.X(r,s);var o=Zi;if(o&&r){var c=Un(o).hoistableScripts,g=Yd(r),M=c.get(g);M||(M=o.querySelector(op(g)),M||(r=_({src:r,async:!0},s),(s=ws.get(g))&&ng(r,s),M=o.createElement("script"),Sn(M),Ct(M,"link",r),o.head.appendChild(M)),M={type:"script",instance:M,count:1,state:null},c.set(g,M))}}function YS(r,s){Qs.M(r,s);var o=Zi;if(o&&r){var c=Un(o).hoistableScripts,g=Yd(r),M=c.get(g);M||(M=o.querySelector(op(g)),M||(r=_({src:r,async:!0,type:"module"},s),(s=ws.get(g))&&ng(r,s),M=o.createElement("script"),Sn(M),Ct(M,"link",r),o.head.appendChild(M)),M={type:"script",instance:M,count:1,state:null},c.set(g,M))}}function uv(r,s,o,c){var g=(g=Te.current)?Dl(g):null;if(!g)throw Error(a(446));switch(r){case"meta":case"title":return null;case"style":return typeof o.precedence=="string"&&typeof o.href=="string"?(s=Xd(o.href),o=Un(g).hoistableStyles,c=o.get(s),c||(c={type:"style",instance:null,count:0,state:null},o.set(s,c)),c):{type:"void",instance:null,count:0,state:null};case"link":if(o.rel==="stylesheet"&&typeof o.href=="string"&&typeof o.precedence=="string"){r=Xd(o.href);var M=Un(g).hoistableStyles,j=M.get(r);if(j||(g=g.ownerDocument||g,j={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},M.set(r,j),(M=g.querySelector(ip(r)))&&!M._p&&(j.instance=M,j.state.loading=5),ws.has(r)||(o={rel:"preload",as:"style",href:o.href,crossOrigin:o.crossOrigin,integrity:o.integrity,media:o.media,hrefLang:o.hrefLang,referrerPolicy:o.referrerPolicy},ws.set(r,o),M||ZS(g,r,o,j.state))),s&&c===null)throw Error(a(528,""));return j}if(s&&c!==null)throw Error(a(529,""));return null;case"script":return s=o.async,o=o.src,typeof o=="string"&&s&&typeof s!="function"&&typeof s!="symbol"?(s=Yd(o),o=Un(g).hoistableScripts,c=o.get(s),c||(c={type:"script",instance:null,count:0,state:null},o.set(s,c)),c):{type:"void",instance:null,count:0,state:null};default:throw Error(a(444,r))}}function Xd(r){return'href="'+Gr(r)+'"'}function ip(r){return'link[rel="stylesheet"]['+r+"]"}function cv(r){return _({},r,{"data-precedence":r.precedence,precedence:null})}function ZS(r,s,o,c){r.querySelector('link[rel="preload"][as="style"]['+s+"]")?c.loading=1:(s=r.createElement("link"),c.preload=s,s.addEventListener("load",function(){return c.loading|=1}),s.addEventListener("error",function(){return c.loading|=2}),Ct(s,"link",o),Sn(s),r.head.appendChild(s))}function Yd(r){return'[src="'+Gr(r)+'"]'}function op(r){return"script[async]"+r}function dv(r,s,o){if(s.count++,s.instance===null)switch(s.type){case"style":var c=r.querySelector('style[data-href~="'+Gr(o.href)+'"]');if(c)return s.instance=c,Sn(c),c;var g=_({},o,{"data-href":o.href,"data-precedence":o.precedence,href:null,precedence:null});return c=(r.ownerDocument||r).createElement("style"),Sn(c),Ct(c,"style",g),Am(c,o.precedence,r),s.instance=c;case"stylesheet":g=Xd(o.href);var M=r.querySelector(ip(g));if(M)return s.state.loading|=4,s.instance=M,Sn(M),M;c=cv(o),(g=ws.get(g))&&tg(c,g),M=(r.ownerDocument||r).createElement("link"),Sn(M);var j=M;return j._p=new Promise(function(Y,he){j.onload=Y,j.onerror=he}),Ct(M,"link",c),s.state.loading|=4,Am(M,o.precedence,r),s.instance=M;case"script":return M=Yd(o.src),(g=r.querySelector(op(M)))?(s.instance=g,Sn(g),g):(c=o,(g=ws.get(M))&&(c=_({},o),ng(c,g)),r=r.ownerDocument||r,g=r.createElement("script"),Sn(g),Ct(g,"link",c),r.head.appendChild(g),s.instance=g);case"void":return null;default:throw Error(a(443,s.type))}else s.type==="stylesheet"&&(s.state.loading&4)===0&&(c=s.instance,s.state.loading|=4,Am(c,o.precedence,r));return s.instance}function Am(r,s,o){for(var c=o.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),g=c.length?c[c.length-1]:null,M=g,j=0;j<c.length;j++){var Y=c[j];if(Y.dataset.precedence===s)M=Y;else if(M!==g)break}M?M.parentNode.insertBefore(r,M.nextSibling):(s=o.nodeType===9?o.head:o,s.insertBefore(r,s.firstChild))}function tg(r,s){r.crossOrigin==null&&(r.crossOrigin=s.crossOrigin),r.referrerPolicy==null&&(r.referrerPolicy=s.referrerPolicy),r.title==null&&(r.title=s.title)}function ng(r,s){r.crossOrigin==null&&(r.crossOrigin=s.crossOrigin),r.referrerPolicy==null&&(r.referrerPolicy=s.referrerPolicy),r.integrity==null&&(r.integrity=s.integrity)}var km=null;function fv(r,s,o){if(km===null){var c=new Map,g=km=new Map;g.set(o,c)}else g=km,c=g.get(o),c||(c=new Map,g.set(o,c));if(c.has(r))return c;for(c.set(r,null),o=o.getElementsByTagName(r),g=0;g<o.length;g++){var M=o[g];if(!(M[mt]||M[X]||r==="link"&&M.getAttribute("rel")==="stylesheet")&&M.namespaceURI!=="http://www.w3.org/2000/svg"){var j=M.getAttribute(s)||"";j=r+j;var Y=c.get(j);Y?Y.push(M):c.set(j,[M])}}return c}function hv(r,s,o){r=r.ownerDocument||r,r.head.insertBefore(o,s==="title"?r.querySelector("head > title"):null)}function JS(r,s,o){if(o===1||s.itemProp!=null)return!1;switch(r){case"meta":case"title":return!0;case"style":if(typeof s.precedence!="string"||typeof s.href!="string"||s.href==="")break;return!0;case"link":if(typeof s.rel!="string"||typeof s.href!="string"||s.href===""||s.onLoad||s.onError)break;switch(s.rel){case"stylesheet":return r=s.disabled,typeof s.precedence=="string"&&r==null;default:return!0}case"script":if(s.async&&typeof s.async!="function"&&typeof s.async!="symbol"&&!s.onLoad&&!s.onError&&s.src&&typeof s.src=="string")return!0}return!1}function pv(r){return!(r.type==="stylesheet"&&(r.state.loading&3)===0)}var lp=null;function eC(){}function tC(r,s,o){if(lp===null)throw Error(a(475));var c=lp;if(s.type==="stylesheet"&&(typeof o.media!="string"||matchMedia(o.media).matches!==!1)&&(s.state.loading&4)===0){if(s.instance===null){var g=Xd(o.href),M=r.querySelector(ip(g));if(M){r=M._p,r!==null&&typeof r=="object"&&typeof r.then=="function"&&(c.count++,c=Om.bind(c),r.then(c,c)),s.state.loading|=4,s.instance=M,Sn(M);return}M=r.ownerDocument||r,o=cv(o),(g=ws.get(g))&&tg(o,g),M=M.createElement("link"),Sn(M);var j=M;j._p=new Promise(function(Y,he){j.onload=Y,j.onerror=he}),Ct(M,"link",o),s.instance=M}c.stylesheets===null&&(c.stylesheets=new Map),c.stylesheets.set(s,r),(r=s.state.preload)&&(s.state.loading&3)===0&&(c.count++,s=Om.bind(c),r.addEventListener("load",s),r.addEventListener("error",s))}}function nC(){if(lp===null)throw Error(a(475));var r=lp;return r.stylesheets&&r.count===0&&rg(r,r.stylesheets),0<r.count?function(s){var o=setTimeout(function(){if(r.stylesheets&&rg(r,r.stylesheets),r.unsuspend){var c=r.unsuspend;r.unsuspend=null,c()}},6e4);return r.unsuspend=s,function(){r.unsuspend=null,clearTimeout(o)}}:null}function Om(){if(this.count--,this.count===0){if(this.stylesheets)rg(this,this.stylesheets);else if(this.unsuspend){var r=this.unsuspend;this.unsuspend=null,r()}}}var $m=null;function rg(r,s){r.stylesheets=null,r.unsuspend!==null&&(r.count++,$m=new Map,s.forEach(rC,r),$m=null,Om.call(r))}function rC(r,s){if(!(s.state.loading&4)){var o=$m.get(r);if(o)var c=o.get(null);else{o=new Map,$m.set(r,o);for(var g=r.querySelectorAll("link[data-precedence],style[data-precedence]"),M=0;M<g.length;M++){var j=g[M];(j.nodeName==="LINK"||j.getAttribute("media")!=="not all")&&(o.set(j.dataset.precedence,j),c=j)}c&&o.set(null,c)}g=s.instance,j=g.getAttribute("data-precedence"),M=o.get(j)||c,M===c&&o.set(null,g),o.set(j,g),this.count++,c=Om.bind(this),g.addEventListener("load",c),g.addEventListener("error",c),M?M.parentNode.insertBefore(g,M.nextSibling):(r=r.nodeType===9?r.head:r,r.insertBefore(g,r.firstChild)),s.state.loading|=4}}var up={$$typeof:I,Provider:null,Consumer:null,_currentValue:ie,_currentValue2:ie,_threadCount:0};function sC(r,s,o,c,g,M,j,Y){this.tag=1,this.containerInfo=r,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=ga(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=ga(0),this.hiddenUpdates=ga(null),this.identifierPrefix=c,this.onUncaughtError=g,this.onCaughtError=M,this.onRecoverableError=j,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=Y,this.incompleteTransitions=new Map}function mv(r,s,o,c,g,M,j,Y,he,$e,Ze,tt){return r=new sC(r,s,o,j,Y,he,$e,tt),s=1,M===!0&&(s|=24),M=_s(3,null,null,s),r.current=M,M.stateNode=r,s=Xc(),s.refCount++,r.pooledCache=s,s.refCount++,M.memoizedState={element:c,isDehydrated:o,cache:s},Tu(M),r}function _v(r){return r?(r=go,r):go}function gv(r,s,o,c,g,M){g=_v(g),c.context===null?c.context=g:c.pendingContext=g,c=ti(s),c.payload={element:o},M=M===void 0?null:M,M!==null&&(c.callback=M),o=ni(r,c,s),o!==null&&(zs(o,r,s),_l(o,r,s))}function yv(r,s){if(r=r.memoizedState,r!==null&&r.dehydrated!==null){var o=r.retryLane;r.retryLane=o!==0&&o<s?o:s}}function sg(r,s){yv(r,s),(r=r.alternate)&&yv(r,s)}function vv(r){if(r.tag===13){var s=_o(r,67108864);s!==null&&zs(s,r,67108864),sg(r,67108864)}}var Dm=!0;function aC(r,s,o,c){var g=W.T;W.T=null;var M=te.p;try{te.p=2,ag(r,s,o,c)}finally{te.p=M,W.T=g}}function iC(r,s,o,c){var g=W.T;W.T=null;var M=te.p;try{te.p=8,ag(r,s,o,c)}finally{te.p=M,W.T=g}}function ag(r,s,o,c){if(Dm){var g=ig(c);if(g===null)ge(r,s,c,Im,o),wv(r,c);else if(lC(g,r,s,o,c))c.stopPropagation();else if(wv(r,c),s&4&&-1<oC.indexOf(r)){for(;g!==null;){var M=On(g);if(M!==null)switch(M.tag){case 3:if(M=M.stateNode,M.current.memoizedState.isDehydrated){var j=Or(M.pendingLanes);if(j!==0){var Y=M;for(Y.pendingLanes|=2,Y.entangledLanes|=2;j;){var he=1<<31-lt(j);Y.entanglements[1]|=he,j&=~he}Ia(M),(xn&6)===0&&(jd=xe()+500,lc(0))}}break;case 13:Y=_o(M,2),Y!==null&&zs(Y,M,2),ic(),sg(M,2)}if(M=ig(c),M===null&&ge(r,s,c,Im,o),M===g)break;g=M}g!==null&&c.stopPropagation()}else ge(r,s,c,null,o)}}function ig(r){return r=Ut(r),og(r)}var Im=null;function og(r){if(Im=null,r=qt(r),r!==null){var s=l(r);if(s===null)r=null;else{var o=s.tag;if(o===13){if(r=u(s),r!==null)return r;r=null}else if(o===3){if(s.stateNode.current.memoizedState.isDehydrated)return s.tag===3?s.stateNode.containerInfo:null;r=null}else s!==r&&(r=null)}}return Im=r,null}function bv(r){switch(r){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Ve()){case Ee:return 2;case Ge:return 8;case Ye:case _t:return 32;case Re:return 268435456;default:return 32}default:return 32}}var lg=!1,Il=null,Ll=null,zl=null,cp=new Map,dp=new Map,Fl=[],oC="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function wv(r,s){switch(r){case"focusin":case"focusout":Il=null;break;case"dragenter":case"dragleave":Ll=null;break;case"mouseover":case"mouseout":zl=null;break;case"pointerover":case"pointerout":cp.delete(s.pointerId);break;case"gotpointercapture":case"lostpointercapture":dp.delete(s.pointerId)}}function fp(r,s,o,c,g,M){return r===null||r.nativeEvent!==M?(r={blockedOn:s,domEventName:o,eventSystemFlags:c,nativeEvent:M,targetContainers:[g]},s!==null&&(s=On(s),s!==null&&vv(s)),r):(r.eventSystemFlags|=c,s=r.targetContainers,g!==null&&s.indexOf(g)===-1&&s.push(g),r)}function lC(r,s,o,c,g){switch(s){case"focusin":return Il=fp(Il,r,s,o,c,g),!0;case"dragenter":return Ll=fp(Ll,r,s,o,c,g),!0;case"mouseover":return zl=fp(zl,r,s,o,c,g),!0;case"pointerover":var M=g.pointerId;return cp.set(M,fp(cp.get(M)||null,r,s,o,c,g)),!0;case"gotpointercapture":return M=g.pointerId,dp.set(M,fp(dp.get(M)||null,r,s,o,c,g)),!0}return!1}function Mv(r){var s=qt(r.target);if(s!==null){var o=l(s);if(o!==null){if(s=o.tag,s===13){if(s=u(o),s!==null){r.blockedOn=s,z(r.priority,function(){if(o.tag===13){var c=bs();c=En(c);var g=_o(o,c);g!==null&&zs(g,o,c),sg(o,c)}});return}}else if(s===3&&o.stateNode.current.memoizedState.isDehydrated){r.blockedOn=o.tag===3?o.stateNode.containerInfo:null;return}}}r.blockedOn=null}function Lm(r){if(r.blockedOn!==null)return!1;for(var s=r.targetContainers;0<s.length;){var o=ig(r.nativeEvent);if(o===null){o=r.nativeEvent;var c=new o.constructor(o.type,o);Qt=c,o.target.dispatchEvent(c),Qt=null}else return s=On(o),s!==null&&vv(s),r.blockedOn=o,!1;s.shift()}return!0}function xv(r,s,o){Lm(r)&&o.delete(s)}function uC(){lg=!1,Il!==null&&Lm(Il)&&(Il=null),Ll!==null&&Lm(Ll)&&(Ll=null),zl!==null&&Lm(zl)&&(zl=null),cp.forEach(xv),dp.forEach(xv)}function zm(r,s){r.blockedOn===s&&(r.blockedOn=null,lg||(lg=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,uC)))}var Fm=null;function Tv(r){Fm!==r&&(Fm=r,e.unstable_scheduleCallback(e.unstable_NormalPriority,function(){Fm===r&&(Fm=null);for(var s=0;s<r.length;s+=3){var o=r[s],c=r[s+1],g=r[s+2];if(typeof c!="function"){if(og(c||o)===null)continue;break}var M=On(o);M!==null&&(r.splice(s,3),s-=3,Fu(M,{pending:!0,data:g,method:o.method,action:c},c,g))}}))}function hp(r){function s(he){return zm(he,r)}Il!==null&&zm(Il,r),Ll!==null&&zm(Ll,r),zl!==null&&zm(zl,r),cp.forEach(s),dp.forEach(s);for(var o=0;o<Fl.length;o++){var c=Fl[o];c.blockedOn===r&&(c.blockedOn=null)}for(;0<Fl.length&&(o=Fl[0],o.blockedOn===null);)Mv(o),o.blockedOn===null&&Fl.shift();if(o=(r.ownerDocument||r).$$reactFormReplay,o!=null)for(c=0;c<o.length;c+=3){var g=o[c],M=o[c+1],j=g[ue]||null;if(typeof M=="function")j||Tv(o);else if(j){var Y=null;if(M&&M.hasAttribute("formAction")){if(g=M,j=M[ue]||null)Y=j.formAction;else if(og(g)!==null)continue}else Y=j.action;typeof Y=="function"?o[c+1]=Y:(o.splice(c,3),c-=3),Tv(o)}}}function ug(r){this._internalRoot=r}Rm.prototype.render=ug.prototype.render=function(r){var s=this._internalRoot;if(s===null)throw Error(a(409));var o=s.current,c=bs();gv(o,c,r,s,null,null)},Rm.prototype.unmount=ug.prototype.unmount=function(){var r=this._internalRoot;if(r!==null){this._internalRoot=null;var s=r.containerInfo;gv(r.current,2,null,r,null,null),ic(),s[pe]=null}};function Rm(r){this._internalRoot=r}Rm.prototype.unstable_scheduleHydration=function(r){if(r){var s=Js();r={blockedOn:null,target:r,priority:s};for(var o=0;o<Fl.length&&s!==0&&s<Fl[o].priority;o++);Fl.splice(o,0,r),o===0&&Mv(r)}};var Ev=n.version;if(Ev!=="19.1.1")throw Error(a(527,Ev,"19.1.1"));te.findDOMNode=function(r){var s=r._reactInternals;if(s===void 0)throw typeof r.render=="function"?Error(a(188)):(r=Object.keys(r).join(","),Error(a(268,r)));return r=f(s),r=r!==null?h(r):null,r=r===null?null:r.stateNode,r};var cC={bundleType:0,version:"19.1.1",rendererPackageName:"react-dom",currentDispatcherRef:W,reconcilerVersion:"19.1.1"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Bm=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Bm.isDisabled&&Bm.supportsFiber)try{nt=Bm.inject(cC),ct=Bm}catch{}}return mp.createRoot=function(r,s){if(!i(r))throw Error(a(299));var o=!1,c="",g=Hu,M=fh,j=hh,Y=null;return s!=null&&(s.unstable_strictMode===!0&&(o=!0),s.identifierPrefix!==void 0&&(c=s.identifierPrefix),s.onUncaughtError!==void 0&&(g=s.onUncaughtError),s.onCaughtError!==void 0&&(M=s.onCaughtError),s.onRecoverableError!==void 0&&(j=s.onRecoverableError),s.unstable_transitionCallbacks!==void 0&&(Y=s.unstable_transitionCallbacks)),s=mv(r,1,!1,null,null,o,c,g,M,j,Y,null),r[pe]=s.current,O(r),new ug(s)},mp.hydrateRoot=function(r,s,o){if(!i(r))throw Error(a(299));var c=!1,g="",M=Hu,j=fh,Y=hh,he=null,$e=null;return o!=null&&(o.unstable_strictMode===!0&&(c=!0),o.identifierPrefix!==void 0&&(g=o.identifierPrefix),o.onUncaughtError!==void 0&&(M=o.onUncaughtError),o.onCaughtError!==void 0&&(j=o.onCaughtError),o.onRecoverableError!==void 0&&(Y=o.onRecoverableError),o.unstable_transitionCallbacks!==void 0&&(he=o.unstable_transitionCallbacks),o.formState!==void 0&&($e=o.formState)),s=mv(r,1,!0,s,o??null,c,g,M,j,Y,he,$e),s.context=_v(null),o=s.current,c=bs(),c=En(c),g=ti(c),g.callback=null,ni(o,g,c),o=c,s.current.lanes=o,Es(s,o),Ia(s),r[pe]=s.current,O(r),new Rm(s)},mp.version="19.1.1",mp}var Lv;function bC(){if(Lv)return fg.exports;Lv=1;function e(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(n){console.error(n)}}return e(),fg.exports=vC(),fg.exports}var wC=bC();/**
 * react-router v7.9.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */var zv="popstate";function MC(e={}){function n(a,i){let{pathname:l,search:u,hash:d}=a.location;return R0("",{pathname:l,search:u,hash:d},i.state&&i.state.usr||null,i.state&&i.state.key||"default")}function t(a,i){return typeof i=="string"?i:zp(i)}return TC(n,t,null,e)}function Ar(e,n){if(e===!1||e===null||typeof e>"u")throw new Error(n)}function eo(e,n){if(!e){typeof console<"u"&&console.warn(n);try{throw new Error(n)}catch{}}}function xC(){return Math.random().toString(36).substring(2,10)}function Fv(e,n){return{usr:e.state,key:e.key,idx:n}}function R0(e,n,t=null,a){return{pathname:typeof e=="string"?e:e.pathname,search:"",hash:"",...typeof n=="string"?uf(n):n,state:t,key:n&&n.key||a||xC()}}function zp({pathname:e="/",search:n="",hash:t=""}){return n&&n!=="?"&&(e+=n.charAt(0)==="?"?n:"?"+n),t&&t!=="#"&&(e+=t.charAt(0)==="#"?t:"#"+t),e}function uf(e){let n={};if(e){let t=e.indexOf("#");t>=0&&(n.hash=e.substring(t),e=e.substring(0,t));let a=e.indexOf("?");a>=0&&(n.search=e.substring(a),e=e.substring(0,a)),e&&(n.pathname=e)}return n}function TC(e,n,t,a={}){let{window:i=document.defaultView,v5Compat:l=!1}=a,u=i.history,d="POP",f=null,h=_();h==null&&(h=0,u.replaceState({...u.state,idx:h},""));function _(){return(u.state||{idx:null}).idx}function m(){d="POP";let L=_(),T=L==null?null:L-h;h=L,f&&f({action:d,location:x.location,delta:T})}function p(L,T){d="PUSH";let E=R0(x.location,L,T);h=_()+1;let I=Fv(E,h),P=x.createHref(E);try{u.pushState(I,"",P)}catch(S){if(S instanceof DOMException&&S.name==="DataCloneError")throw S;i.location.assign(P)}l&&f&&f({action:d,location:x.location,delta:1})}function y(L,T){d="REPLACE";let E=R0(x.location,L,T);h=_();let I=Fv(E,h),P=x.createHref(E);u.replaceState(I,"",P),l&&f&&f({action:d,location:x.location,delta:0})}function v(L){return EC(L)}let x={get action(){return d},get location(){return e(i,u)},listen(L){if(f)throw new Error("A history only accepts one active listener");return i.addEventListener(zv,m),f=L,()=>{i.removeEventListener(zv,m),f=null}},createHref(L){return n(i,L)},createURL:v,encodeLocation(L){let T=v(L);return{pathname:T.pathname,search:T.search,hash:T.hash}},push:p,replace:y,go(L){return u.go(L)}};return x}function EC(e,n=!1){let t="http://localhost";typeof window<"u"&&(t=window.location.origin!=="null"?window.location.origin:window.location.href),Ar(t,"No window.location.(origin|href) available to create URL");let a=typeof e=="string"?e:zp(e);return a=a.replace(/ $/,"%20"),!n&&a.startsWith("//")&&(a=t+a),new URL(a,t)}function J2(e,n,t="/"){return SC(e,n,t,!1)}function SC(e,n,t,a){let i=typeof n=="string"?uf(n):n,l=Wo(i.pathname||"/",t);if(l==null)return null;let u=e1(e);CC(u);let d=null;for(let f=0;d==null&&f<u.length;++f){let h=RC(l);d=zC(u[f],h,a)}return d}function e1(e,n=[],t=[],a="",i=!1){let l=(u,d,f=i,h)=>{let _={relativePath:h===void 0?u.path||"":h,caseSensitive:u.caseSensitive===!0,childrenIndex:d,route:u};if(_.relativePath.startsWith("/")){if(!_.relativePath.startsWith(a)&&f)return;Ar(_.relativePath.startsWith(a),`Absolute route path "${_.relativePath}" nested under path "${a}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),_.relativePath=_.relativePath.slice(a.length)}let m=Go([a,_.relativePath]),p=t.concat(_);u.children&&u.children.length>0&&(Ar(u.index!==!0,`Index routes must not have child routes. Please remove all child routes from route path "${m}".`),e1(u.children,n,p,m,f)),!(u.path==null&&!u.index)&&n.push({path:m,score:IC(m,u.index),routesMeta:p})};return e.forEach((u,d)=>{if(u.path===""||!u.path?.includes("?"))l(u,d);else for(let f of t1(u.path))l(u,d,!0,f)}),n}function t1(e){let n=e.split("/");if(n.length===0)return[];let[t,...a]=n,i=t.endsWith("?"),l=t.replace(/\?$/,"");if(a.length===0)return i?[l,""]:[l];let u=t1(a.join("/")),d=[];return d.push(...u.map(f=>f===""?l:[l,f].join("/"))),i&&d.push(...u),d.map(f=>e.startsWith("/")&&f===""?"/":f)}function CC(e){e.sort((n,t)=>n.score!==t.score?t.score-n.score:LC(n.routesMeta.map(a=>a.childrenIndex),t.routesMeta.map(a=>a.childrenIndex)))}var PC=/^:[\w-]+$/,AC=3,kC=2,OC=1,$C=10,DC=-2,Rv=e=>e==="*";function IC(e,n){let t=e.split("/"),a=t.length;return t.some(Rv)&&(a+=DC),n&&(a+=kC),t.filter(i=>!Rv(i)).reduce((i,l)=>i+(PC.test(l)?AC:l===""?OC:$C),a)}function LC(e,n){return e.length===n.length&&e.slice(0,-1).every((a,i)=>a===n[i])?e[e.length-1]-n[n.length-1]:0}function zC(e,n,t=!1){let{routesMeta:a}=e,i={},l="/",u=[];for(let d=0;d<a.length;++d){let f=a[d],h=d===a.length-1,_=l==="/"?n:n.slice(l.length)||"/",m=y_({path:f.relativePath,caseSensitive:f.caseSensitive,end:h},_),p=f.route;if(!m&&h&&t&&!a[a.length-1].route.index&&(m=y_({path:f.relativePath,caseSensitive:f.caseSensitive,end:!1},_)),!m)return null;Object.assign(i,m.params),u.push({params:i,pathname:Go([l,m.pathname]),pathnameBase:UC(Go([l,m.pathnameBase])),route:p}),m.pathnameBase!=="/"&&(l=Go([l,m.pathnameBase]))}return u}function y_(e,n){typeof e=="string"&&(e={path:e,caseSensitive:!1,end:!0});let[t,a]=FC(e.path,e.caseSensitive,e.end),i=n.match(t);if(!i)return null;let l=i[0],u=l.replace(/(.)\/+$/,"$1"),d=i.slice(1);return{params:a.reduce((h,{paramName:_,isOptional:m},p)=>{if(_==="*"){let v=d[p]||"";u=l.slice(0,l.length-v.length).replace(/(.)\/+$/,"$1")}const y=d[p];return m&&!y?h[_]=void 0:h[_]=(y||"").replace(/%2F/g,"/"),h},{}),pathname:l,pathnameBase:u,pattern:e}}function FC(e,n=!1,t=!0){eo(e==="*"||!e.endsWith("*")||e.endsWith("/*"),`Route path "${e}" will be treated as if it were "${e.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/,"/*")}".`);let a=[],i="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(u,d,f)=>(a.push({paramName:d,isOptional:f!=null}),f?"/?([^\\/]+)?":"/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g,"(/$1)?$2");return e.endsWith("*")?(a.push({paramName:"*"}),i+=e==="*"||e==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):t?i+="\\/*$":e!==""&&e!=="/"&&(i+="(?:(?=\\/|$))"),[new RegExp(i,n?void 0:"i"),a]}function RC(e){try{return e.split("/").map(n=>decodeURIComponent(n).replace(/\//g,"%2F")).join("/")}catch(n){return eo(!1,`The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${n}).`),e}}function Wo(e,n){if(n==="/")return e;if(!e.toLowerCase().startsWith(n.toLowerCase()))return null;let t=n.endsWith("/")?n.length-1:n.length,a=e.charAt(t);return a&&a!=="/"?null:e.slice(t)||"/"}function BC(e,n="/"){let{pathname:t,search:a="",hash:i=""}=typeof e=="string"?uf(e):e;return{pathname:t?t.startsWith("/")?t:jC(t,n):n,search:VC(a),hash:GC(i)}}function jC(e,n){let t=n.replace(/\/+$/,"").split("/");return e.split("/").forEach(i=>{i===".."?t.length>1&&t.pop():i!=="."&&t.push(i)}),t.length>1?t.join("/"):"/"}function _g(e,n,t,a){return`Cannot include a '${e}' character in a manually specified \`to.${n}\` field [${JSON.stringify(a)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function NC(e){return e.filter((n,t)=>t===0||n.route.path&&n.route.path.length>0)}function n1(e){let n=NC(e);return n.map((t,a)=>a===n.length-1?t.pathname:t.pathnameBase)}function r1(e,n,t,a=!1){let i;typeof e=="string"?i=uf(e):(i={...e},Ar(!i.pathname||!i.pathname.includes("?"),_g("?","pathname","search",i)),Ar(!i.pathname||!i.pathname.includes("#"),_g("#","pathname","hash",i)),Ar(!i.search||!i.search.includes("#"),_g("#","search","hash",i)));let l=e===""||i.pathname==="",u=l?"/":i.pathname,d;if(u==null)d=t;else{let m=n.length-1;if(!a&&u.startsWith("..")){let p=u.split("/");for(;p[0]==="..";)p.shift(),m-=1;i.pathname=p.join("/")}d=m>=0?n[m]:"/"}let f=BC(i,d),h=u&&u!=="/"&&u.endsWith("/"),_=(l||u===".")&&t.endsWith("/");return!f.pathname.endsWith("/")&&(h||_)&&(f.pathname+="/"),f}var Go=e=>e.join("/").replace(/\/\/+/g,"/"),UC=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),VC=e=>!e||e==="?"?"":e.startsWith("?")?e:"?"+e,GC=e=>!e||e==="#"?"":e.startsWith("#")?e:"#"+e;function WC(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.internal=="boolean"&&"data"in e}var s1=["POST","PUT","PATCH","DELETE"];new Set(s1);var HC=["GET",...s1];new Set(HC);var cf=Ce.createContext(null);cf.displayName="DataRouter";var k_=Ce.createContext(null);k_.displayName="DataRouterState";Ce.createContext(!1);var a1=Ce.createContext({isTransitioning:!1});a1.displayName="ViewTransition";var KC=Ce.createContext(new Map);KC.displayName="Fetchers";var qC=Ce.createContext(null);qC.displayName="Await";var to=Ce.createContext(null);to.displayName="Navigation";var Np=Ce.createContext(null);Np.displayName="Location";var Ko=Ce.createContext({outlet:null,matches:[],isDataRoute:!1});Ko.displayName="Route";var vy=Ce.createContext(null);vy.displayName="RouteError";function QC(e,{relative:n}={}){Ar(Up(),"useHref() may be used only in the context of a <Router> component.");let{basename:t,navigator:a}=Ce.useContext(to),{hash:i,pathname:l,search:u}=Vp(e,{relative:n}),d=l;return t!=="/"&&(d=l==="/"?t:Go([t,l])),a.createHref({pathname:d,search:u,hash:i})}function Up(){return Ce.useContext(Np)!=null}function Tc(){return Ar(Up(),"useLocation() may be used only in the context of a <Router> component."),Ce.useContext(Np).location}var i1="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function o1(e){Ce.useContext(to).static||Ce.useLayoutEffect(e)}function O_(){let{isDataRoute:e}=Ce.useContext(Ko);return e?lP():XC()}function XC(){Ar(Up(),"useNavigate() may be used only in the context of a <Router> component.");let e=Ce.useContext(cf),{basename:n,navigator:t}=Ce.useContext(to),{matches:a}=Ce.useContext(Ko),{pathname:i}=Tc(),l=JSON.stringify(n1(a)),u=Ce.useRef(!1);return o1(()=>{u.current=!0}),Ce.useCallback((f,h={})=>{if(eo(u.current,i1),!u.current)return;if(typeof f=="number"){t.go(f);return}let _=r1(f,JSON.parse(l),i,h.relative==="path");e==null&&n!=="/"&&(_.pathname=_.pathname==="/"?n:Go([n,_.pathname])),(h.replace?t.replace:t.push)(_,h.state,h)},[n,t,l,i,e])}Ce.createContext(null);function Vp(e,{relative:n}={}){let{matches:t}=Ce.useContext(Ko),{pathname:a}=Tc(),i=JSON.stringify(n1(t));return Ce.useMemo(()=>r1(e,JSON.parse(i),a,n==="path"),[e,i,a,n])}function YC(e,n){return l1(e,n)}function l1(e,n,t,a,i){Ar(Up(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:l}=Ce.useContext(to),{matches:u}=Ce.useContext(Ko),d=u[u.length-1],f=d?d.params:{},h=d?d.pathname:"/",_=d?d.pathnameBase:"/",m=d&&d.route;{let E=m&&m.path||"";u1(h,!m||E.endsWith("*")||E.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${h}" (under <Route path="${E}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${E}"> to <Route path="${E==="/"?"*":`${E}/*`}">.`)}let p=Tc(),y;if(n){let E=typeof n=="string"?uf(n):n;Ar(_==="/"||E.pathname?.startsWith(_),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${_}" but pathname "${E.pathname}" was given in the \`location\` prop.`),y=E}else y=p;let v=y.pathname||"/",x=v;if(_!=="/"){let E=_.replace(/^\//,"").split("/");x="/"+v.replace(/^\//,"").split("/").slice(E.length).join("/")}let L=J2(e,{pathname:x});eo(m||L!=null,`No routes matched location "${y.pathname}${y.search}${y.hash}" `),eo(L==null||L[L.length-1].route.element!==void 0||L[L.length-1].route.Component!==void 0||L[L.length-1].route.lazy!==void 0,`Matched leaf route at location "${y.pathname}${y.search}${y.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let T=nP(L&&L.map(E=>Object.assign({},E,{params:Object.assign({},f,E.params),pathname:Go([_,l.encodeLocation?l.encodeLocation(E.pathname.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:E.pathname]),pathnameBase:E.pathnameBase==="/"?_:Go([_,l.encodeLocation?l.encodeLocation(E.pathnameBase.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:E.pathnameBase])})),u,t,a,i);return n&&T?Ce.createElement(Np.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",...y},navigationType:"POP"}},T):T}function ZC(){let e=oP(),n=WC(e)?`${e.status} ${e.statusText}`:e instanceof Error?e.message:JSON.stringify(e),t=e instanceof Error?e.stack:null,a="rgba(200,200,200, 0.5)",i={padding:"0.5rem",backgroundColor:a},l={padding:"2px 4px",backgroundColor:a},u=null;return console.error("Error handled by React Router default ErrorBoundary:",e),u=Ce.createElement(Ce.Fragment,null,Ce.createElement("p",null," Hey developer "),Ce.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",Ce.createElement("code",{style:l},"ErrorBoundary")," or"," ",Ce.createElement("code",{style:l},"errorElement")," prop on your route.")),Ce.createElement(Ce.Fragment,null,Ce.createElement("h2",null,"Unexpected Application Error!"),Ce.createElement("h3",{style:{fontStyle:"italic"}},n),t?Ce.createElement("pre",{style:i},t):null,u)}var JC=Ce.createElement(ZC,null),eP=class extends Ce.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,n){return n.location!==e.location||n.revalidation!=="idle"&&e.revalidation==="idle"?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:e.error!==void 0?e.error:n.error,location:n.location,revalidation:e.revalidation||n.revalidation}}componentDidCatch(e,n){this.props.unstable_onError?this.props.unstable_onError(e,n):console.error("React Router caught the following error during render",e)}render(){return this.state.error!==void 0?Ce.createElement(Ko.Provider,{value:this.props.routeContext},Ce.createElement(vy.Provider,{value:this.state.error,children:this.props.component})):this.props.children}};function tP({routeContext:e,match:n,children:t}){let a=Ce.useContext(cf);return a&&a.static&&a.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=n.route.id),Ce.createElement(Ko.Provider,{value:e},t)}function nP(e,n=[],t=null,a=null,i=null){if(e==null){if(!t)return null;if(t.errors)e=t.matches;else if(n.length===0&&!t.initialized&&t.matches.length>0)e=t.matches;else return null}let l=e,u=t?.errors;if(u!=null){let h=l.findIndex(_=>_.route.id&&u?.[_.route.id]!==void 0);Ar(h>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(u).join(",")}`),l=l.slice(0,Math.min(l.length,h+1))}let d=!1,f=-1;if(t)for(let h=0;h<l.length;h++){let _=l[h];if((_.route.HydrateFallback||_.route.hydrateFallbackElement)&&(f=h),_.route.id){let{loaderData:m,errors:p}=t,y=_.route.loader&&!m.hasOwnProperty(_.route.id)&&(!p||p[_.route.id]===void 0);if(_.route.lazy||y){d=!0,f>=0?l=l.slice(0,f+1):l=[l[0]];break}}}return l.reduceRight((h,_,m)=>{let p,y=!1,v=null,x=null;t&&(p=u&&_.route.id?u[_.route.id]:void 0,v=_.route.errorElement||JC,d&&(f<0&&m===0?(u1("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),y=!0,x=null):f===m&&(y=!0,x=_.route.hydrateFallbackElement||null)));let L=n.concat(l.slice(0,m+1)),T=()=>{let E;return p?E=v:y?E=x:_.route.Component?E=Ce.createElement(_.route.Component,null):_.route.element?E=_.route.element:E=h,Ce.createElement(tP,{match:_,routeContext:{outlet:h,matches:L,isDataRoute:t!=null},children:E})};return t&&(_.route.ErrorBoundary||_.route.errorElement||m===0)?Ce.createElement(eP,{location:t.location,revalidation:t.revalidation,component:v,error:p,children:T(),routeContext:{outlet:null,matches:L,isDataRoute:!0},unstable_onError:a}):T()},null)}function by(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function rP(e){let n=Ce.useContext(cf);return Ar(n,by(e)),n}function sP(e){let n=Ce.useContext(k_);return Ar(n,by(e)),n}function aP(e){let n=Ce.useContext(Ko);return Ar(n,by(e)),n}function wy(e){let n=aP(e),t=n.matches[n.matches.length-1];return Ar(t.route.id,`${e} can only be used on routes that contain a unique "id"`),t.route.id}function iP(){return wy("useRouteId")}function oP(){let e=Ce.useContext(vy),n=sP("useRouteError"),t=wy("useRouteError");return e!==void 0?e:n.errors?.[t]}function lP(){let{router:e}=rP("useNavigate"),n=wy("useNavigate"),t=Ce.useRef(!1);return o1(()=>{t.current=!0}),Ce.useCallback(async(i,l={})=>{eo(t.current,i1),t.current&&(typeof i=="number"?e.navigate(i):await e.navigate(i,{fromRouteId:n,...l}))},[e,n])}var Bv={};function u1(e,n,t){!n&&!Bv[e]&&(Bv[e]=!0,eo(!1,t))}Ce.memo(uP);function uP({routes:e,future:n,state:t,unstable_onError:a}){return l1(e,void 0,t,a,n)}function B0(e){Ar(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function cP({basename:e="/",children:n=null,location:t,navigationType:a="POP",navigator:i,static:l=!1}){Ar(!Up(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let u=e.replace(/^\/*/,"/"),d=Ce.useMemo(()=>({basename:u,navigator:i,static:l,future:{}}),[u,i,l]);typeof t=="string"&&(t=uf(t));let{pathname:f="/",search:h="",hash:_="",state:m=null,key:p="default"}=t,y=Ce.useMemo(()=>{let v=Wo(f,u);return v==null?null:{location:{pathname:v,search:h,hash:_,state:m,key:p},navigationType:a}},[u,f,h,_,m,p,a]);return eo(y!=null,`<Router basename="${u}"> is not able to match the URL "${f}${h}${_}" because it does not start with the basename, so the <Router> won't render anything.`),y==null?null:Ce.createElement(to.Provider,{value:d},Ce.createElement(Np.Provider,{children:n,value:y}))}function dP({children:e,location:n}){return YC(j0(e),n)}function j0(e,n=[]){let t=[];return Ce.Children.forEach(e,(a,i)=>{if(!Ce.isValidElement(a))return;let l=[...n,i];if(a.type===Ce.Fragment){t.push.apply(t,j0(a.props.children,l));return}Ar(a.type===B0,`[${typeof a.type=="string"?a.type:a.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),Ar(!a.props.index||!a.props.children,"An index route cannot have child routes.");let u={id:a.props.id||l.join("-"),caseSensitive:a.props.caseSensitive,element:a.props.element,Component:a.props.Component,index:a.props.index,path:a.props.path,middleware:a.props.middleware,loader:a.props.loader,action:a.props.action,hydrateFallbackElement:a.props.hydrateFallbackElement,HydrateFallback:a.props.HydrateFallback,errorElement:a.props.errorElement,ErrorBoundary:a.props.ErrorBoundary,hasErrorBoundary:a.props.hasErrorBoundary===!0||a.props.ErrorBoundary!=null||a.props.errorElement!=null,shouldRevalidate:a.props.shouldRevalidate,handle:a.props.handle,lazy:a.props.lazy};a.props.children&&(u.children=j0(a.props.children,l)),t.push(u)}),t}var l_="get",u_="application/x-www-form-urlencoded";function $_(e){return e!=null&&typeof e.tagName=="string"}function fP(e){return $_(e)&&e.tagName.toLowerCase()==="button"}function hP(e){return $_(e)&&e.tagName.toLowerCase()==="form"}function pP(e){return $_(e)&&e.tagName.toLowerCase()==="input"}function mP(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}function _P(e,n){return e.button===0&&(!n||n==="_self")&&!mP(e)}var jm=null;function gP(){if(jm===null)try{new FormData(document.createElement("form"),0),jm=!1}catch{jm=!0}return jm}var yP=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function gg(e){return e!=null&&!yP.has(e)?(eo(!1,`"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${u_}"`),null):e}function vP(e,n){let t,a,i,l,u;if(hP(e)){let d=e.getAttribute("action");a=d?Wo(d,n):null,t=e.getAttribute("method")||l_,i=gg(e.getAttribute("enctype"))||u_,l=new FormData(e)}else if(fP(e)||pP(e)&&(e.type==="submit"||e.type==="image")){let d=e.form;if(d==null)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let f=e.getAttribute("formaction")||d.getAttribute("action");if(a=f?Wo(f,n):null,t=e.getAttribute("formmethod")||d.getAttribute("method")||l_,i=gg(e.getAttribute("formenctype"))||gg(d.getAttribute("enctype"))||u_,l=new FormData(d,e),!gP()){let{name:h,type:_,value:m}=e;if(_==="image"){let p=h?`${h}.`:"";l.append(`${p}x`,"0"),l.append(`${p}y`,"0")}else h&&l.append(h,m)}}else{if($_(e))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');t=l_,a=null,i=u_,u=e}return l&&i==="text/plain"&&(u=l,l=void 0),{action:a,method:t.toLowerCase(),encType:i,formData:l,body:u}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");function My(e,n){if(e===!1||e===null||typeof e>"u")throw new Error(n)}function bP(e,n,t){let a=typeof e=="string"?new URL(e,typeof window>"u"?"server://singlefetch/":window.location.origin):e;return a.pathname==="/"?a.pathname=`_root.${t}`:n&&Wo(a.pathname,n)==="/"?a.pathname=`${n.replace(/\/$/,"")}/_root.${t}`:a.pathname=`${a.pathname.replace(/\/$/,"")}.${t}`,a}async function wP(e,n){if(e.id in n)return n[e.id];try{let t=await import(e.module);return n[e.id]=t,t}catch(t){return console.error(`Error loading route module \`${e.module}\`, reloading page...`),console.error(t),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise(()=>{})}}function MP(e){return e==null?!1:e.href==null?e.rel==="preload"&&typeof e.imageSrcSet=="string"&&typeof e.imageSizes=="string":typeof e.rel=="string"&&typeof e.href=="string"}async function xP(e,n,t){let a=await Promise.all(e.map(async i=>{let l=n.routes[i.route.id];if(l){let u=await wP(l,t);return u.links?u.links():[]}return[]}));return CP(a.flat(1).filter(MP).filter(i=>i.rel==="stylesheet"||i.rel==="preload").map(i=>i.rel==="stylesheet"?{...i,rel:"prefetch",as:"style"}:{...i,rel:"prefetch"}))}function jv(e,n,t,a,i,l){let u=(f,h)=>t[h]?f.route.id!==t[h].route.id:!0,d=(f,h)=>t[h].pathname!==f.pathname||t[h].route.path?.endsWith("*")&&t[h].params["*"]!==f.params["*"];return l==="assets"?n.filter((f,h)=>u(f,h)||d(f,h)):l==="data"?n.filter((f,h)=>{let _=a.routes[f.route.id];if(!_||!_.hasLoader)return!1;if(u(f,h)||d(f,h))return!0;if(f.route.shouldRevalidate){let m=f.route.shouldRevalidate({currentUrl:new URL(i.pathname+i.search+i.hash,window.origin),currentParams:t[0]?.params||{},nextUrl:new URL(e,window.origin),nextParams:f.params,defaultShouldRevalidate:!0});if(typeof m=="boolean")return m}return!0}):[]}function TP(e,n,{includeHydrateFallback:t}={}){return EP(e.map(a=>{let i=n.routes[a.route.id];if(!i)return[];let l=[i.module];return i.clientActionModule&&(l=l.concat(i.clientActionModule)),i.clientLoaderModule&&(l=l.concat(i.clientLoaderModule)),t&&i.hydrateFallbackModule&&(l=l.concat(i.hydrateFallbackModule)),i.imports&&(l=l.concat(i.imports)),l}).flat(1))}function EP(e){return[...new Set(e)]}function SP(e){let n={},t=Object.keys(e).sort();for(let a of t)n[a]=e[a];return n}function CP(e,n){let t=new Set;return new Set(n),e.reduce((a,i)=>{let l=JSON.stringify(SP(i));return t.has(l)||(t.add(l),a.push({key:l,link:i})),a},[])}function c1(){let e=Ce.useContext(cf);return My(e,"You must render this element inside a <DataRouterContext.Provider> element"),e}function PP(){let e=Ce.useContext(k_);return My(e,"You must render this element inside a <DataRouterStateContext.Provider> element"),e}var xy=Ce.createContext(void 0);xy.displayName="FrameworkContext";function d1(){let e=Ce.useContext(xy);return My(e,"You must render this element inside a <HydratedRouter> element"),e}function AP(e,n){let t=Ce.useContext(xy),[a,i]=Ce.useState(!1),[l,u]=Ce.useState(!1),{onFocus:d,onBlur:f,onMouseEnter:h,onMouseLeave:_,onTouchStart:m}=n,p=Ce.useRef(null);Ce.useEffect(()=>{if(e==="render"&&u(!0),e==="viewport"){let x=T=>{T.forEach(E=>{u(E.isIntersecting)})},L=new IntersectionObserver(x,{threshold:.5});return p.current&&L.observe(p.current),()=>{L.disconnect()}}},[e]),Ce.useEffect(()=>{if(a){let x=setTimeout(()=>{u(!0)},100);return()=>{clearTimeout(x)}}},[a]);let y=()=>{i(!0)},v=()=>{i(!1),u(!1)};return t?e!=="intent"?[l,p,{}]:[l,p,{onFocus:_p(d,y),onBlur:_p(f,v),onMouseEnter:_p(h,y),onMouseLeave:_p(_,v),onTouchStart:_p(m,y)}]:[!1,p,{}]}function _p(e,n){return t=>{e&&e(t),t.defaultPrevented||n(t)}}function kP({page:e,...n}){let{router:t}=c1(),a=Ce.useMemo(()=>J2(t.routes,e,t.basename),[t.routes,e,t.basename]);return a?Ce.createElement($P,{page:e,matches:a,...n}):null}function OP(e){let{manifest:n,routeModules:t}=d1(),[a,i]=Ce.useState([]);return Ce.useEffect(()=>{let l=!1;return xP(e,n,t).then(u=>{l||i(u)}),()=>{l=!0}},[e,n,t]),a}function $P({page:e,matches:n,...t}){let a=Tc(),{manifest:i,routeModules:l}=d1(),{basename:u}=c1(),{loaderData:d,matches:f}=PP(),h=Ce.useMemo(()=>jv(e,n,f,i,a,"data"),[e,n,f,i,a]),_=Ce.useMemo(()=>jv(e,n,f,i,a,"assets"),[e,n,f,i,a]),m=Ce.useMemo(()=>{if(e===a.pathname+a.search+a.hash)return[];let v=new Set,x=!1;if(n.forEach(T=>{let E=i.routes[T.route.id];!E||!E.hasLoader||(!h.some(I=>I.route.id===T.route.id)&&T.route.id in d&&l[T.route.id]?.shouldRevalidate||E.hasClientLoader?x=!0:v.add(T.route.id))}),v.size===0)return[];let L=bP(e,u,"data");return x&&v.size>0&&L.searchParams.set("_routes",n.filter(T=>v.has(T.route.id)).map(T=>T.route.id).join(",")),[L.pathname+L.search]},[u,d,a,i,h,n,e,l]),p=Ce.useMemo(()=>TP(_,i),[_,i]),y=OP(_);return Ce.createElement(Ce.Fragment,null,m.map(v=>Ce.createElement("link",{key:v,rel:"prefetch",as:"fetch",href:v,...t})),p.map(v=>Ce.createElement("link",{key:v,rel:"modulepreload",href:v,...t})),y.map(({key:v,link:x})=>Ce.createElement("link",{key:v,nonce:t.nonce,...x})))}function DP(...e){return n=>{e.forEach(t=>{typeof t=="function"?t(n):t!=null&&(t.current=n)})}}var f1=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";try{f1&&(window.__reactRouterVersion="7.9.3")}catch{}function IP({basename:e,children:n,window:t}){let a=Ce.useRef();a.current==null&&(a.current=MC({window:t,v5Compat:!0}));let i=a.current,[l,u]=Ce.useState({action:i.action,location:i.location}),d=Ce.useCallback(f=>{Ce.startTransition(()=>u(f))},[u]);return Ce.useLayoutEffect(()=>i.listen(d),[i,d]),Ce.createElement(cP,{basename:e,children:n,location:l.location,navigationType:l.action,navigator:i})}var h1=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Ty=Ce.forwardRef(function({onClick:n,discover:t="render",prefetch:a="none",relative:i,reloadDocument:l,replace:u,state:d,target:f,to:h,preventScrollReset:_,viewTransition:m,...p},y){let{basename:v}=Ce.useContext(to),x=typeof h=="string"&&h1.test(h),L,T=!1;if(typeof h=="string"&&x&&(L=h,f1))try{let V=new URL(window.location.href),U=h.startsWith("//")?new URL(V.protocol+h):new URL(h),ne=Wo(U.pathname,v);U.origin===V.origin&&ne!=null?h=ne+U.search+U.hash:T=!0}catch{eo(!1,`<Link to="${h}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}let E=QC(h,{relative:i}),[I,P,S]=AP(a,p),k=RP(h,{replace:u,state:d,target:f,preventScrollReset:_,relative:i,viewTransition:m});function C(V){n&&n(V),V.defaultPrevented||k(V)}let D=Ce.createElement("a",{...p,...S,href:L||E,onClick:T||l?n:C,ref:DP(y,P),target:f,"data-discover":!x&&t==="render"?"true":void 0});return I&&!x?Ce.createElement(Ce.Fragment,null,D,Ce.createElement(kP,{page:E})):D});Ty.displayName="Link";var LP=Ce.forwardRef(function({"aria-current":n="page",caseSensitive:t=!1,className:a="",end:i=!1,style:l,to:u,viewTransition:d,children:f,...h},_){let m=Vp(u,{relative:h.relative}),p=Tc(),y=Ce.useContext(k_),{navigator:v,basename:x}=Ce.useContext(to),L=y!=null&&VP(m)&&d===!0,T=v.encodeLocation?v.encodeLocation(m).pathname:m.pathname,E=p.pathname,I=y&&y.navigation&&y.navigation.location?y.navigation.location.pathname:null;t||(E=E.toLowerCase(),I=I?I.toLowerCase():null,T=T.toLowerCase()),I&&x&&(I=Wo(I,x)||I);const P=T!=="/"&&T.endsWith("/")?T.length-1:T.length;let S=E===T||!i&&E.startsWith(T)&&E.charAt(P)==="/",k=I!=null&&(I===T||!i&&I.startsWith(T)&&I.charAt(T.length)==="/"),C={isActive:S,isPending:k,isTransitioning:L},D=S?n:void 0,V;typeof a=="function"?V=a(C):V=[a,S?"active":null,k?"pending":null,L?"transitioning":null].filter(Boolean).join(" ");let U=typeof l=="function"?l(C):l;return Ce.createElement(Ty,{...h,"aria-current":D,className:V,ref:_,style:U,to:u,viewTransition:d},typeof f=="function"?f(C):f)});LP.displayName="NavLink";var zP=Ce.forwardRef(({discover:e="render",fetcherKey:n,navigate:t,reloadDocument:a,replace:i,state:l,method:u=l_,action:d,onSubmit:f,relative:h,preventScrollReset:_,viewTransition:m,...p},y)=>{let v=NP(),x=UP(d,{relative:h}),L=u.toLowerCase()==="get"?"get":"post",T=typeof d=="string"&&h1.test(d),E=I=>{if(f&&f(I),I.defaultPrevented)return;I.preventDefault();let P=I.nativeEvent.submitter,S=P?.getAttribute("formmethod")||u;v(P||I.currentTarget,{fetcherKey:n,method:S,navigate:t,replace:i,state:l,relative:h,preventScrollReset:_,viewTransition:m})};return Ce.createElement("form",{ref:y,method:L,action:x,onSubmit:a?f:E,...p,"data-discover":!T&&e==="render"?"true":void 0})});zP.displayName="Form";function FP(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function p1(e){let n=Ce.useContext(cf);return Ar(n,FP(e)),n}function RP(e,{target:n,replace:t,state:a,preventScrollReset:i,relative:l,viewTransition:u}={}){let d=O_(),f=Tc(),h=Vp(e,{relative:l});return Ce.useCallback(_=>{if(_P(_,n)){_.preventDefault();let m=t!==void 0?t:zp(f)===zp(h);d(e,{replace:m,state:a,preventScrollReset:i,relative:l,viewTransition:u})}},[f,d,h,t,a,n,e,i,l,u])}var BP=0,jP=()=>`__${String(++BP)}__`;function NP(){let{router:e}=p1("useSubmit"),{basename:n}=Ce.useContext(to),t=iP();return Ce.useCallback(async(a,i={})=>{let{action:l,method:u,encType:d,formData:f,body:h}=vP(a,n);if(i.navigate===!1){let _=i.fetcherKey||jP();await e.fetch(_,t,i.action||l,{preventScrollReset:i.preventScrollReset,formData:f,body:h,formMethod:i.method||u,formEncType:i.encType||d,flushSync:i.flushSync})}else await e.navigate(i.action||l,{preventScrollReset:i.preventScrollReset,formData:f,body:h,formMethod:i.method||u,formEncType:i.encType||d,replace:i.replace,state:i.state,fromRouteId:t,flushSync:i.flushSync,viewTransition:i.viewTransition})},[e,n,t])}function UP(e,{relative:n}={}){let{basename:t}=Ce.useContext(to),a=Ce.useContext(Ko);Ar(a,"useFormAction must be used inside a RouteContext");let[i]=a.matches.slice(-1),l={...Vp(e||".",{relative:n})},u=Tc();if(e==null){l.search=u.search;let d=new URLSearchParams(l.search),f=d.getAll("index");if(f.some(_=>_==="")){d.delete("index"),f.filter(m=>m).forEach(m=>d.append("index",m));let _=d.toString();l.search=_?`?${_}`:""}}return(!e||e===".")&&i.route.index&&(l.search=l.search?l.search.replace(/^\?/,"?index&"):"?index"),t!=="/"&&(l.pathname=l.pathname==="/"?t:Go([t,l.pathname])),zp(l)}function VP(e,{relative:n}={}){let t=Ce.useContext(a1);Ar(t!=null,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:a}=p1("useViewTransitionState"),i=Vp(e,{relative:n});if(!t.isTransitioning)return!1;let l=Wo(t.currentLocation.pathname,a)||t.currentLocation.pathname,u=Wo(t.nextLocation.pathname,a)||t.nextLocation.pathname;return y_(i.pathname,u)!=null||y_(i.pathname,l)!=null}var GP=Z2();const WP="/BG-REMOVAL/assets/logo-B9MEDlPA.svg",HP="data:image/svg+xml,%3csvg%20width='18'%20height='16'%20viewBox='0%200%2018%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M15.5%208L1%208'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M10%2015L17%208L10%200.999999'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e",KP="/BG-REMOVAL/assets/header_img-mdrOD-tk.png",qP="data:image/svg+xml,%3csvg%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20width='44'%20height='44'%20rx='11'%20fill='url(%23paint0_linear_6505_476)'/%3e%3crect%20x='12'%20y='9'%20width='21'%20height='3.5'%20rx='1.75'%20fill='white'/%3e%3crect%20x='17.045'%20y='16'%20width='18.8888'%20height='3.14813'%20rx='1.57407'%20transform='rotate(47.0582%2017.045%2016)'%20fill='white'/%3e%3crect%20x='14'%20y='29.8926'%20width='18.8888'%20height='3.14813'%20rx='1.57407'%20transform='rotate(-42.9418%2014%2029.8926)'%20fill='white'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_6505_476'%20x1='22'%20y1='0'%20x2='22'%20y2='44'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%237F48FD'/%3e%3cstop%20offset='1'%20stop-color='%23C448F8'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e",QP="data:image/svg+xml,%3csvg%20width='29'%20height='29'%20viewBox='0%200%2029%2029'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M15.3232%200.362753C15.1118%200.131645%2014.8132%200%2014.5%200C14.1868%200%2013.8882%200.131645%2013.6769%200.362753L7.72812%206.86916C7.31246%207.32379%207.34404%208.02931%207.79867%208.44498C8.25332%208.86064%208.95882%208.82906%209.37449%208.37443L13.3846%203.98832V20.4487C13.3846%2021.0647%2013.884%2021.5641%2014.5%2021.5641C15.116%2021.5641%2015.6154%2021.0647%2015.6154%2020.4487V3.98832L19.6256%208.37443C20.0413%208.82906%2020.7468%208.86064%2021.2014%208.44498C21.656%208.02931%2021.6876%207.32379%2021.2719%206.86916L15.3232%200.362753Z'%20fill='white'/%3e%3cpath%20d='M2.23077%2018.9611C2.23077%2018.3451%201.7314%2017.8457%201.11539%2017.8457C0.499381%2017.8457%207.79212e-07%2018.3451%207.79212e-07%2018.9611V19.0427C-2.89644e-05%2021.0766%20-5.88145e-05%2022.7159%200.173287%2024.0053C0.353265%2025.3439%200.738281%2026.4709%201.63344%2027.366C2.52861%2028.2613%203.6557%2028.6463%204.99432%2028.8263C6.28366%2028.9995%207.92301%2028.9995%209.95686%2028.9995H19.0432C21.0771%2028.9995%2022.7164%2028.9995%2024.0058%2028.8263C25.3444%2028.6463%2026.4713%2028.2613%2027.3666%2027.366C28.2618%2026.4709%2028.6468%2025.3439%2028.8267%2024.0053C29%2022.7159%2029%2021.0766%2029%2019.0427V18.9611C29%2018.3451%2028.5006%2017.8457%2027.8846%2017.8457C27.2686%2017.8457%2026.7692%2018.3451%2026.7692%2018.9611C26.7692%2021.0958%2026.7669%2022.5846%2026.6159%2023.708C26.4691%2024.7993%2026.2008%2025.3771%2025.7892%2025.7887C25.3775%2026.2004%2024.7998%2026.4687%2023.7085%2026.6155C22.5851%2026.7664%2021.0962%2026.7688%2018.9615%2026.7688H10.0385C7.90375%2026.7688%206.4149%2026.7664%205.29156%2026.6155C4.20032%2026.4687%203.62243%2026.2004%203.21084%2025.7887C2.79924%2025.3771%202.53088%2024.7993%202.38417%2023.708C2.23313%2022.5846%202.23077%2021.0958%202.23077%2018.9611Z'%20fill='white'/%3e%3c/svg%3e",XP="data:image/svg+xml,%3csvg%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M0%2022C0%2011.6291%20-2.6226e-07%206.44365%203.22183%203.22183C6.44365%20-2.6226e-07%2011.6291%200%2022%200C32.3708%200%2037.5564%20-2.6226e-07%2040.7781%203.22183C44%206.44365%2044%2011.6291%2044%2022C44%2032.3708%2044%2037.5564%2040.7781%2040.7781C37.5564%2044%2032.3708%2044%2022%2044C11.6291%2044%206.44365%2044%203.22183%2040.7781C-2.6226e-07%2037.5564%200%2032.3708%200%2022ZM22%2034.65C22.9112%2034.65%2023.65%2033.9112%2023.65%2033V21.5835L27.4333%2025.3667C28.0777%2026.011%2029.1223%2026.011%2029.7667%2025.3667C30.411%2024.7223%2030.411%2023.6777%2029.7667%2023.0333L23.1667%2016.4333C22.8573%2016.1238%2022.4376%2015.95%2022%2015.95C21.5624%2015.95%2021.1427%2016.1238%2020.8333%2016.4333L14.2333%2023.0333C13.5889%2023.6777%2013.5889%2024.7223%2014.2333%2025.3667C14.8776%2026.011%2015.9224%2026.011%2016.5667%2025.3667L20.35%2021.5835V33C20.35%2033.9112%2021.0888%2034.65%2022%2034.65ZM13.2%2012.65C12.2887%2012.65%2011.55%2011.9113%2011.55%2011C11.55%2010.0887%2012.2887%209.35%2013.2%209.35H30.8C31.7112%209.35%2032.45%2010.0887%2032.45%2011C32.45%2011.9113%2031.7112%2012.65%2030.8%2012.65H13.2Z'%20fill='url(%23paint0_linear_6505_459)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_6505_459'%20x1='22'%20y1='0'%20x2='22'%20y2='44'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%237C48FE'/%3e%3cstop%20offset='1'%20stop-color='%23C849F8'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e",YP="data:image/svg+xml,%3csvg%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M44%2022C44%2032.3709%2044%2037.5564%2040.7782%2040.7782C37.5564%2044%2032.3709%2044%2022%2044C11.6292%2044%206.44358%2044%203.2219%2040.7782C0%2037.5564%200%2032.3709%200%2022C0%2011.6292%200%206.44358%203.2219%203.2219C6.44358%200%2011.6292%200%2022%200C32.3709%200%2037.5564%200%2040.7782%203.2219C44%206.44358%2044%2011.6292%2044%2022ZM22%209.35C21.0888%209.35%2020.35%2010.0888%2020.35%2011V22.4165L16.5667%2018.6333C15.9223%2017.989%2014.8777%2017.989%2014.2333%2018.6333C13.589%2019.2777%2013.589%2020.3223%2014.2333%2020.9667L20.8333%2027.5667C21.1427%2027.8762%2021.5624%2028.05%2022%2028.05C22.4376%2028.05%2022.8573%2027.8762%2023.1667%2027.5667L29.7667%2020.9667C30.4111%2020.3223%2030.4111%2019.2777%2029.7667%2018.6333C29.1224%2017.989%2028.0776%2017.989%2027.4333%2018.6333L23.65%2022.4165V11C23.65%2010.0888%2022.9112%209.35%2022%209.35ZM30.8%2031.35C31.7113%2031.35%2032.45%2032.0887%2032.45%2033C32.45%2033.9113%2031.7113%2034.65%2030.8%2034.65H13.2C12.2888%2034.65%2011.55%2033.9113%2011.55%2033C11.55%2032.0887%2012.2888%2031.35%2013.2%2031.35L30.8%2031.35Z'%20fill='url(%23paint0_linear_6505_460)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_6505_460'%20x1='22'%20y1='44'%20x2='22'%20y2='0'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%237C48FE'/%3e%3cstop%20offset='1'%20stop-color='%23C849F8'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e",ZP="/BG-REMOVAL/assets/image_w_bg-CAl5Q0sB.png",JP="/BG-REMOVAL/assets/image_wo_bg-CH2_nM8n.png",e3="data:image/svg+xml,%3csvg%20width='58'%20height='58'%20viewBox='0%200%2058%2058'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20filter='url(%23filter0_d_6414_485)'%3e%3cpath%20d='M29%2049C41.7025%2049%2052%2038.7025%2052%2026C52%2013.2975%2041.7025%203%2029%203C16.2975%203%206%2013.2975%206%2026C6%2038.7025%2016.2975%2049%2029%2049Z'%20fill='white'/%3e%3c/g%3e%3cpath%20d='M30.811%2035.7731H26.584V26.7731H24.472V23.2991H26.584V21.2181C26.584%2018.3891%2027.772%2016.7051%2031.165%2016.7051H33.986V20.1751H32.224C30.905%2020.1751%2030.817%2020.6591%2030.817%2021.5641L30.811%2023.2991H34.006L33.632%2026.7691H30.811V35.7691V35.7731Z'%20fill='black'/%3e%3cdefs%3e%3cfilter%20id='filter0_d_6414_485'%20x='0'%20y='0'%20width='58'%20height='58'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeColorMatrix%20in='SourceAlpha'%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%20127%200'%20result='hardAlpha'/%3e%3cfeOffset%20dy='3'/%3e%3cfeGaussianBlur%20stdDeviation='3'/%3e%3cfeColorMatrix%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.161%200'/%3e%3cfeBlend%20mode='normal'%20in2='BackgroundImageFix'%20result='effect1_dropShadow_6414_485'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='effect1_dropShadow_6414_485'%20result='shape'/%3e%3c/filter%3e%3c/defs%3e%3c/svg%3e",t3="data:image/svg+xml,%3csvg%20width='59'%20height='59'%20viewBox='0%200%2059%2059'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20filter='url(%23filter0_d_6414_493)'%3e%3cpath%20d='M29.239%2049.478C42.0735%2049.478%2052.478%2039.0735%2052.478%2026.239C52.478%2013.4045%2042.0735%203%2029.239%203C16.4045%203%206%2013.4045%206%2026.239C6%2039.0735%2016.4045%2049.478%2029.239%2049.478Z'%20fill='white'/%3e%3c/g%3e%3cpath%20d='M25.291%2033.389C23.3461%2033.3991%2021.4746%2032.6475%2020.077%2031.295C19.3944%2030.6415%2018.8512%2029.8566%2018.48%2028.9876C18.1089%2028.1186%2017.9176%2027.1834%2017.9176%2026.2385C17.9176%2025.2935%2018.1089%2024.3583%2018.48%2023.4893C18.8512%2022.6203%2019.3944%2021.8354%2020.077%2021.182C21.4395%2019.877%2023.2419%2019.1304%2025.1282%2019.0896C27.0144%2019.0489%2028.8473%2019.717%2030.265%2020.962L28.093%2023.026C27.3029%2022.3796%2026.3137%2022.0263%2025.293%2022.026C24.1587%2022.0097%2023.0644%2022.4442%2022.2503%2023.2341C21.4362%2024.024%2020.9689%2025.1048%2020.951%2026.239C20.9699%2027.3721%2021.4374%2028.4515%2022.251%2029.2405C23.0645%2030.0295%2024.1578%2030.4637%2025.291%2030.448C26.161%2030.4517%2027.0123%2030.1952%2027.7354%2029.7114C28.4585%2029.2276%2029.0205%2028.5386%2029.349%2027.733H25.198V24.746H32.498C32.7536%2025.9176%2032.7039%2027.1353%2032.3537%2028.2823C32.0035%2029.4292%2031.3645%2030.4669%2030.498%2031.296C29.1019%2032.6464%2027.2333%2033.3975%2025.291%2033.389ZM38.591%2029.27H36.724V26.782H34.158V24.972H36.724V22.483H38.591V24.972H41.157V26.782H38.591V29.271V29.27Z'%20fill='black'/%3e%3cdefs%3e%3cfilter%20id='filter0_d_6414_493'%20x='0'%20y='0'%20width='58.478'%20height='58.4785'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeColorMatrix%20in='SourceAlpha'%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%20127%200'%20result='hardAlpha'/%3e%3cfeOffset%20dy='3'/%3e%3cfeGaussianBlur%20stdDeviation='3'/%3e%3cfeColorMatrix%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.161%200'/%3e%3cfeBlend%20mode='normal'%20in2='BackgroundImageFix'%20result='effect1_dropShadow_6414_493'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='effect1_dropShadow_6414_493'%20result='shape'/%3e%3c/filter%3e%3c/defs%3e%3c/svg%3e",n3="data:image/svg+xml,%3csvg%20width='59'%20height='59'%20viewBox='0%200%2059%2059'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20filter='url(%23filter0_d_6414_489)'%3e%3cpath%20d='M29.24%2049.48C42.0751%2049.48%2052.48%2039.0751%2052.48%2026.24C52.48%2013.4049%2042.0751%203%2029.24%203C16.4049%203%206%2013.4049%206%2026.24C6%2039.0751%2016.4049%2049.48%2029.24%2049.48Z'%20fill='white'/%3e%3c/g%3e%3cpath%20d='M38.778%2020.3267C38.0638%2020.6427%2037.3064%2020.8504%2036.531%2020.9427C37.3477%2020.4542%2037.959%2019.6855%2038.251%2018.7797C37.4829%2019.2354%2036.6424%2019.556%2035.766%2019.7277C35.2291%2019.1557%2034.5328%2018.7582%2033.7672%2018.5868C33.0017%2018.4154%2032.2023%2018.4779%2031.4728%2018.7664C30.7433%2019.0548%2030.1173%2019.5558%2029.676%2020.2044C29.2347%2020.853%2028.9985%2021.6193%2028.998%2022.4037C28.9973%2022.7039%2029.0309%2023.0032%2029.098%2023.2957C27.5431%2023.2176%2026.022%2022.8133%2024.6334%2022.1092C23.2449%2021.4051%2022.0199%2020.4169%2021.038%2019.2087C20.5377%2020.0698%2020.3843%2021.0892%2020.6091%2022.0593C20.8339%2023.0294%2021.4199%2023.8775%2022.248%2024.4307C21.6269%2024.4116%2021.0195%2024.2435%2020.477%2023.9407V23.9927C20.4773%2024.8949%2020.7893%2025.7692%2021.3603%2026.4677C21.9312%2027.1662%2022.7259%2027.6459%2023.61%2027.8257C23.2739%2027.9172%2022.9272%2027.9632%2022.579%2027.9627C22.3336%2027.9628%2022.0888%2027.9393%2021.848%2027.8927C22.0981%2028.67%2022.5848%2029.3497%2023.2401%2029.8368C23.8955%2030.324%2024.6866%2030.5942%2025.503%2030.6097C24.1163%2031.6964%2022.4047%2032.2856%2020.643%2032.2827C20.3312%2032.2832%2020.0196%2032.2652%2019.71%2032.2287C21.4996%2033.3787%2023.5827%2033.9887%2025.71%2033.9857C27.1741%2033.9956%2028.6255%2033.7145%2029.9801%2033.1587C31.3346%2032.603%2032.5653%2031.7836%2033.6006%2030.7484C34.6359%2029.7131%2035.4552%2028.4824%2036.0109%2027.1279C36.5667%2025.7733%2036.8478%2024.3218%2036.838%2022.8577C36.838%2022.6877%2036.838%2022.5197%2036.827%2022.3517C37.5927%2021.7984%2038.2537%2021.113%2038.779%2020.3277L38.778%2020.3267Z'%20fill='black'/%3e%3cdefs%3e%3cfilter%20id='filter0_d_6414_489'%20x='0'%20y='0'%20width='58.48'%20height='58.4805'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeColorMatrix%20in='SourceAlpha'%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%20127%200'%20result='hardAlpha'/%3e%3cfeOffset%20dy='3'/%3e%3cfeGaussianBlur%20stdDeviation='3'/%3e%3cfeColorMatrix%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.161%200'/%3e%3cfeBlend%20mode='normal'%20in2='BackgroundImageFix'%20result='effect1_dropShadow_6414_489'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='effect1_dropShadow_6414_489'%20result='shape'/%3e%3c/filter%3e%3c/defs%3e%3c/svg%3e",Xs={logo:WP,arrow_icon:HP,header_img:KP,remove_bg_icon:qP,upload_icon:XP,download_icon:YP,image_w_bg:ZP,image_wo_bg:JP,facebook_icon:e3,google_plus_icon:t3,twitter_icon:n3,upload_btn_icon:QP},m1=Ce.createContext(null),r3=({children:e})=>{const[n,t]=Ce.useState(null),[a,i]=Ce.useState(""),[l,u]=Ce.useState(""),[d,f]=Ce.useState(!1),[h,_]=Ce.useState(""),[m,p]=Ce.useState("local"),y=Ce.useMemo(()=>({originalFile:n,setOriginalFile:t,originalPreview:a,setOriginalPreview:i,processedImage:l,setProcessedImage:u,loading:d,setLoading:f,error:h,setError:_,mode:m,setMode:p}),[n,a,l,d,h,m]);return rt.jsx(m1.Provider,{value:y,children:e})},D_=()=>{const e=Ce.useContext(m1);if(!e)throw new Error("useImage must be used within an ImageProvider");return e};var s3=Object.freeze({InvalidProxyUrlErrorMessage:"The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})",InvalidPublishableKeyErrorMessage:"The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})",MissingPublishableKeyErrorMessage:"Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.",MissingSecretKeyErrorMessage:"Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.",MissingClerkProvider:"{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider"});function _1({packageName:e,customMessages:n}){let t=e;function a(l,u){if(!u)return`${t}: ${l}`;let d=l;const f=l.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);for(const h of f){const _=(u[h[1]]||"").toString();d=d.replace(`{{${h[1]}}}`,_)}return`${t}: ${d}`}const i={...s3,...n};return{setPackageName({packageName:l}){return typeof l=="string"&&(t=l),this},setMessages({customMessages:l}){return Object.assign(i,l||{}),this},throwInvalidPublishableKeyError(l){throw new Error(a(i.InvalidPublishableKeyErrorMessage,l))},throwInvalidProxyUrl(l){throw new Error(a(i.InvalidProxyUrlErrorMessage,l))},throwMissingPublishableKeyError(){throw new Error(a(i.MissingPublishableKeyErrorMessage))},throwMissingSecretKeyError(){throw new Error(a(i.MissingSecretKeyErrorMessage))},throwMissingClerkProviderError(l){throw new Error(a(i.MissingClerkProvider,l))},throw(l){throw new Error(a(l))}}}var g1=class y1 extends Error{constructor(n,{code:t,cause:a}){const i=" Clerk:",l=new RegExp(i.replace(" ","\\s*"),"i"),u=n.replace(l,""),d=`${i} ${u.trim()}

(code="${t}")
`;super(d),this.toString=()=>`[${this.name}]
Message:${this.message}`,Object.setPrototypeOf(this,y1.prototype),this.cause=a,this.code=t,this.message=d,this.clerkRuntimeError=!0,this.name="ClerkRuntimeError"}},v1=Object.defineProperty,a3=Object.getOwnPropertyDescriptor,i3=Object.getOwnPropertyNames,o3=Object.prototype.hasOwnProperty,l3=(e,n)=>{for(var t in n)v1(e,t,{get:n[t],enumerable:!0})},u3=(e,n,t,a)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of i3(n))!o3.call(e,i)&&i!==t&&v1(e,i,{get:()=>n[i],enumerable:!(a=a3(n,i))||a.enumerable});return e},c3=(e,n,t)=>(u3(e,n,"default"),t),d3={strict_mfa:{afterMinutes:10,level:"multi_factor"},strict:{afterMinutes:10,level:"second_factor"},moderate:{afterMinutes:60,level:"second_factor"},lax:{afterMinutes:1440,level:"second_factor"}},f3=new Set(["first_factor","second_factor","multi_factor"]),h3=new Set(["strict_mfa","strict","moderate","lax"]),p3=e=>typeof e=="number"&&e>0,m3=e=>f3.has(e),_3=e=>h3.has(e),yg=e=>e.replace(/^(org:)*/,"org:"),g3=(e,n)=>{const{orgId:t,orgRole:a,orgPermissions:i}=n;return!e.role&&!e.permission||!t||!a||!i?null:e.permission?i.includes(yg(e.permission)):e.role?yg(a)===yg(e.role):null},Nv=(e,n)=>{const{org:t,user:a}=v3(e),[i,l]=n.split(":"),u=l||i;return i==="org"?t.includes(u):i==="user"?a.includes(u):[...t,...a].includes(u)},y3=(e,n)=>{const{features:t,plans:a}=n;return e.feature&&t?Nv(t,e.feature):e.plan&&a?Nv(a,e.plan):null},v3=e=>{const n=e?e.split(",").map(t=>t.trim()):[];return{org:n.filter(t=>t.split(":")[0].includes("o")).map(t=>t.split(":")[1]),user:n.filter(t=>t.split(":")[0].includes("u")).map(t=>t.split(":")[1])}},b3=e=>{if(!e)return!1;const n=i=>typeof i=="string"?d3[i]:i,t=typeof e=="string"&&_3(e),a=typeof e=="object"&&m3(e.level)&&p3(e.afterMinutes);return t||a?n.bind(null,e):!1},w3=(e,{factorVerificationAge:n})=>{if(!e.reverification||!n)return null;const t=b3(e.reverification);if(!t)return null;const{level:a,afterMinutes:i}=t(),[l,u]=n,d=l!==-1?i>l:null,f=u!==-1?i>u:null;switch(a){case"first_factor":return d;case"second_factor":return u!==-1?f:d;case"multi_factor":return u===-1?d:d&&f}},M3=e=>n=>{if(!e.userId)return!1;const t=y3(n,e),a=g3(n,e),i=w3(n,e);return[t||a,i].some(l=>l===null)?[t||a,i].some(l=>l===!0):[t||a,i].every(l=>l===!0)},x3=({authObject:{sessionId:e,sessionStatus:n,userId:t,actor:a,orgId:i,orgRole:l,orgSlug:u,signOut:d,getToken:f,has:h,sessionClaims:_},options:{treatPendingAsSignedOut:m=!0}})=>{if(e===void 0&&t===void 0)return{isLoaded:!1,isSignedIn:void 0,sessionId:e,sessionClaims:void 0,userId:t,actor:void 0,orgId:void 0,orgRole:void 0,orgSlug:void 0,has:void 0,signOut:d,getToken:f};if(e===null&&t===null)return{isLoaded:!0,isSignedIn:!1,sessionId:e,userId:t,sessionClaims:null,actor:null,orgId:null,orgRole:null,orgSlug:null,has:()=>!1,signOut:d,getToken:f};if(m&&n==="pending")return{isLoaded:!0,isSignedIn:!1,sessionId:null,userId:null,sessionClaims:null,actor:null,orgId:null,orgRole:null,orgSlug:null,has:()=>!1,signOut:d,getToken:f};if(e&&_&&t&&i&&l)return{isLoaded:!0,isSignedIn:!0,sessionId:e,sessionClaims:_,userId:t,actor:a||null,orgId:i,orgRole:l,orgSlug:u||null,has:h,signOut:d,getToken:f};if(e&&_&&t&&!i)return{isLoaded:!0,isSignedIn:!0,sessionId:e,sessionClaims:_,userId:t,actor:a||null,orgId:null,orgRole:null,orgSlug:null,has:h,signOut:d,getToken:f}},b1=e=>typeof atob<"u"&&typeof atob=="function"?atob(e):typeof global<"u"&&global.Buffer?new global.Buffer(e,"base64").toString():e,T3=[".lcl.dev",".stg.dev",".lclstage.dev",".stgstage.dev",".dev.lclclerk.com",".stg.lclclerk.com",".accounts.lclclerk.com","accountsstage.dev","accounts.dev"],w1="pk_live_",E3="pk_test_";function M1(e){if(!e.endsWith("$"))return!1;const n=e.slice(0,-1);return n.includes("$")?!1:n.includes(".")}function Uv(e,n={}){if(e=e||"",!e||!N0(e)){if(n.fatal&&!e)throw new Error("Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys");if(n.fatal&&!N0(e))throw new Error("Publishable key not valid.");return null}const t=e.startsWith(w1)?"production":"development";let a;try{a=b1(e.split("_")[2])}catch{if(n.fatal)throw new Error("Publishable key not valid: Failed to decode key.");return null}if(!M1(a)){if(n.fatal)throw new Error("Publishable key not valid: Decoded key has invalid format.");return null}let i=a.slice(0,-1);return n.proxyUrl?i=n.proxyUrl:t!=="development"&&n.domain&&n.isSatellite&&(i=`clerk.${n.domain}`),{instanceType:t,frontendApi:i}}function N0(e=""){try{if(!(e.startsWith(w1)||e.startsWith(E3)))return!1;const t=e.split("_");if(t.length!==3)return!1;const a=t[2];if(!a)return!1;const i=b1(a);return M1(i)}catch{return!1}}function S3(){const e=new Map;return{isDevOrStagingUrl:n=>{if(!n)return!1;const t=typeof n=="string"?n:n.hostname;let a=e.get(t);return a===void 0&&(a=T3.some(i=>t.endsWith(i)),e.set(t,a)),a}}}var C3="METHOD_CALLED",P3=.1;function x1(e,n){return{event:C3,eventSamplingRate:P3,payload:{method:e,...n}}}var vg={exports:{}},bg={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Vv;function A3(){if(Vv)return bg;Vv=1;var e=A_();function n(m,p){return m===p&&(m!==0||1/m===1/p)||m!==m&&p!==p}var t=typeof Object.is=="function"?Object.is:n,a=e.useState,i=e.useEffect,l=e.useLayoutEffect,u=e.useDebugValue;function d(m,p){var y=p(),v=a({inst:{value:y,getSnapshot:p}}),x=v[0].inst,L=v[1];return l(function(){x.value=y,x.getSnapshot=p,f(x)&&L({inst:x})},[m,y,p]),i(function(){return f(x)&&L({inst:x}),m(function(){f(x)&&L({inst:x})})},[m]),u(y),y}function f(m){var p=m.getSnapshot;m=m.value;try{var y=p();return!t(m,y)}catch{return!0}}function h(m,p){return p()}var _=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?h:d;return bg.useSyncExternalStore=e.useSyncExternalStore!==void 0?e.useSyncExternalStore:_,bg}var Gv;function k3(){return Gv||(Gv=1,vg.exports=A3()),vg.exports}var T1=k3();const E1=0,S1=1,C1=2,Wv=3;var Hv=Object.prototype.hasOwnProperty;function U0(e,n){var t,a;if(e===n)return!0;if(e&&n&&(t=e.constructor)===n.constructor){if(t===Date)return e.getTime()===n.getTime();if(t===RegExp)return e.toString()===n.toString();if(t===Array){if((a=e.length)===n.length)for(;a--&&U0(e[a],n[a]););return a===-1}if(!t||typeof e=="object"){a=0;for(t in e)if(Hv.call(e,t)&&++a&&!Hv.call(n,t)||!(t in n)||!U0(e[t],n[t]))return!1;return Object.keys(n).length===a}}return e!==e&&n!==n}const vi=new WeakMap,Hl=()=>{},ts=Hl(),v_=Object,dn=e=>e===ts,Fa=e=>typeof e=="function",Ho=(e,n)=>({...e,...n}),P1=e=>Fa(e.then),wg={},Nm={},Ey="undefined",Gp=typeof window!=Ey,V0=typeof document!=Ey,O3=Gp&&"Deno"in window,$3=()=>Gp&&typeof window.requestAnimationFrame!=Ey,Gl=(e,n)=>{const t=vi.get(e);return[()=>!dn(n)&&e.get(n)||wg,a=>{if(!dn(n)){const i=e.get(n);n in Nm||(Nm[n]=i),t[5](n,Ho(i,a),i||wg)}},t[6],()=>!dn(n)&&n in Nm?Nm[n]:!dn(n)&&e.get(n)||wg]};let G0=!0;const D3=()=>G0,[W0,H0]=Gp&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[Hl,Hl],I3=()=>{const e=V0&&document.visibilityState;return dn(e)||e!=="hidden"},L3=e=>(V0&&document.addEventListener("visibilitychange",e),W0("focus",e),()=>{V0&&document.removeEventListener("visibilitychange",e),H0("focus",e)}),z3=e=>{const n=()=>{G0=!0,e()},t=()=>{G0=!1};return W0("online",n),W0("offline",t),()=>{H0("online",n),H0("offline",t)}},F3={isOnline:D3,isVisible:I3},R3={initFocus:L3,initReconnect:z3},Kv=!We.useId,Fp=!Gp||O3,B3=e=>$3()?window.requestAnimationFrame(e):setTimeout(e,1),$p=Fp?Ce.useEffect:Ce.useLayoutEffect,Mg=typeof navigator<"u"&&navigator.connection,qv=!Fp&&Mg&&(["slow-2g","2g"].includes(Mg.effectiveType)||Mg.saveData),Um=new WeakMap,j3=e=>v_.prototype.toString.call(e),xg=(e,n)=>e===`[object ${n}]`;let N3=0;const K0=e=>{const n=typeof e,t=j3(e),a=xg(t,"Date"),i=xg(t,"RegExp"),l=xg(t,"Object");let u,d;if(v_(e)===e&&!a&&!i){if(u=Um.get(e),u)return u;if(u=++N3+"~",Um.set(e,u),Array.isArray(e)){for(u="@",d=0;d<e.length;d++)u+=K0(e[d])+",";Um.set(e,u)}if(l){u="#";const f=v_.keys(e).sort();for(;!dn(d=f.pop());)dn(e[d])||(u+=d+":"+K0(e[d])+",");Um.set(e,u)}}else u=a?e.toJSON():n=="symbol"?e.toString():n=="string"?JSON.stringify(e):""+e;return u},af=e=>{if(Fa(e))try{e=e()}catch{e=""}const n=e;return e=typeof e=="string"?e:(Array.isArray(e)?e.length:e)?K0(e):"",[e,n]};let U3=0;const q0=()=>++U3;async function A1(...e){const[n,t,a,i]=e,l=Ho({populateCache:!0,throwOnError:!0},typeof i=="boolean"?{revalidate:i}:i||{});let u=l.populateCache;const d=l.rollbackOnError;let f=l.optimisticData;const h=p=>typeof d=="function"?d(p):d!==!1,_=l.throwOnError;if(Fa(t)){const p=t,y=[],v=n.keys();for(const x of v)!/^\$(inf|sub)\$/.test(x)&&p(n.get(x)._k)&&y.push(x);return Promise.all(y.map(m))}return m(t);async function m(p){const[y]=af(p);if(!y)return;const[v,x]=Gl(n,y),[L,T,E,I]=vi.get(n),P=()=>{const oe=L[y];return(Fa(l.revalidate)?l.revalidate(v().data,p):l.revalidate!==!1)&&(delete E[y],delete I[y],oe&&oe[0])?oe[0](C1).then(()=>v().data):v().data};if(e.length<3)return P();let S=a,k,C=!1;const D=q0();T[y]=[D,0];const V=!dn(f),U=v(),ne=U.data,ee=U._c,H=dn(ee)?ne:ee;if(V&&(f=Fa(f)?f(H,ne):f,x({data:f,_c:H})),Fa(S))try{S=S(H)}catch(oe){k=oe,C=!0}if(S&&P1(S))if(S=await S.catch(oe=>{k=oe,C=!0}),D!==T[y][0]){if(C)throw k;return S}else C&&V&&h(k)&&(u=!0,x({data:H,_c:ts}));if(u&&!C)if(Fa(u)){const oe=u(S,H);x({data:oe,error:ts,_c:ts})}else x({data:S,error:ts,_c:ts});if(T[y][1]=q0(),Promise.resolve(P()).then(()=>{x({_c:ts})}),C){if(_)throw k;return}return S}}const Qv=(e,n)=>{for(const t in e)e[t][0]&&e[t][0](n)},k1=(e,n)=>{if(!vi.has(e)){const t=Ho(R3,n),a=Object.create(null),i=A1.bind(ts,e);let l=Hl;const u=Object.create(null),d=(_,m)=>{const p=u[_]||[];return u[_]=p,p.push(m),()=>p.splice(p.indexOf(m),1)},f=(_,m,p)=>{e.set(_,m);const y=u[_];if(y)for(const v of y)v(m,p)},h=()=>{if(!vi.has(e)&&(vi.set(e,[a,Object.create(null),Object.create(null),Object.create(null),i,f,d]),!Fp)){const _=t.initFocus(setTimeout.bind(ts,Qv.bind(ts,a,E1))),m=t.initReconnect(setTimeout.bind(ts,Qv.bind(ts,a,S1)));l=()=>{_&&_(),m&&m(),vi.delete(e)}}};return h(),[e,i,h,l]}return[e,vi.get(e)[4]]},V3=(e,n,t,a,i)=>{const l=t.errorRetryCount,u=i.retryCount,d=~~((Math.random()+.5)*(1<<(u<8?u:8)))*t.errorRetryInterval;!dn(l)&&u>l||setTimeout(a,d,i)},G3=U0,[Wp,O1]=k1(new Map),$1=Ho({onLoadingSlow:Hl,onSuccess:Hl,onError:Hl,onErrorRetry:V3,onDiscarded:Hl,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:qv?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:qv?5e3:3e3,compare:G3,isPaused:()=>!1,cache:Wp,mutate:O1,fallback:{}},F3),D1=(e,n)=>{const t=Ho(e,n);if(n){const{use:a,fallback:i}=e,{use:l,fallback:u}=n;a&&l&&(t.use=a.concat(l)),i&&u&&(t.fallback=Ho(i,u))}return t},Q0=Ce.createContext({}),W3=e=>{const{value:n}=e,t=Ce.useContext(Q0),a=Fa(n),i=Ce.useMemo(()=>a?n(t):n,[a,t,n]),l=Ce.useMemo(()=>a?i:D1(t,i),[a,t,i]),u=i&&i.provider,d=Ce.useRef(ts);u&&!d.current&&(d.current=k1(u(l.cache||Wp),i));const f=d.current;return f&&(l.cache=f[0],l.mutate=f[1]),$p(()=>{if(f)return f[2]&&f[2](),f[3]},[]),Ce.createElement(Q0.Provider,Ho(e,{value:l}))},I1="$inf$",L1=Gp&&window.__SWR_DEVTOOLS_USE__,H3=L1?window.__SWR_DEVTOOLS_USE__:[],K3=()=>{L1&&(window.__SWR_DEVTOOLS_REACT__=We)},z1=e=>Fa(e[1])?[e[0],e[1],e[2]||{}]:[e[0],null,(e[1]===null?e[2]:e[1])||{}],F1=()=>Ho($1,Ce.useContext(Q0)),q3=(e,n)=>{const[t,a]=af(e),[,,,i]=vi.get(Wp);if(i[t])return i[t];const l=n(a);return i[t]=l,l},Q3=e=>(n,t,a)=>e(n,t&&((...l)=>{const[u]=af(n),[,,,d]=vi.get(Wp);if(u.startsWith(I1))return t(...l);const f=d[u];return dn(f)?t(...l):(delete d[u],f)}),a),X3=H3.concat(Q3),Y3=e=>function(...t){const a=F1(),[i,l,u]=z1(t),d=D1(a,u);let f=e;const{use:h}=d,_=(h||[]).concat(X3);for(let m=_.length;m--;)f=_[m](f);return f(i,l||d.fetcher||null,d)},Z3=(e,n,t)=>{const a=n[e]||(n[e]=[]);return a.push(t),()=>{const i=a.indexOf(t);i>=0&&(a[i]=a[a.length-1],a.pop())}},J3=(e,n)=>(...t)=>{const[a,i,l]=z1(t),u=(l.use||[]).concat(n);return e(a,i,{...l,use:u})};K3();const eA=()=>{},tA=eA(),X0=Object,Xv=e=>e===tA,nA=e=>typeof e=="function",Vm=new WeakMap,rA=e=>X0.prototype.toString.call(e),Tg=(e,n)=>e===`[object ${n}]`;let sA=0;const Y0=e=>{const n=typeof e,t=rA(e),a=Tg(t,"Date"),i=Tg(t,"RegExp"),l=Tg(t,"Object");let u,d;if(X0(e)===e&&!a&&!i){if(u=Vm.get(e),u)return u;if(u=++sA+"~",Vm.set(e,u),Array.isArray(e)){for(u="@",d=0;d<e.length;d++)u+=Y0(e[d])+",";Vm.set(e,u)}if(l){u="#";const f=X0.keys(e).sort();for(;!Xv(d=f.pop());)Xv(e[d])||(u+=d+":"+Y0(e[d])+",");Vm.set(e,u)}}else u=a?e.toJSON():n=="symbol"?e.toString():n=="string"?JSON.stringify(e):""+e;return u},aA=e=>{if(nA(e))try{e=e()}catch{e=""}const n=e;return e=typeof e=="string"?e:(Array.isArray(e)?e.length:e)?Y0(e):"",[e,n]},iA=e=>aA(e)[0],Eg=We.use||(e=>{switch(e.status){case"pending":throw e;case"fulfilled":return e.value;case"rejected":throw e.reason;default:throw e.status="pending",e.then(n=>{e.status="fulfilled",e.value=n},n=>{e.status="rejected",e.reason=n}),e}}),Sg={dedupe:!0},oA=(e,n,t)=>{const{cache:a,compare:i,suspense:l,fallbackData:u,revalidateOnMount:d,revalidateIfStale:f,refreshInterval:h,refreshWhenHidden:_,refreshWhenOffline:m,keepPreviousData:p}=t,[y,v,x,L]=vi.get(a),[T,E]=af(e),I=Ce.useRef(!1),P=Ce.useRef(!1),S=Ce.useRef(T),k=Ce.useRef(n),C=Ce.useRef(t),D=()=>C.current,V=()=>D().isVisible()&&D().isOnline(),[U,ne,ee,H]=Gl(a,T),oe=Ce.useRef({}).current,ae=dn(u)?dn(t.fallback)?ts:t.fallback[T]:u,W=(be,Ae)=>{for(const Ne in oe){const De=Ne;if(De==="data"){if(!i(be[De],Ae[De])&&(!dn(be[De])||!i(fe,Ae[De])))return!1}else if(Ae[De]!==be[De])return!1}return!0},te=Ce.useMemo(()=>{const be=!T||!n?!1:dn(d)?D().isPaused()||l?!1:f!==!1:d,Ae=Ge=>{const Ye=Ho(Ge);return delete Ye._k,be?{isValidating:!0,isLoading:!0,...Ye}:Ye},Ne=U(),De=H(),xe=Ae(Ne),Ve=Ne===De?xe:Ae(De);let Ee=xe;return[()=>{const Ge=Ae(U());return W(Ge,Ee)?(Ee.data=Ge.data,Ee.isLoading=Ge.isLoading,Ee.isValidating=Ge.isValidating,Ee.error=Ge.error,Ee):(Ee=Ge,Ge)},()=>Ve]},[a,T]),ie=T1.useSyncExternalStore(Ce.useCallback(be=>ee(T,(Ae,Ne)=>{W(Ne,Ae)||be()}),[a,T]),te[0],te[1]),_e=!I.current,q=y[T]&&y[T].length>0,B=ie.data,R=dn(B)?ae&&P1(ae)?Eg(ae):ae:B,Q=ie.error,G=Ce.useRef(R),fe=p?dn(B)?dn(G.current)?R:G.current:B:R,Te=q&&!dn(Q)?!1:_e&&!dn(d)?d:D().isPaused()?!1:l?dn(R)?!1:f:dn(R)||f,ze=!!(T&&n&&_e&&Te),Ue=dn(ie.isValidating)?ze:ie.isValidating,ft=dn(ie.isLoading)?ze:ie.isLoading,je=Ce.useCallback(async be=>{const Ae=k.current;if(!T||!Ae||P.current||D().isPaused())return!1;let Ne,De,xe=!0;const Ve=be||{},Ee=!x[T]||!Ve.dedupe,Ge=()=>Kv?!P.current&&T===S.current&&I.current:T===S.current,Ye={isValidating:!1,isLoading:!1},_t=()=>{ne(Ye)},Re=()=>{const st=x[T];st&&st[1]===De&&delete x[T]},xt={isValidating:!0};dn(U().data)&&(xt.isLoading=!0);try{if(Ee&&(ne(xt),t.loadingTimeout&&dn(U().data)&&setTimeout(()=>{xe&&Ge()&&D().onLoadingSlow(T,t)},t.loadingTimeout),x[T]=[Ae(E),q0()]),[Ne,De]=x[T],Ne=await Ne,Ee&&setTimeout(Re,t.dedupingInterval),!x[T]||x[T][1]!==De)return Ee&&Ge()&&D().onDiscarded(T),!1;Ye.error=ts;const st=v[T];if(!dn(st)&&(De<=st[0]||De<=st[1]||st[1]===0))return _t(),Ee&&Ge()&&D().onDiscarded(T),!1;const nt=U().data;Ye.data=i(nt,Ne)?nt:Ne,Ee&&Ge()&&D().onSuccess(Ne,T,t)}catch(st){Re();const nt=D(),{shouldRetryOnError:ct}=nt;nt.isPaused()||(Ye.error=st,Ee&&Ge()&&(nt.onError(st,T,nt),(ct===!0||Fa(ct)&&ct(st))&&(!D().revalidateOnFocus||!D().revalidateOnReconnect||V())&&nt.onErrorRetry(st,T,nt,pt=>{const lt=y[T];lt&&lt[0]&&lt[0](Wv,pt)},{retryCount:(Ve.retryCount||0)+1,dedupe:!0})))}return xe=!1,_t(),!0},[T,a]),le=Ce.useCallback((...be)=>A1(a,S.current,...be),[]);if($p(()=>{k.current=n,C.current=t,dn(B)||(G.current=B)}),$p(()=>{if(!T)return;const be=je.bind(ts,Sg);let Ae=0;D().revalidateOnFocus&&(Ae=Date.now()+D().focusThrottleInterval);const De=Z3(T,y,(xe,Ve={})=>{if(xe==E1){const Ee=Date.now();D().revalidateOnFocus&&Ee>Ae&&V()&&(Ae=Ee+D().focusThrottleInterval,be())}else if(xe==S1)D().revalidateOnReconnect&&V()&&be();else{if(xe==C1)return je();if(xe==Wv)return je(Ve)}});return P.current=!1,S.current=T,I.current=!0,ne({_k:E}),Te&&(x[T]||(dn(R)||Fp?be():B3(be))),()=>{P.current=!0,De()}},[T]),$p(()=>{let be;function Ae(){const De=Fa(h)?h(U().data):h;De&&be!==-1&&(be=setTimeout(Ne,De))}function Ne(){!U().error&&(_||D().isVisible())&&(m||D().isOnline())?je(Sg).then(Ae):Ae()}return Ae(),()=>{be&&(clearTimeout(be),be=-1)}},[h,_,m,T]),Ce.useDebugValue(fe),l&&dn(R)&&T){if(!Kv&&Fp)throw new Error("Fallback data is required when using Suspense in SSR.");k.current=n,C.current=t,P.current=!1;const be=L[T];if(!dn(be)){const Ae=le(be);Eg(Ae)}if(dn(Q)){const Ae=je(Sg);dn(fe)||(Ae.status="fulfilled",Ae.value=!0),Eg(Ae)}else throw Q}return{mutate:le,get data(){return oe.data=!0,fe},get error(){return oe.error=!0,Q},get isValidating(){return oe.isValidating=!0,Ue},get isLoading(){return oe.isLoading=!0,ft}}},lA=v_.defineProperty(W3,"defaultValue",{value:$1}),Sy=Y3(oA),uA=Object.freeze(Object.defineProperty({__proto__:null,SWRConfig:lA,default:Sy,mutate:O1,preload:q3,unstable_serialize:iA,useSWRConfig:F1},Symbol.toStringTag,{value:"Module"})),cA=()=>{},dA=cA(),Z0=Object,Yv=e=>e===dA,fA=e=>typeof e=="function",Gm=new WeakMap,hA=e=>Z0.prototype.toString.call(e),Cg=(e,n)=>e===`[object ${n}]`;let pA=0;const J0=e=>{const n=typeof e,t=hA(e),a=Cg(t,"Date"),i=Cg(t,"RegExp"),l=Cg(t,"Object");let u,d;if(Z0(e)===e&&!a&&!i){if(u=Gm.get(e),u)return u;if(u=++pA+"~",Gm.set(e,u),Array.isArray(e)){for(u="@",d=0;d<e.length;d++)u+=J0(e[d])+",";Gm.set(e,u)}if(l){u="#";const f=Z0.keys(e).sort();for(;!Yv(d=f.pop());)Yv(e[d])||(u+=d+":"+J0(e[d])+",");Gm.set(e,u)}}else u=a?e.toJSON():n=="symbol"?e.toString():n=="string"?JSON.stringify(e):""+e;return u},mA=e=>{if(fA(e))try{e=e()}catch{e=""}const n=e;return e=typeof e=="string"?e:(Array.isArray(e)?e.length:e)?J0(e):"",[e,n]},_A=e=>mA(e?e(0,null):null)[0],Pg=Promise.resolve(),gA=e=>(n,t,a)=>{const i=Ce.useRef(!1),{cache:l,initialSize:u=1,revalidateAll:d=!1,persistSize:f=!1,revalidateFirstPage:h=!0,revalidateOnMount:_=!1,parallel:m=!1}=a,[,,,p]=vi.get(Wp);let y;try{y=_A(n),y&&(y=I1+y)}catch{}const[v,x,L]=Gl(l,y),T=Ce.useCallback(()=>dn(v()._l)?u:v()._l,[l,y,u]);T1.useSyncExternalStore(Ce.useCallback(D=>y?L(y,()=>{D()}):()=>{},[l,y]),T,T);const E=Ce.useCallback(()=>{const D=v()._l;return dn(D)?u:D},[y,u]),I=Ce.useRef(E());$p(()=>{if(!i.current){i.current=!0;return}y&&x({_l:f?I.current:E()})},[y,l]);const P=_&&!i.current,S=e(y,async D=>{const V=v()._i,U=v()._r;x({_r:ts});const ne=[],ee=E(),[H]=Gl(l,D),oe=H().data,ae=[];let W=null;for(let te=0;te<ee;++te){const[ie,_e]=af(n(te,m?null:W));if(!ie)break;const[q,B]=Gl(l,ie);let R=q().data;const Q=d||V||dn(R)||h&&!te&&!dn(oe)||P||oe&&!dn(oe[te])&&!a.compare(oe[te],R);if(t&&(typeof U=="function"?U(R,_e):Q)){const G=async()=>{if(!(ie in p))R=await t(_e);else{const Te=p[ie];delete p[ie],R=await Te}B({data:R,_k:_e}),ne[te]=R};m?ae.push(G):await G()}else ne[te]=R;m||(W=R)}return m&&await Promise.all(ae.map(te=>te())),x({_i:ts}),ne},a),k=Ce.useCallback(function(D,V){const U=typeof V=="boolean"?{revalidate:V}:V||{},ne=U.revalidate!==!1;return y?(ne&&(dn(D)?x({_i:!0,_r:U.revalidate}):x({_i:!1,_r:U.revalidate})),arguments.length?S.mutate(D,{...U,revalidate:ne}):S.mutate()):Pg},[y,l]),C=Ce.useCallback(D=>{if(!y)return Pg;const[,V]=Gl(l,y);let U;if(Fa(D)?U=D(E()):typeof D=="number"&&(U=D),typeof U!="number")return Pg;V({_l:U}),I.current=U;const ne=[],[ee]=Gl(l,y);let H=null;for(let oe=0;oe<U;++oe){const[ae]=af(n(oe,H)),[W]=Gl(l,ae),te=ae?W().data:ts;if(dn(te))return k(ee().data);ne.push(te),H=te}return k(ne)},[y,l,k,E]);return{size:E(),setSize:C,mutate:k,get data(){return S.data},get error(){return S.error},get isValidating(){return S.isValidating},get isLoading(){return S.isLoading}}},yA=J3(Sy,gA);var Zv=Object.prototype.hasOwnProperty;function Jv(e,n,t){for(t of e.keys())if(Dp(t,n))return t}function Dp(e,n){var t,a,i;if(e===n)return!0;if(e&&n&&(t=e.constructor)===n.constructor){if(t===Date)return e.getTime()===n.getTime();if(t===RegExp)return e.toString()===n.toString();if(t===Array){if((a=e.length)===n.length)for(;a--&&Dp(e[a],n[a]););return a===-1}if(t===Set){if(e.size!==n.size)return!1;for(a of e)if(i=a,i&&typeof i=="object"&&(i=Jv(n,i),!i)||!n.has(i))return!1;return!0}if(t===Map){if(e.size!==n.size)return!1;for(a of e)if(i=a[0],i&&typeof i=="object"&&(i=Jv(n,i),!i)||!Dp(a[1],n.get(i)))return!1;return!0}if(t===ArrayBuffer)e=new Uint8Array(e),n=new Uint8Array(n);else if(t===DataView){if((a=e.byteLength)===n.byteLength)for(;a--&&e.getInt8(a)===n.getInt8(a););return a===-1}if(ArrayBuffer.isView(e)){if((a=e.byteLength)===n.byteLength)for(;a--&&e[a]===n[a];);return a===-1}if(!t||typeof e=="object"){a=0;for(t in e)if(Zv.call(e,t)&&++a&&!Zv.call(n,t)||!(t in n)||!Dp(e[t],n[t]))return!1;return Object.keys(n).length===a}}return e!==e&&n!==n}function vA(e,n){if(!e)throw typeof n=="string"?new Error(n):new Error(`${n.displayName} not found`)}var no=(e,n)=>{const{assertCtxFn:t=vA}={},a=We.createContext(void 0);return a.displayName=e,[a,()=>{const u=We.useContext(a);return t(u,`${e} not found`),u.value},()=>{const u=We.useContext(a);return u?u.value:{}}]},Cy={};l3(Cy,{useSWR:()=>Sy,useSWRInfinite:()=>yA});c3(Cy,uA);var[R1,Py]=no("ClerkInstanceContext"),[bA,wA]=no("UserContext"),[MA]=no("ClientContext"),[xA]=no("SessionContext");We.createContext({});var[TA]=no("CheckoutContext"),EA=({children:e,...n})=>We.createElement(TA.Provider,{value:{value:n}},e),[SA]=no("OrganizationContext"),CA=({children:e,organization:n,swrConfig:t})=>We.createElement(Cy.SWRConfig,{value:t},We.createElement(SA.Provider,{value:{value:{organization:n}}},e));function Ay(e){if(!We.useContext(R1)){if(typeof e=="function"){e();return}throw new Error(`${e} can only be used within the <ClerkProvider /> component.

Possible fixes:
1. Ensure that the <ClerkProvider /> is correctly wrapping your application where this component is used.
2. Check for multiple versions of the \`@clerk/shared\` package in your project. Use a tool like \`npm ls @clerk/shared\` to identify multiple versions, and update your dependencies to only rely on one.

Learn more: https://clerk.com/docs/components/clerk-provider`.trim())}}typeof window<"u"?We.useLayoutEffect:We.useEffect;var eb="useUser";function I_(){Ay(eb);const e=wA();return Py().telemetry?.record(x1(eb)),e===void 0?{isLoaded:!1,isSignedIn:void 0,user:void 0}:e===null?{isLoaded:!0,isSignedIn:!1,user:null}:{isLoaded:!0,isSignedIn:!0,user:e}}var ky=()=>(Ay("useClerk"),Py()),tb=Dp,PA=e=>{const n=Ce.useRef(e);return Ce.useEffect(()=>{n.current=e},[e]),n.current},ha=(e,n,t)=>{const a=!!t,i=Ce.useRef(t);Ce.useEffect(()=>{i.current=t},[t]),Ce.useEffect(()=>{if(!a||!e)return()=>{};const l=(...u)=>{i.current&&i.current(...u)};return e.on(n,l),()=>{e.off(n,l)}},[a,n,e,i])},B1=We.createContext(null);B1.displayName="ElementsContext";var AA=(e,n)=>{if(!e)throw new Error(`Could not find Elements context; You need to wrap the part of your app that ${n} in an <Elements> provider.`);return e},b_=e=>e!==null&&typeof e=="object",kA=(e,n,t)=>b_(e)?Object.keys(e).reduce((a,i)=>{const l=!b_(n)||!j1(e[i],n[i]);return t.includes(i)?(l&&console.warn(`Unsupported prop change: options.${i} is not a mutable property.`),a):l?{...a||{},[i]:e[i]}:a},null):null,nb="[object Object]",j1=(e,n)=>{if(!b_(e)||!b_(n))return e===n;const t=Array.isArray(e),a=Array.isArray(n);if(t!==a)return!1;const i=Object.prototype.toString.call(e)===nb,l=Object.prototype.toString.call(n)===nb;if(i!==l)return!1;if(!i&&!t)return e===n;const u=Object.keys(e),d=Object.keys(n);if(u.length!==d.length)return!1;const f={};for(let y=0;y<u.length;y+=1)f[u[y]]=!0;for(let y=0;y<d.length;y+=1)f[d[y]]=!0;const h=Object.keys(f);if(h.length!==u.length)return!1;const _=e,m=n,p=y=>j1(_[y],m[y]);return h.every(p)},rb=e=>{const n=We.useContext(B1);return AA(n,e)},OA=e=>e.charAt(0).toUpperCase()+e.slice(1),$A=(e,n)=>{const t=`${OA(e)}Element`,l=n?u=>{rb(`mounts <${t}>`);const{id:d,className:f}=u;return We.createElement("div",{id:d,className:f})}:({id:u,className:d,fallback:f,options:h={},onBlur:_,onFocus:m,onReady:p,onChange:y,onEscape:v,onClick:x,onLoadError:L,onLoaderStart:T,onNetworksChange:E,onConfirm:I,onCancel:P,onShippingAddressChange:S,onShippingRateChange:k})=>{const C=rb(`mounts <${t}>`),D="elements"in C?C.elements:null,[V,U]=We.useState(null),ne=We.useRef(null),ee=We.useRef(null),[H,oe]=Ce.useState(!1);ha(V,"blur",_),ha(V,"focus",m),ha(V,"escape",v),ha(V,"click",x),ha(V,"loaderror",L),ha(V,"loaderstart",T),ha(V,"networkschange",E),ha(V,"confirm",I),ha(V,"cancel",P),ha(V,"shippingaddresschange",S),ha(V,"shippingratechange",k),ha(V,"change",y);let ae;p&&(ae=()=>{oe(!0),p(V)}),ha(V,"ready",ae),We.useLayoutEffect(()=>{if(ne.current===null&&ee.current!==null&&D){let te=null;D&&(te=D.create(e,h)),ne.current=te,U(te),te&&te.mount(ee.current)}},[D,h]);const W=PA(h);return We.useEffect(()=>{if(!ne.current)return;const te=kA(h,W,["paymentRequest"]);te&&"update"in ne.current&&ne.current.update(te)},[h,W]),We.useLayoutEffect(()=>()=>{if(ne.current&&typeof ne.current.destroy=="function")try{ne.current.destroy(),ne.current=null}catch{}},[]),We.createElement(We.Fragment,null,!H&&f,We.createElement("div",{id:u,style:{height:H?"unset":"0px",visibility:H?"visible":"hidden"},className:d,ref:ee}))};return l.displayName=t,l.__elementType=e,l},DA=typeof window>"u";$A("payment",DA);no("StripeLibsContext");no("PaymentElementContext");no("StripeUtilsContext");var wi=_1({packageName:"@clerk/clerk-react"});function IA(e){wi.setMessages(e).setPackageName(e)}var[LA,zA]=no("AuthContext"),FA=R1,N1=Py,RA="You've added multiple <ClerkProvider> components in your React component tree. Wrap your components in a single <ClerkProvider>.",BA=e=>`You've passed multiple children components to <${e}/>. You can only pass a single child component or text.`,jA="Invalid state. Feel free to submit a bug or reach out to support here: https://clerk.com/support",Ag="Unsupported usage of isSatellite, domain or proxyUrl. The usage of isSatellite, domain or proxyUrl as function is not supported in non-browser environments.",NA="<UserProfile.Page /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.",UA="<UserProfile.Link /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.",VA="<OrganizationProfile.Page /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.",GA="<OrganizationProfile.Link /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.",WA=e=>`<${e} /> can only accept <${e}.Page /> and <${e}.Link /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.`,HA=e=>`Missing props. <${e}.Page /> component requires the following props: url, label, labelIcon, alongside with children to be rendered inside the page.`,KA=e=>`Missing props. <${e}.Link /> component requires the following props: url, label and labelIcon.`,qA="<UserButton /> can only accept <UserButton.UserProfilePage />, <UserButton.UserProfileLink /> and <UserButton.MenuItems /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.",QA="<UserButton.MenuItems /> component can only accept <UserButton.Action /> and <UserButton.Link /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.",XA="<UserButton.MenuItems /> component needs to be a direct child of `<UserButton />`.",YA="<UserButton.Action /> component needs to be a direct child of `<UserButton.MenuItems />`.",ZA="<UserButton.Link /> component needs to be a direct child of `<UserButton.MenuItems />`.",JA="Missing props. <UserButton.Link /> component requires the following props: href, label and labelIcon.",ek="Missing props. <UserButton.Action /> component requires the following props: label.",U1=e=>{Ay(()=>{wi.throwMissingClerkProviderError({source:e})})},V1=e=>new Promise(n=>{const t=a=>{["ready","degraded"].includes(a)&&(n(),e.off("status",t))};e.on("status",t,{notify:!0})}),tk=e=>async n=>(await V1(e),e.session?e.session.getToken(n):null),nk=e=>async(...n)=>(await V1(e),e.signOut(...n)),G1=(e={})=>{var n;U1("useAuth");const{treatPendingAsSignedOut:t,...a}=e??{},i=a;let u=zA();u.sessionId===void 0&&u.userId===void 0&&(u=i??{});const d=N1(),f=Ce.useCallback(tk(d),[d]),h=Ce.useCallback(nk(d),[d]);return(n=d.telemetry)==null||n.record(x1("useAuth",{treatPendingAsSignedOut:t})),rk({...u,getToken:f,signOut:h},{treatPendingAsSignedOut:t})};function rk(e,{treatPendingAsSignedOut:n=!0}={}){const{userId:t,orgId:a,orgRole:i,has:l,signOut:u,getToken:d,orgPermissions:f,factorVerificationAge:h,sessionClaims:_}=e??{},m=Ce.useCallback(y=>l?l(y):M3({userId:t,orgId:a,orgRole:i,orgPermissions:f,factorVerificationAge:h,features:_?.fea||"",plans:_?.pla||""})(y),[l,t,a,i,f,h]),p=x3({authObject:{...e,getToken:d,signOut:u,has:m},options:{treatPendingAsSignedOut:n}});return p||wi.throw(jA)}var fr=(e,n)=>{const a=(typeof n=="string"?n:n?.component)||e.displayName||e.name||"Component";e.displayName=a;const i=typeof n=="string"?void 0:n,l=u=>{U1(a||"withClerk");const d=N1();return!d.loaded&&!i?.renderWhileLoading?null:We.createElement(e,{...u,component:a,clerk:d})};return l.displayName=`withClerk(${a})`,l},sk=()=>{try{return!1}catch{}return!1},ak=()=>{try{return!1}catch{}return!1},ik=()=>{try{return!0}catch{}return!1},sb=new Set,Oy=(e,n,t)=>{const a=ak()||ik(),i=e;sb.has(i)||a||(sb.add(i),console.warn(`Clerk - DEPRECATION WARNING: "${e}" is deprecated and will be removed in the next major release.
${n}`))};fr(({clerk:e,...n})=>{const{client:t,session:a}=e,i=t.signedInSessions?t.signedInSessions.length>0:t.activeSessions&&t.activeSessions.length>0;return We.useEffect(()=>{a===null&&i?e.redirectToAfterSignOut():e.redirectToSignIn(n)},[]),null},"RedirectToSignIn");fr(({clerk:e,...n})=>(We.useEffect(()=>{e.redirectToSignUp(n)},[]),null),"RedirectToSignUp");fr(({clerk:e,...n})=>(We.useEffect(()=>{e.redirectToTasks(n)},[]),null),"RedirectToTasks");fr(({clerk:e})=>(We.useEffect(()=>{Oy("RedirectToUserProfile","Use the `redirectToUserProfile()` method instead."),e.redirectToUserProfile()},[]),null),"RedirectToUserProfile");fr(({clerk:e})=>(We.useEffect(()=>{Oy("RedirectToOrganizationProfile","Use the `redirectToOrganizationProfile()` method instead."),e.redirectToOrganizationProfile()},[]),null),"RedirectToOrganizationProfile");fr(({clerk:e})=>(We.useEffect(()=>{Oy("RedirectToCreateOrganization","Use the `redirectToCreateOrganization()` method instead."),e.redirectToCreateOrganization()},[]),null),"RedirectToCreateOrganization");fr(({clerk:e,...n})=>(We.useEffect(()=>{e.handleRedirectCallback(n)},[]),null),"AuthenticateWithRedirectCallback");var Us=e=>{sk()&&console.error(`Clerk: ${e}`)};function kg(e,n,t){if(typeof e=="function")return e(n);if(typeof e<"u")return e;if(typeof t<"u")return t}var ab=(e,...n)=>{const t={...e};for(const a of n)delete t[a];return t},L_=e=>n=>{try{return We.Children.only(e)}catch{return wi.throw(BA(n))}},z_=(e,n)=>(e||(e=n),typeof e=="string"&&(e=We.createElement("button",null,e)),e),F_=e=>(...n)=>{if(e&&typeof e=="function")return e(...n)};function ok(e){return typeof e=="function"}var Wm=new Map;function lk(e,n,t=1){We.useEffect(()=>{const a=Wm.get(e)||0;return a==t?wi.throw(n):(Wm.set(e,a+1),()=>{Wm.set(e,(Wm.get(e)||1)-1)})},[])}function uk(e,n,t){const a=e.displayName||e.name||n||"Component",i=l=>(lk(n,t),We.createElement(e,{...l}));return i.displayName=`withMaxAllowedInstancesGuard(${a})`,i}var Ip=e=>{const[n,t]=Ce.useState(new Map);return e.map(a=>({id:a.id,mount:i=>t(l=>new Map(l).set(String(a.id),i)),unmount:()=>t(i=>{const l=new Map(i);return l.set(String(a.id),null),l}),portal:()=>{const i=n.get(String(a.id));return i?GP.createPortal(a.component,i):null}}))},Ns=(e,n)=>!!e&&We.isValidElement(e)&&e?.type===n,W1=(e,n)=>q1({children:e,reorderItemsLabels:["account","security"],LinkComponent:Kp,PageComponent:Hp,MenuItemsComponent:B_,componentName:"UserProfile"},n),H1=(e,n)=>q1({children:e,reorderItemsLabels:["general","members"],LinkComponent:N_,PageComponent:j_,componentName:"OrganizationProfile"},n),K1=e=>{const n=[],t=[N_,j_,B_,Hp,Kp];return We.Children.forEach(e,a=>{t.some(i=>Ns(a,i))||n.push(a)}),n},q1=(e,n)=>{const{children:t,LinkComponent:a,PageComponent:i,MenuItemsComponent:l,reorderItemsLabels:u,componentName:d}=e,{allowForAnyChildren:f=!1}=n||{},h=[];We.Children.forEach(t,E=>{if(!Ns(E,i)&&!Ns(E,a)&&!Ns(E,l)){E&&!f&&Us(WA(d));return}const{props:I}=E,{children:P,label:S,url:k,labelIcon:C}=I;if(Ns(E,i))if(ib(I,u))h.push({label:S});else if(Og(I))h.push({label:S,labelIcon:C,children:P,url:k});else{Us(HA(d));return}if(Ns(E,a))if($g(I))h.push({label:S,labelIcon:C,url:k});else{Us(KA(d));return}});const _=[],m=[],p=[];h.forEach((E,I)=>{if(Og(E)){_.push({component:E.children,id:I}),m.push({component:E.labelIcon,id:I});return}$g(E)&&p.push({component:E.labelIcon,id:I})});const y=Ip(_),v=Ip(m),x=Ip(p),L=[],T=[];return h.forEach((E,I)=>{if(ib(E,u)){L.push({label:E.label});return}if(Og(E)){const{portal:P,mount:S,unmount:k}=y.find(U=>U.id===I),{portal:C,mount:D,unmount:V}=v.find(U=>U.id===I);L.push({label:E.label,url:E.url,mount:S,unmount:k,mountIcon:D,unmountIcon:V}),T.push(P),T.push(C);return}if($g(E)){const{portal:P,mount:S,unmount:k}=x.find(C=>C.id===I);L.push({label:E.label,url:E.url,mountIcon:S,unmountIcon:k}),T.push(P);return}}),{customPages:L,customPagesPortals:T}},ib=(e,n)=>{const{children:t,label:a,url:i,labelIcon:l}=e;return!t&&!i&&!l&&n.some(u=>u===a)},Og=e=>{const{children:n,label:t,url:a,labelIcon:i}=e;return!!n&&!!a&&!!i&&!!t},$g=e=>{const{children:n,label:t,url:a,labelIcon:i}=e;return!n&&!!a&&!!i&&!!t},ck=(e,n)=>{var t;return dk({children:e,reorderItemsLabels:["manageAccount","signOut"],MenuItemsComponent:B_,MenuActionComponent:X1,MenuLinkComponent:Y1,UserProfileLinkComponent:Kp,UserProfilePageComponent:Hp,allowForAnyChildren:(t=n?.allowForAnyChildren)!=null?t:!1})},dk=({children:e,MenuItemsComponent:n,MenuActionComponent:t,MenuLinkComponent:a,UserProfileLinkComponent:i,UserProfilePageComponent:l,reorderItemsLabels:u,allowForAnyChildren:d=!1})=>{const f=[],h=[],_=[];We.Children.forEach(e,x=>{if(!Ns(x,n)&&!Ns(x,i)&&!Ns(x,l)){x&&!d&&Us(qA);return}if(Ns(x,i)||Ns(x,l))return;const{props:L}=x;We.Children.forEach(L.children,T=>{if(!Ns(T,t)&&!Ns(T,a)){T&&Us(QA);return}const{props:E}=T,{label:I,labelIcon:P,href:S,onClick:k,open:C}=E;if(Ns(T,t))if(ob(E,u))f.push({label:I});else if(Dg(E)){const D={label:I,labelIcon:P};if(k!==void 0)f.push({...D,onClick:k});else if(C!==void 0)f.push({...D,open:C.startsWith("/")?C:`/${C}`});else{Us("Custom menu item must have either onClick or open property");return}}else{Us(ek);return}if(Ns(T,a))if(Ig(E))f.push({label:I,labelIcon:P,href:S});else{Us(JA);return}})});const m=[],p=[];f.forEach((x,L)=>{Dg(x)&&m.push({component:x.labelIcon,id:L}),Ig(x)&&p.push({component:x.labelIcon,id:L})});const y=Ip(m),v=Ip(p);return f.forEach((x,L)=>{if(ob(x,u)&&h.push({label:x.label}),Dg(x)){const{portal:T,mount:E,unmount:I}=y.find(S=>S.id===L),P={label:x.label,mountIcon:E,unmountIcon:I};"onClick"in x?P.onClick=x.onClick:"open"in x&&(P.open=x.open),h.push(P),_.push(T)}if(Ig(x)){const{portal:T,mount:E,unmount:I}=v.find(P=>P.id===L);h.push({label:x.label,href:x.href,mountIcon:E,unmountIcon:I}),_.push(T)}}),{customMenuItems:h,customMenuItemsPortals:_}},ob=(e,n)=>{const{children:t,label:a,onClick:i,labelIcon:l}=e;return!t&&!i&&!l&&n.some(u=>u===a)},Dg=e=>{const{label:n,labelIcon:t,onClick:a,open:i}=e;return!!t&&!!n&&(typeof a=="function"||typeof i=="string")},Ig=e=>{const{label:n,href:t,labelIcon:a}=e;return!!t&&!!a&&!!n},fk=e=>{const n=e?.isReady;return t=>new Promise((a,i)=>{const{root:l=document?.body,selector:u,timeout:d=0}=t;if(!l){i(new Error("No root element provided"));return}let f=l;if(u&&(f=l?.querySelector(u)),n(f,u)){a();return}const h=new MutationObserver(_=>{for(const m of _)if(!f&&u&&(f=l?.querySelector(u)),(e.childList&&m.type==="childList"||e.attributes&&m.type==="attributes")&&n(f,u)){h.disconnect(),a();return}});h.observe(l,e),d>0&&setTimeout(()=>{h.disconnect(),i(new Error(`Timeout waiting for ${u}`))},d)})},hk=fk({childList:!0,subtree:!0,isReady:(e,n)=>{var t;return!!e?.childElementCount&&((t=e?.matches)==null?void 0:t.call(e,n))&&e.childElementCount>0}});function Ys(e,n){const t=Ce.useRef(),[a,i]=Ce.useState("rendering");return Ce.useEffect(()=>{if(!e)throw new Error("Clerk: no component name provided, unable to detect mount.");if(typeof window<"u"&&!t.current){const l=`[data-clerk-component="${e}"]`,u=n?.selector;t.current=hk({selector:u?l+u:l}).then(()=>{i("rendered")}).catch(()=>{i("error")})}},[e,n?.selector]),a}var Hm=e=>"mount"in e,lb=e=>"open"in e,ub=e=>e?.map(({mountIcon:n,unmountIcon:t,...a})=>a),Ts=class extends We.PureComponent{constructor(){super(...arguments),this.rootRef=We.createRef()}componentDidUpdate(e){var n,t,a,i;if(!Hm(e)||!Hm(this.props))return;const l=ab(e.props,"customPages","customMenuItems","children"),u=ab(this.props.props,"customPages","customMenuItems","children"),d=((n=l.customPages)==null?void 0:n.length)!==((t=u.customPages)==null?void 0:t.length),f=((a=l.customMenuItems)==null?void 0:a.length)!==((i=u.customMenuItems)==null?void 0:i.length),h=ub(e.props.customMenuItems),_=ub(this.props.props.customMenuItems);(!tb(l,u)||!tb(h,_)||d||f)&&this.rootRef.current&&this.props.updateProps({node:this.rootRef.current,props:this.props.props})}componentDidMount(){this.rootRef.current&&(Hm(this.props)&&this.props.mount(this.rootRef.current,this.props.props),lb(this.props)&&this.props.open(this.props.props))}componentWillUnmount(){this.rootRef.current&&(Hm(this.props)&&this.props.unmount(this.rootRef.current),lb(this.props)&&this.props.close())}render(){const{hideRootHtmlElement:e=!1}=this.props,n={ref:this.rootRef,...this.props.rootProps,...this.props.component&&{"data-clerk-component":this.props.component}};return We.createElement(We.Fragment,null,!e&&We.createElement("div",{...n}),this.props.children)}},R_=e=>{var n,t;return We.createElement(We.Fragment,null,(n=e?.customPagesPortals)==null?void 0:n.map((a,i)=>Ce.createElement(a,{key:i})),(t=e?.customMenuItemsPortals)==null?void 0:t.map((a,i)=>Ce.createElement(a,{key:i})))};fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}};return We.createElement(We.Fragment,null,l&&t,e.loaded&&We.createElement(Ts,{component:n,mount:e.mountSignIn,unmount:e.unmountSignIn,updateProps:e.__unstable__updateProps,props:a,rootProps:u}))},{component:"SignIn",renderWhileLoading:!0});fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}};return We.createElement(We.Fragment,null,l&&t,e.loaded&&We.createElement(Ts,{component:n,mount:e.mountSignUp,unmount:e.unmountSignUp,updateProps:e.__unstable__updateProps,props:a,rootProps:u}))},{component:"SignUp",renderWhileLoading:!0});function Hp({children:e}){return Us(NA),We.createElement(We.Fragment,null,e)}function Kp({children:e}){return Us(UA),We.createElement(We.Fragment,null,e)}var pk=fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}},{customPages:d,customPagesPortals:f}=W1(a.children);return We.createElement(We.Fragment,null,l&&t,We.createElement(Ts,{component:n,mount:e.mountUserProfile,unmount:e.unmountUserProfile,updateProps:e.__unstable__updateProps,props:{...a,customPages:d},rootProps:u},We.createElement(R_,{customPagesPortals:f})))},{component:"UserProfile",renderWhileLoading:!0});Object.assign(pk,{Page:Hp,Link:Kp});var Q1=Ce.createContext({mount:()=>{},unmount:()=>{},updateProps:()=>{}}),mk=fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}},{customPages:d,customPagesPortals:f}=W1(a.children,{allowForAnyChildren:!!a.__experimental_asProvider}),h=Object.assign(a.userProfileProps||{},{customPages:d}),{customMenuItems:_,customMenuItemsPortals:m}=ck(a.children,{allowForAnyChildren:!!a.__experimental_asProvider}),p=K1(a.children),y={mount:e.mountUserButton,unmount:e.unmountUserButton,updateProps:e.__unstable__updateProps,props:{...a,userProfileProps:h,customMenuItems:_}},v={customPagesPortals:f,customMenuItemsPortals:m};return We.createElement(Q1.Provider,{value:y},l&&t,e.loaded&&We.createElement(Ts,{component:n,...y,hideRootHtmlElement:!!a.__experimental_asProvider,rootProps:u},a.__experimental_asProvider?p:null,We.createElement(R_,{...v})))},{component:"UserButton",renderWhileLoading:!0});function B_({children:e}){return Us(XA),We.createElement(We.Fragment,null,e)}function X1({children:e}){return Us(YA),We.createElement(We.Fragment,null,e)}function Y1({children:e}){return Us(ZA),We.createElement(We.Fragment,null,e)}function _k(e){const n=Ce.useContext(Q1),t={...n,props:{...n.props,...e}};return We.createElement(Ts,{...t})}var gk=Object.assign(mk,{UserProfilePage:Hp,UserProfileLink:Kp,MenuItems:B_,Action:X1,Link:Y1,__experimental_Outlet:_k});function j_({children:e}){return Us(VA),We.createElement(We.Fragment,null,e)}function N_({children:e}){return Us(GA),We.createElement(We.Fragment,null,e)}var yk=fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}},{customPages:d,customPagesPortals:f}=H1(a.children);return We.createElement(We.Fragment,null,l&&t,e.loaded&&We.createElement(Ts,{component:n,mount:e.mountOrganizationProfile,unmount:e.unmountOrganizationProfile,updateProps:e.__unstable__updateProps,props:{...a,customPages:d},rootProps:u},We.createElement(R_,{customPagesPortals:f})))},{component:"OrganizationProfile",renderWhileLoading:!0});Object.assign(yk,{Page:j_,Link:N_});fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}};return We.createElement(We.Fragment,null,l&&t,e.loaded&&We.createElement(Ts,{component:n,mount:e.mountCreateOrganization,unmount:e.unmountCreateOrganization,updateProps:e.__unstable__updateProps,props:a,rootProps:u}))},{component:"CreateOrganization",renderWhileLoading:!0});var Z1=Ce.createContext({mount:()=>{},unmount:()=>{},updateProps:()=>{}}),vk=fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}},{customPages:d,customPagesPortals:f}=H1(a.children,{allowForAnyChildren:!!a.__experimental_asProvider}),h=Object.assign(a.organizationProfileProps||{},{customPages:d}),_=K1(a.children),m={mount:e.mountOrganizationSwitcher,unmount:e.unmountOrganizationSwitcher,updateProps:e.__unstable__updateProps,props:{...a,organizationProfileProps:h},rootProps:u,component:n};return e.__experimental_prefetchOrganizationSwitcher(),We.createElement(Z1.Provider,{value:m},We.createElement(We.Fragment,null,l&&t,e.loaded&&We.createElement(Ts,{...m,hideRootHtmlElement:!!a.__experimental_asProvider},a.__experimental_asProvider?_:null,We.createElement(R_,{customPagesPortals:f}))))},{component:"OrganizationSwitcher",renderWhileLoading:!0});function bk(e){const n=Ce.useContext(Z1),t={...n,props:{...n.props,...e}};return We.createElement(Ts,{...t})}Object.assign(vk,{OrganizationProfilePage:j_,OrganizationProfileLink:N_,__experimental_Outlet:bk});fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}};return We.createElement(We.Fragment,null,l&&t,e.loaded&&We.createElement(Ts,{component:n,mount:e.mountOrganizationList,unmount:e.unmountOrganizationList,updateProps:e.__unstable__updateProps,props:a,rootProps:u}))},{component:"OrganizationList",renderWhileLoading:!0});fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}};return We.createElement(We.Fragment,null,l&&t,e.loaded&&We.createElement(Ts,{component:n,open:e.openGoogleOneTap,close:e.closeGoogleOneTap,updateProps:e.__unstable__updateProps,props:a,rootProps:u}))},{component:"GoogleOneTap",renderWhileLoading:!0});fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}};return We.createElement(We.Fragment,null,l&&t,e.loaded&&We.createElement(Ts,{component:n,mount:e.mountWaitlist,unmount:e.unmountWaitlist,updateProps:e.__unstable__updateProps,props:a,rootProps:u}))},{component:"Waitlist",renderWhileLoading:!0});fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n,{selector:'[data-component-status="ready"]'})==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}};return We.createElement(We.Fragment,null,l&&t,e.loaded&&We.createElement(Ts,{component:n,mount:e.mountPricingTable,unmount:e.unmountPricingTable,updateProps:e.__unstable__updateProps,props:a,rootProps:u}))},{component:"PricingTable",renderWhileLoading:!0});fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}};return We.createElement(We.Fragment,null,l&&t,e.loaded&&We.createElement(Ts,{component:n,mount:e.mountApiKeys,unmount:e.unmountApiKeys,updateProps:e.__unstable__updateProps,props:a,rootProps:u}))},{component:"ApiKeys",renderWhileLoading:!0});fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}};return We.createElement(We.Fragment,null,l&&t,e.loaded&&We.createElement(Ts,{component:n,mount:e.mountUserAvatar,unmount:e.unmountUserAvatar,updateProps:e.__unstable__updateProps,props:a,rootProps:u}))},{component:"UserAvatar",renderWhileLoading:!0});fr(({clerk:e,component:n,fallback:t,...a})=>{const l=Ys(n)==="rendering"||!e.loaded,u={...l&&t&&{style:{display:"none"}}};return We.createElement(We.Fragment,null,l&&t,e.loaded&&We.createElement(Ts,{component:n,mount:e.mountTaskChooseOrganization,unmount:e.unmountTaskChooseOrganization,updateProps:e.__unstable__updateProps,props:a,rootProps:u}))},{component:"TaskChooseOrganization",renderWhileLoading:!0});var J1=e=>{throw TypeError(e)},$y=(e,n,t)=>n.has(e)||J1("Cannot "+t),xr=(e,n,t)=>($y(e,n,"read from private field"),t?t.call(e):n.get(e)),Ul=(e,n,t)=>n.has(e)?J1("Cannot add the same private member more than once"):n instanceof WeakSet?n.add(e):n.set(e,t),fc=(e,n,t,a)=>($y(e,n,"write to private field"),n.set(e,t),t),Lg=(e,n,t)=>($y(e,n,"access private method"),t),wk=(e,n="5.96.0")=>{if(e)return e;const t=Mk(n);return t?t==="snapshot"?"5.96.0":t:xk(n)},Mk=e=>e.trim().replace(/^v/,"").match(/-(.+?)(\.|$)/)?.[1],xk=e=>e.trim().replace(/^v/,"").split(".")[0];function Tk(e){return e?Ek(e)||ex(e):!0}function Ek(e){return/^http(s)?:\/\//.test(e||"")}function ex(e){return e.startsWith("/")}function Sk(e){return e?ex(e)?new URL(e,window.location.origin).toString():e:""}function Ck(e){if(!e)return"";let n;if(e.match(/^(clerk\.)+\w*$/))n=/(clerk\.)*(?=clerk\.)/;else{if(e.match(/\.clerk.accounts/))return e;n=/^(clerk\.)*/gi}return`clerk.${e.replace(n,"")}`}var Pk={initialDelay:125,maxDelayBetweenRetries:0,factor:2,shouldRetry:(e,n)=>n<5,retryImmediately:!1,jitter:!0},Ak=100,tx=async e=>new Promise(n=>setTimeout(n,e)),nx=(e,n)=>n?e*(1+Math.random()):e,kk=e=>{let n=0;const t=()=>{const a=e.initialDelay,i=e.factor;let l=a*Math.pow(i,n);return l=nx(l,e.jitter),Math.min(e.maxDelayBetweenRetries||l,l)};return async()=>{await tx(t()),n++}},Ok=async(e,n={})=>{let t=0;const{shouldRetry:a,initialDelay:i,maxDelayBetweenRetries:l,factor:u,retryImmediately:d,jitter:f,onBeforeRetry:h}={...Pk,...n},_=kk({initialDelay:i,maxDelayBetweenRetries:l,factor:u,jitter:f});for(;;)try{return await e()}catch(m){if(t++,!a(m,t))throw m;h&&await h(t),d&&t===1?await tx(nx(Ak,f)):await _()}},$k="loadScript cannot be called when document does not exist",Dk="loadScript cannot be called without a src";async function Ik(e="",n){const{async:t,defer:a,beforeLoad:i,crossOrigin:l,nonce:u}=n||{};return Ok(()=>new Promise((f,h)=>{e||h(new Error(Dk)),(!document||!document.body)&&h(new Error($k));const _=document.createElement("script");l&&_.setAttribute("crossorigin",l),_.async=t||!1,_.defer=a||!1,_.addEventListener("load",()=>{_.remove(),f(_)}),_.addEventListener("error",m=>{_.remove(),h(m.error??new Error(`failed to load script: ${e}`))}),_.src=e,_.nonce=u,i?.(_),document.body.appendChild(_)}),{shouldRetry:(f,h)=>h<=5})}var Lk="failed_to_load_clerk_js",zk="failed_to_load_clerk_js_timeout",rx="Failed to load Clerk",{isDevOrStagingUrl:Fk}=S3(),sx=_1({packageName:"@clerk/shared"});function Rk(e){sx.setPackageName({packageName:e})}function ey(){if(typeof window>"u"||!window.Clerk)return!1;const e=window.Clerk;return typeof e=="object"&&typeof e.load=="function"}function cb(e){return new Promise((n,t)=>{let a=!1;const i=(h,_)=>{clearTimeout(h),clearInterval(_)},l=()=>{a||ey()&&(a=!0,i(d,f),n(null))},d=setTimeout(()=>{a||(a=!0,i(d,f),ey()?n(null):t(new g1(rx,{code:zk})))},e);l();const f=setInterval(()=>{if(a){clearInterval(f);return}l()},100)})}var Bk=async e=>{const n=e?.scriptLoadTimeout??15e3;if(ey())return null;if(document.querySelector("script[data-clerk-js-script]"))return cb(n);if(!e?.publishableKey)return sx.throwMissingPublishableKeyError(),null;const a=cb(n);return Ik(jk(e),{async:!0,crossOrigin:"anonymous",nonce:e.nonce,beforeLoad:Uk(e)}).catch(i=>{throw new g1(rx+(i.message?`, ${i.message}`:""),{code:Lk,cause:i})}),a},jk=e=>{const{clerkJSUrl:n,clerkJSVariant:t,clerkJSVersion:a,proxyUrl:i,domain:l,publishableKey:u}=e;if(n)return n;let d="";i&&Tk(i)?d=Sk(i).replace(/http(s)?:\/\//,""):l&&!Fk(Uv(u)?.frontendApi||"")?d=Ck(l):d=Uv(u)?.frontendApi||"";const f=t?`${t.replace(/\.+$/,"")}.`:"",h=wk(a);return`https://${d}/npm/@clerk/clerk-js@${h}/dist/clerk.${f}browser.js`},Nk=e=>{const n={};return e.publishableKey&&(n["data-clerk-publishable-key"]=e.publishableKey),e.proxyUrl&&(n["data-clerk-proxy-url"]=e.proxyUrl),e.domain&&(n["data-clerk-domain"]=e.domain),e.nonce&&(n.nonce=e.nonce),n},Uk=e=>n=>{const t=Nk(e);for(const a in t)n.setAttribute(a,t[a])},Vk=(e,n,t)=>!e&&t?Gk(t):Wk(n),Gk=e=>{const n=e.userId,t=e.user,a=e.sessionId,i=e.sessionStatus,l=e.sessionClaims,u=e.session,d=e.organization,f=e.orgId,h=e.orgRole,_=e.orgPermissions,m=e.orgSlug,p=e.actor,y=e.factorVerificationAge;return{userId:n,user:t,sessionId:a,session:u,sessionStatus:i,sessionClaims:l,organization:d,orgId:f,orgRole:h,orgPermissions:_,orgSlug:m,actor:p,factorVerificationAge:y}},Wk=e=>{const n=e.user?e.user.id:e.user,t=e.user,a=e.session?e.session.id:e.session,i=e.session,l=e.session?.status,u=e.session?e.session.lastActiveToken?.jwt?.claims:null,d=e.session?e.session.factorVerificationAge:null,f=i?.actor,h=e.organization,_=e.organization?e.organization.id:e.organization,m=h?.slug,p=h&&t?.organizationMemberships?.find(x=>x.organization.id===_),y=p&&p.permissions,v=p&&p.role;return{userId:n,user:t,sessionId:a,session:i,sessionStatus:l,sessionClaims:u,organization:h,orgId:_,orgRole:v,orgSlug:m,orgPermissions:y,actor:f,factorVerificationAge:d}};function w_(){return typeof window<"u"}var db=(e,n,t,a,i)=>{const{notify:l}=i||{};let u=e.get(t);u||(u=[],e.set(t,u)),u.push(a),l&&n.has(t)&&a(n.get(t))},fb=(e,n,t)=>(e.get(n)||[]).map(a=>a(t)),hb=(e,n,t)=>{const a=e.get(n);a&&(t?a.splice(a.indexOf(t)>>>0,1):e.set(n,[]))},Hk=()=>{const e=new Map,n=new Map,t=new Map;return{on:(...i)=>db(e,n,...i),prioritizedOn:(...i)=>db(t,n,...i),emit:(i,l)=>{n.set(i,l),fb(t,i,l),fb(e,i,l)},off:(...i)=>hb(e,...i),prioritizedOff:(...i)=>hb(t,...i),internal:{retrieveListeners:i=>e.get(i)||[]}}},Km={Status:"status"},Kk=()=>Hk();typeof window<"u"&&!window.global&&(window.global=typeof global>"u"?window:global);fr(({clerk:e,children:n,...t})=>{const{signUpFallbackRedirectUrl:a,forceRedirectUrl:i,fallbackRedirectUrl:l,signUpForceRedirectUrl:u,mode:d,initialValues:f,withSignUp:h,oauthFlow:_,...m}=t;n=z_(n,"Sign in");const p=L_(n)("SignInButton"),y=()=>{const L={forceRedirectUrl:i,fallbackRedirectUrl:l,signUpFallbackRedirectUrl:a,signUpForceRedirectUrl:u,initialValues:f,withSignUp:h,oauthFlow:_};return d==="modal"?e.openSignIn({...L,appearance:t.appearance}):e.redirectToSignIn({...L,signInFallbackRedirectUrl:l,signInForceRedirectUrl:i})},x={...m,onClick:async L=>(p&&typeof p=="object"&&"props"in p&&await F_(p.props.onClick)(L),y())};return We.cloneElement(p,x)},{component:"SignInButton",renderWhileLoading:!0});fr(({clerk:e,children:n,...t})=>{const{redirectUrl:a,...i}=t;n=z_(n,"Sign in with Metamask");const l=L_(n)("SignInWithMetamaskButton"),u=async()=>{async function h(){await e.authenticateWithMetamask({redirectUrl:a||void 0})}h()},f={...i,onClick:async h=>(await F_(l.props.onClick)(h),u())};return We.cloneElement(l,f)},{component:"SignInWithMetamask",renderWhileLoading:!0});fr(({clerk:e,children:n,...t})=>{const{redirectUrl:a="/",signOutOptions:i,...l}=t;n=z_(n,"Sign out");const u=L_(n)("SignOutButton"),d=()=>e.signOut({redirectUrl:a,...i}),h={...l,onClick:async _=>(await F_(u.props.onClick)(_),d())};return We.cloneElement(u,h)},{component:"SignOutButton",renderWhileLoading:!0});fr(({clerk:e,children:n,...t})=>{const{fallbackRedirectUrl:a,forceRedirectUrl:i,signInFallbackRedirectUrl:l,signInForceRedirectUrl:u,mode:d,initialValues:f,oauthFlow:h,..._}=t;n=z_(n,"Sign up");const m=L_(n)("SignUpButton"),p=()=>{const x={fallbackRedirectUrl:a,forceRedirectUrl:i,signInFallbackRedirectUrl:l,signInForceRedirectUrl:u,initialValues:f,oauthFlow:h};return d==="modal"?e.openSignUp({...x,appearance:t.appearance,unsafeMetadata:t.unsafeMetadata}):e.redirectToSignUp({...x,signUpFallbackRedirectUrl:a,signUpForceRedirectUrl:i})},v={..._,onClick:async x=>(m&&typeof m=="object"&&"props"in m&&await F_(m.props.onClick)(x),p())};return We.cloneElement(m,v)},{component:"SignUpButton",renderWhileLoading:!0});var pb=()=>({fields:{firstName:null,lastName:null,emailAddress:null,identifier:null,phoneNumber:null,password:null,username:null,code:null,captcha:null,legalAccepted:null},raw:null,global:null}),qk=class{constructor(e){this.isomorphicClerk=e,this.signInSignalProxy=this.buildSignInProxy(),this.signUpSignalProxy=this.buildSignUpProxy()}signInSignal(){return this.signInSignalProxy}signUpSignal(){return this.signUpSignalProxy}buildSignInProxy(){const e=this.gateProperty.bind(this),n=()=>this.client.signIn.__internal_future;return{errors:pb(),fetchStatus:"idle",signIn:{status:"needs_identifier",availableStrategies:[],isTransferable:!1,get firstFactorVerification(){return e(n,"firstFactorVerification",{status:null,error:null,expireAt:null,externalVerificationRedirectURL:null,nonce:null,attempts:null,message:null,strategy:null,verifiedAtClient:null,verifiedFromTheSameClient:()=>!1,__internal_toSnapshot:()=>{throw new Error("__internal_toSnapshot called before Clerk is loaded")},pathRoot:"",reload:()=>{throw new Error("__internal_toSnapshot called before Clerk is loaded")}})},create:this.gateMethod(n,"create"),password:this.gateMethod(n,"password"),sso:this.gateMethod(n,"sso"),finalize:this.gateMethod(n,"finalize"),emailCode:this.wrapMethods(()=>n().emailCode,["sendCode","verifyCode"]),emailLink:this.wrapStruct(()=>n().emailLink,["sendLink","waitForVerification"],["verification"],{verification:null}),resetPasswordEmailCode:this.wrapMethods(()=>n().resetPasswordEmailCode,["sendCode","verifyCode","submitPassword"]),phoneCode:this.wrapMethods(()=>n().phoneCode,["sendCode","verifyCode"]),mfa:this.wrapMethods(()=>n().mfa,["sendPhoneCode","verifyPhoneCode","verifyTOTP","verifyBackupCode"]),ticket:this.gateMethod(n,"ticket")}}}buildSignUpProxy(){const e=this.gateProperty.bind(this),n=this.gateMethod.bind(this),t=this.wrapMethods.bind(this),a=()=>this.client.signUp.__internal_future;return{errors:pb(),fetchStatus:"idle",signUp:{get status(){return e(a,"status","missing_requirements")},get unverifiedFields(){return e(a,"unverifiedFields",[])},get isTransferable(){return e(a,"isTransferable",!1)},create:n(a,"create"),update:n(a,"update"),sso:n(a,"sso"),password:n(a,"password"),ticket:n(a,"ticket"),finalize:n(a,"finalize"),verifications:t(()=>a().verifications,["sendEmailCode","verifyEmailCode","sendPhoneCode","verifyPhoneCode"])}}}__internal_effect(e){throw new Error("__internal_effect called before Clerk is loaded")}__internal_computed(e){throw new Error("__internal_computed called before Clerk is loaded")}get client(){const e=this.isomorphicClerk.client;if(!e)throw new Error("Clerk client not ready");return e}gateProperty(e,n,t){return!w_()||!this.isomorphicClerk.loaded?t:e()[n]}gateMethod(e,n){return async(...t)=>{if(!w_())return wi.throw(`Attempted to call a method (${n}) that is not supported on the server.`);this.isomorphicClerk.loaded||await new Promise(i=>this.isomorphicClerk.addOnLoaded(i));const a=e();return a[n].apply(a,t)}}wrapMethods(e,n){return Object.fromEntries(n.map(t=>[t,this.gateMethod(e,t)]))}wrapStruct(e,n,t,a){const i={};for(const l of n)i[l]=this.gateMethod(e,l);for(const l of t)Object.defineProperty(i,l,{get:()=>this.gateProperty(e,l,a[l]),enumerable:!0});return i}};typeof globalThis.__BUILD_DISABLE_RHC__>"u"&&(globalThis.__BUILD_DISABLE_RHC__=!1);var Qk={name:"@clerk/clerk-react",version:"5.49.0",environment:"production"},c_,Jd,ef,Vl,Uo,d_,Wl,Cp,f_,ax=class ix{constructor(n){Ul(this,Cp),this.clerkjs=null,this.preopenOneTap=null,this.preopenUserVerification=null,this.preopenSignIn=null,this.preopenCheckout=null,this.preopenPlanDetails=null,this.preopenSubscriptionDetails=null,this.preopenSignUp=null,this.preopenUserProfile=null,this.preopenOrganizationProfile=null,this.preopenCreateOrganization=null,this.preOpenWaitlist=null,this.premountSignInNodes=new Map,this.premountSignUpNodes=new Map,this.premountUserAvatarNodes=new Map,this.premountUserProfileNodes=new Map,this.premountUserButtonNodes=new Map,this.premountOrganizationProfileNodes=new Map,this.premountCreateOrganizationNodes=new Map,this.premountOrganizationSwitcherNodes=new Map,this.premountOrganizationListNodes=new Map,this.premountMethodCalls=new Map,this.premountWaitlistNodes=new Map,this.premountPricingTableNodes=new Map,this.premountApiKeysNodes=new Map,this.premountOAuthConsentNodes=new Map,this.premountTaskChooseOrganizationNodes=new Map,this.premountAddListenerCalls=new Map,this.loadedListeners=[],Ul(this,c_,"loading"),Ul(this,Jd),Ul(this,ef),Ul(this,Vl),Ul(this,Uo,Kk()),Ul(this,d_),this.buildSignInUrl=i=>{const l=()=>{var u;return((u=this.clerkjs)==null?void 0:u.buildSignInUrl(i))||""};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("buildSignInUrl",l)},this.buildSignUpUrl=i=>{const l=()=>{var u;return((u=this.clerkjs)==null?void 0:u.buildSignUpUrl(i))||""};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("buildSignUpUrl",l)},this.buildAfterSignInUrl=(...i)=>{const l=()=>{var u;return((u=this.clerkjs)==null?void 0:u.buildAfterSignInUrl(...i))||""};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("buildAfterSignInUrl",l)},this.buildAfterSignUpUrl=(...i)=>{const l=()=>{var u;return((u=this.clerkjs)==null?void 0:u.buildAfterSignUpUrl(...i))||""};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("buildAfterSignUpUrl",l)},this.buildAfterSignOutUrl=()=>{const i=()=>{var l;return((l=this.clerkjs)==null?void 0:l.buildAfterSignOutUrl())||""};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("buildAfterSignOutUrl",i)},this.buildNewSubscriptionRedirectUrl=()=>{const i=()=>{var l;return((l=this.clerkjs)==null?void 0:l.buildNewSubscriptionRedirectUrl())||""};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("buildNewSubscriptionRedirectUrl",i)},this.buildAfterMultiSessionSingleSignOutUrl=()=>{const i=()=>{var l;return((l=this.clerkjs)==null?void 0:l.buildAfterMultiSessionSingleSignOutUrl())||""};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("buildAfterMultiSessionSingleSignOutUrl",i)},this.buildUserProfileUrl=()=>{const i=()=>{var l;return((l=this.clerkjs)==null?void 0:l.buildUserProfileUrl())||""};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("buildUserProfileUrl",i)},this.buildCreateOrganizationUrl=()=>{const i=()=>{var l;return((l=this.clerkjs)==null?void 0:l.buildCreateOrganizationUrl())||""};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("buildCreateOrganizationUrl",i)},this.buildOrganizationProfileUrl=()=>{const i=()=>{var l;return((l=this.clerkjs)==null?void 0:l.buildOrganizationProfileUrl())||""};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("buildOrganizationProfileUrl",i)},this.buildWaitlistUrl=()=>{const i=()=>{var l;return((l=this.clerkjs)==null?void 0:l.buildWaitlistUrl())||""};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("buildWaitlistUrl",i)},this.buildTasksUrl=()=>{const i=()=>{var l;return((l=this.clerkjs)==null?void 0:l.buildTasksUrl())||""};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("buildTasksUrl",i)},this.buildUrlWithAuth=i=>{const l=()=>{var u;return((u=this.clerkjs)==null?void 0:u.buildUrlWithAuth(i))||""};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("buildUrlWithAuth",l)},this.handleUnauthenticated=async()=>{const i=()=>{var l;return(l=this.clerkjs)==null?void 0:l.handleUnauthenticated()};this.clerkjs&&this.loaded?i():this.premountMethodCalls.set("handleUnauthenticated",i)},this.on=(...i)=>{var l;if((l=this.clerkjs)!=null&&l.on)return this.clerkjs.on(...i);xr(this,Uo).on(...i)},this.off=(...i)=>{var l;if((l=this.clerkjs)!=null&&l.off)return this.clerkjs.off(...i);xr(this,Uo).off(...i)},this.addOnLoaded=i=>{this.loadedListeners.push(i),this.loaded&&this.emitLoaded()},this.emitLoaded=()=>{this.loadedListeners.forEach(i=>i()),this.loadedListeners=[]},this.beforeLoad=i=>{if(!i)throw new Error("Failed to hydrate latest Clerk JS")},this.hydrateClerkJS=i=>{var l;if(!i)throw new Error("Failed to hydrate latest Clerk JS");return this.clerkjs=i,this.premountMethodCalls.forEach(u=>u()),this.premountAddListenerCalls.forEach((u,d)=>{u.nativeUnsubscribe=i.addListener(d)}),(l=xr(this,Uo).internal.retrieveListeners("status"))==null||l.forEach(u=>{this.on("status",u,{notify:!0})}),this.preopenSignIn!==null&&i.openSignIn(this.preopenSignIn),this.preopenCheckout!==null&&i.__internal_openCheckout(this.preopenCheckout),this.preopenPlanDetails!==null&&i.__internal_openPlanDetails(this.preopenPlanDetails),this.preopenSubscriptionDetails!==null&&i.__internal_openSubscriptionDetails(this.preopenSubscriptionDetails),this.preopenSignUp!==null&&i.openSignUp(this.preopenSignUp),this.preopenUserProfile!==null&&i.openUserProfile(this.preopenUserProfile),this.preopenUserVerification!==null&&i.__internal_openReverification(this.preopenUserVerification),this.preopenOneTap!==null&&i.openGoogleOneTap(this.preopenOneTap),this.preopenOrganizationProfile!==null&&i.openOrganizationProfile(this.preopenOrganizationProfile),this.preopenCreateOrganization!==null&&i.openCreateOrganization(this.preopenCreateOrganization),this.preOpenWaitlist!==null&&i.openWaitlist(this.preOpenWaitlist),this.premountSignInNodes.forEach((u,d)=>{i.mountSignIn(d,u)}),this.premountSignUpNodes.forEach((u,d)=>{i.mountSignUp(d,u)}),this.premountUserProfileNodes.forEach((u,d)=>{i.mountUserProfile(d,u)}),this.premountUserAvatarNodes.forEach((u,d)=>{i.mountUserAvatar(d,u)}),this.premountUserButtonNodes.forEach((u,d)=>{i.mountUserButton(d,u)}),this.premountOrganizationListNodes.forEach((u,d)=>{i.mountOrganizationList(d,u)}),this.premountWaitlistNodes.forEach((u,d)=>{i.mountWaitlist(d,u)}),this.premountPricingTableNodes.forEach((u,d)=>{i.mountPricingTable(d,u)}),this.premountApiKeysNodes.forEach((u,d)=>{i.mountApiKeys(d,u)}),this.premountOAuthConsentNodes.forEach((u,d)=>{i.__internal_mountOAuthConsent(d,u)}),this.premountTaskChooseOrganizationNodes.forEach((u,d)=>{i.mountTaskChooseOrganization(d,u)}),typeof this.clerkjs.status>"u"&&xr(this,Uo).emit(Km.Status,"ready"),this.emitLoaded(),this.clerkjs},this.__experimental_checkout=(...i)=>{var l;return(l=this.clerkjs)==null?void 0:l.__experimental_checkout(...i)},this.__unstable__updateProps=async i=>{const l=await Lg(this,Cp,f_).call(this);if(l&&"__unstable__updateProps"in l)return l.__unstable__updateProps(i)},this.setActive=i=>this.clerkjs?this.clerkjs.setActive(i):Promise.reject(),this.openSignIn=i=>{this.clerkjs&&this.loaded?this.clerkjs.openSignIn(i):this.preopenSignIn=i},this.closeSignIn=()=>{this.clerkjs&&this.loaded?this.clerkjs.closeSignIn():this.preopenSignIn=null},this.__internal_openCheckout=i=>{this.clerkjs&&this.loaded?this.clerkjs.__internal_openCheckout(i):this.preopenCheckout=i},this.__internal_closeCheckout=()=>{this.clerkjs&&this.loaded?this.clerkjs.__internal_closeCheckout():this.preopenCheckout=null},this.__internal_openPlanDetails=i=>{this.clerkjs&&this.loaded?this.clerkjs.__internal_openPlanDetails(i):this.preopenPlanDetails=i},this.__internal_closePlanDetails=()=>{this.clerkjs&&this.loaded?this.clerkjs.__internal_closePlanDetails():this.preopenPlanDetails=null},this.__internal_openSubscriptionDetails=i=>{this.clerkjs&&this.loaded?this.clerkjs.__internal_openSubscriptionDetails(i):this.preopenSubscriptionDetails=i??null},this.__internal_closeSubscriptionDetails=()=>{this.clerkjs&&this.loaded?this.clerkjs.__internal_closeSubscriptionDetails():this.preopenSubscriptionDetails=null},this.__internal_openReverification=i=>{this.clerkjs&&this.loaded?this.clerkjs.__internal_openReverification(i):this.preopenUserVerification=i},this.__internal_closeReverification=()=>{this.clerkjs&&this.loaded?this.clerkjs.__internal_closeReverification():this.preopenUserVerification=null},this.openGoogleOneTap=i=>{this.clerkjs&&this.loaded?this.clerkjs.openGoogleOneTap(i):this.preopenOneTap=i},this.closeGoogleOneTap=()=>{this.clerkjs&&this.loaded?this.clerkjs.closeGoogleOneTap():this.preopenOneTap=null},this.openUserProfile=i=>{this.clerkjs&&this.loaded?this.clerkjs.openUserProfile(i):this.preopenUserProfile=i},this.closeUserProfile=()=>{this.clerkjs&&this.loaded?this.clerkjs.closeUserProfile():this.preopenUserProfile=null},this.openOrganizationProfile=i=>{this.clerkjs&&this.loaded?this.clerkjs.openOrganizationProfile(i):this.preopenOrganizationProfile=i},this.closeOrganizationProfile=()=>{this.clerkjs&&this.loaded?this.clerkjs.closeOrganizationProfile():this.preopenOrganizationProfile=null},this.openCreateOrganization=i=>{this.clerkjs&&this.loaded?this.clerkjs.openCreateOrganization(i):this.preopenCreateOrganization=i},this.closeCreateOrganization=()=>{this.clerkjs&&this.loaded?this.clerkjs.closeCreateOrganization():this.preopenCreateOrganization=null},this.openWaitlist=i=>{this.clerkjs&&this.loaded?this.clerkjs.openWaitlist(i):this.preOpenWaitlist=i},this.closeWaitlist=()=>{this.clerkjs&&this.loaded?this.clerkjs.closeWaitlist():this.preOpenWaitlist=null},this.openSignUp=i=>{this.clerkjs&&this.loaded?this.clerkjs.openSignUp(i):this.preopenSignUp=i},this.closeSignUp=()=>{this.clerkjs&&this.loaded?this.clerkjs.closeSignUp():this.preopenSignUp=null},this.mountSignIn=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountSignIn(i,l):this.premountSignInNodes.set(i,l)},this.unmountSignIn=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountSignIn(i):this.premountSignInNodes.delete(i)},this.mountSignUp=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountSignUp(i,l):this.premountSignUpNodes.set(i,l)},this.unmountSignUp=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountSignUp(i):this.premountSignUpNodes.delete(i)},this.mountUserAvatar=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountUserAvatar(i,l):this.premountUserAvatarNodes.set(i,l)},this.unmountUserAvatar=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountUserAvatar(i):this.premountUserAvatarNodes.delete(i)},this.mountUserProfile=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountUserProfile(i,l):this.premountUserProfileNodes.set(i,l)},this.unmountUserProfile=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountUserProfile(i):this.premountUserProfileNodes.delete(i)},this.mountOrganizationProfile=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountOrganizationProfile(i,l):this.premountOrganizationProfileNodes.set(i,l)},this.unmountOrganizationProfile=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountOrganizationProfile(i):this.premountOrganizationProfileNodes.delete(i)},this.mountCreateOrganization=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountCreateOrganization(i,l):this.premountCreateOrganizationNodes.set(i,l)},this.unmountCreateOrganization=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountCreateOrganization(i):this.premountCreateOrganizationNodes.delete(i)},this.mountOrganizationSwitcher=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountOrganizationSwitcher(i,l):this.premountOrganizationSwitcherNodes.set(i,l)},this.unmountOrganizationSwitcher=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountOrganizationSwitcher(i):this.premountOrganizationSwitcherNodes.delete(i)},this.__experimental_prefetchOrganizationSwitcher=()=>{const i=()=>{var l;return(l=this.clerkjs)==null?void 0:l.__experimental_prefetchOrganizationSwitcher()};this.clerkjs&&this.loaded?i():this.premountMethodCalls.set("__experimental_prefetchOrganizationSwitcher",i)},this.mountOrganizationList=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountOrganizationList(i,l):this.premountOrganizationListNodes.set(i,l)},this.unmountOrganizationList=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountOrganizationList(i):this.premountOrganizationListNodes.delete(i)},this.mountUserButton=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountUserButton(i,l):this.premountUserButtonNodes.set(i,l)},this.unmountUserButton=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountUserButton(i):this.premountUserButtonNodes.delete(i)},this.mountWaitlist=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountWaitlist(i,l):this.premountWaitlistNodes.set(i,l)},this.unmountWaitlist=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountWaitlist(i):this.premountWaitlistNodes.delete(i)},this.mountPricingTable=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountPricingTable(i,l):this.premountPricingTableNodes.set(i,l)},this.unmountPricingTable=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountPricingTable(i):this.premountPricingTableNodes.delete(i)},this.mountApiKeys=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountApiKeys(i,l):this.premountApiKeysNodes.set(i,l)},this.unmountApiKeys=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountApiKeys(i):this.premountApiKeysNodes.delete(i)},this.__internal_mountOAuthConsent=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.__internal_mountOAuthConsent(i,l):this.premountOAuthConsentNodes.set(i,l)},this.__internal_unmountOAuthConsent=i=>{this.clerkjs&&this.loaded?this.clerkjs.__internal_unmountOAuthConsent(i):this.premountOAuthConsentNodes.delete(i)},this.mountTaskChooseOrganization=(i,l)=>{this.clerkjs&&this.loaded?this.clerkjs.mountTaskChooseOrganization(i,l):this.premountTaskChooseOrganizationNodes.set(i,l)},this.unmountTaskChooseOrganization=i=>{this.clerkjs&&this.loaded?this.clerkjs.unmountTaskChooseOrganization(i):this.premountTaskChooseOrganizationNodes.delete(i)},this.addListener=i=>{if(this.clerkjs)return this.clerkjs.addListener(i);{const l=()=>{var u;const d=this.premountAddListenerCalls.get(i);d&&((u=d.nativeUnsubscribe)==null||u.call(d),this.premountAddListenerCalls.delete(i))};return this.premountAddListenerCalls.set(i,{unsubscribe:l,nativeUnsubscribe:void 0}),l}},this.navigate=i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.navigate(i)};this.clerkjs&&this.loaded?l():this.premountMethodCalls.set("navigate",l)},this.redirectWithAuth=async(...i)=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.redirectWithAuth(...i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("redirectWithAuth",l)},this.redirectToSignIn=async i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.redirectToSignIn(i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("redirectToSignIn",l)},this.redirectToSignUp=async i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.redirectToSignUp(i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("redirectToSignUp",l)},this.redirectToUserProfile=async()=>{const i=()=>{var l;return(l=this.clerkjs)==null?void 0:l.redirectToUserProfile()};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("redirectToUserProfile",i)},this.redirectToAfterSignUp=()=>{const i=()=>{var l;return(l=this.clerkjs)==null?void 0:l.redirectToAfterSignUp()};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("redirectToAfterSignUp",i)},this.redirectToAfterSignIn=()=>{const i=()=>{var l;return(l=this.clerkjs)==null?void 0:l.redirectToAfterSignIn()};this.clerkjs&&this.loaded?i():this.premountMethodCalls.set("redirectToAfterSignIn",i)},this.redirectToAfterSignOut=()=>{const i=()=>{var l;return(l=this.clerkjs)==null?void 0:l.redirectToAfterSignOut()};this.clerkjs&&this.loaded?i():this.premountMethodCalls.set("redirectToAfterSignOut",i)},this.redirectToOrganizationProfile=async()=>{const i=()=>{var l;return(l=this.clerkjs)==null?void 0:l.redirectToOrganizationProfile()};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("redirectToOrganizationProfile",i)},this.redirectToCreateOrganization=async()=>{const i=()=>{var l;return(l=this.clerkjs)==null?void 0:l.redirectToCreateOrganization()};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("redirectToCreateOrganization",i)},this.redirectToWaitlist=async()=>{const i=()=>{var l;return(l=this.clerkjs)==null?void 0:l.redirectToWaitlist()};if(this.clerkjs&&this.loaded)return i();this.premountMethodCalls.set("redirectToWaitlist",i)},this.redirectToTasks=async i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.redirectToTasks(i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("redirectToTasks",l)},this.handleRedirectCallback=async i=>{var l;const u=()=>{var d;return(d=this.clerkjs)==null?void 0:d.handleRedirectCallback(i)};this.clerkjs&&this.loaded?(l=u())==null||l.catch(()=>{}):this.premountMethodCalls.set("handleRedirectCallback",u)},this.handleGoogleOneTapCallback=async(i,l)=>{var u;const d=()=>{var f;return(f=this.clerkjs)==null?void 0:f.handleGoogleOneTapCallback(i,l)};this.clerkjs&&this.loaded?(u=d())==null||u.catch(()=>{}):this.premountMethodCalls.set("handleGoogleOneTapCallback",d)},this.handleEmailLinkVerification=async i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.handleEmailLinkVerification(i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("handleEmailLinkVerification",l)},this.authenticateWithMetamask=async i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.authenticateWithMetamask(i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("authenticateWithMetamask",l)},this.authenticateWithCoinbaseWallet=async i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.authenticateWithCoinbaseWallet(i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("authenticateWithCoinbaseWallet",l)},this.authenticateWithBase=async i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.authenticateWithBase(i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("authenticateWithBase",l)},this.authenticateWithOKXWallet=async i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.authenticateWithOKXWallet(i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("authenticateWithOKXWallet",l)},this.authenticateWithWeb3=async i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.authenticateWithWeb3(i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("authenticateWithWeb3",l)},this.authenticateWithGoogleOneTap=async i=>(await Lg(this,Cp,f_).call(this)).authenticateWithGoogleOneTap(i),this.__internal_loadStripeJs=async()=>(await Lg(this,Cp,f_).call(this)).__internal_loadStripeJs(),this.createOrganization=async i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.createOrganization(i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("createOrganization",l)},this.getOrganization=async i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.getOrganization(i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("getOrganization",l)},this.joinWaitlist=async i=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.joinWaitlist(i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("joinWaitlist",l)},this.signOut=async(...i)=>{const l=()=>{var u;return(u=this.clerkjs)==null?void 0:u.signOut(...i)};if(this.clerkjs&&this.loaded)return l();this.premountMethodCalls.set("signOut",l)};const{Clerk:t=null,publishableKey:a}=n||{};fc(this,Vl,a),fc(this,ef,n?.proxyUrl),fc(this,Jd,n?.domain),this.options=n,this.Clerk=t,this.mode=w_()?"browser":"server",fc(this,d_,new qk(this)),this.options.sdkMetadata||(this.options.sdkMetadata=Qk),xr(this,Uo).emit(Km.Status,"loading"),xr(this,Uo).prioritizedOn(Km.Status,i=>fc(this,c_,i)),xr(this,Vl)&&this.loadClerkJS()}get publishableKey(){return xr(this,Vl)}get loaded(){var n;return((n=this.clerkjs)==null?void 0:n.loaded)||!1}get status(){var n;return this.clerkjs?((n=this.clerkjs)==null?void 0:n.status)||(this.clerkjs.loaded?"ready":"loading"):xr(this,c_)}static getOrCreateInstance(n){return(!w_()||!xr(this,Wl)||n.Clerk&&xr(this,Wl).Clerk!==n.Clerk||xr(this,Wl).publishableKey!==n.publishableKey)&&fc(this,Wl,new ix(n)),xr(this,Wl)}static clearInstance(){fc(this,Wl,null)}get domain(){return typeof window<"u"&&window.location?kg(xr(this,Jd),new URL(window.location.href),""):typeof xr(this,Jd)=="function"?wi.throw(Ag):xr(this,Jd)||""}get proxyUrl(){return typeof window<"u"&&window.location?kg(xr(this,ef),new URL(window.location.href),""):typeof xr(this,ef)=="function"?wi.throw(Ag):xr(this,ef)||""}__internal_getOption(n){var t,a;return(t=this.clerkjs)!=null&&t.__internal_getOption?(a=this.clerkjs)==null?void 0:a.__internal_getOption(n):this.options[n]}get sdkMetadata(){var n;return((n=this.clerkjs)==null?void 0:n.sdkMetadata)||this.options.sdkMetadata||void 0}get instanceType(){var n;return(n=this.clerkjs)==null?void 0:n.instanceType}get frontendApi(){var n;return((n=this.clerkjs)==null?void 0:n.frontendApi)||""}get isStandardBrowser(){var n;return((n=this.clerkjs)==null?void 0:n.isStandardBrowser)||this.options.standardBrowser||!1}get isSatellite(){return typeof window<"u"&&window.location?kg(this.options.isSatellite,new URL(window.location.href),!1):typeof this.options.isSatellite=="function"?wi.throw(Ag):!1}async loadClerkJS(){var n;if(!(this.mode!=="browser"||this.loaded)){typeof window<"u"&&(window.__clerk_publishable_key=xr(this,Vl),window.__clerk_proxy_url=this.proxyUrl,window.__clerk_domain=this.domain);try{if(this.Clerk){let t;ok(this.Clerk)?(t=new this.Clerk(xr(this,Vl),{proxyUrl:this.proxyUrl,domain:this.domain}),this.beforeLoad(t),await t.load(this.options)):(t=this.Clerk,t.loaded||(this.beforeLoad(t),await t.load(this.options))),global.Clerk=t}else if(!__BUILD_DISABLE_RHC__){if(global.Clerk||await Bk({...this.options,publishableKey:xr(this,Vl),proxyUrl:this.proxyUrl,domain:this.domain,nonce:this.options.nonce}),!global.Clerk)throw new Error("Failed to download latest ClerkJS. Contact support@clerk.com.");this.beforeLoad(global.Clerk),await global.Clerk.load(this.options)}return(n=global.Clerk)!=null&&n.loaded?this.hydrateClerkJS(global.Clerk):void 0}catch(t){const a=t;xr(this,Uo).emit(Km.Status,"error"),console.error(a.stack||a.message||a);return}}}get version(){var n;return(n=this.clerkjs)==null?void 0:n.version}get client(){if(this.clerkjs)return this.clerkjs.client}get session(){if(this.clerkjs)return this.clerkjs.session}get user(){if(this.clerkjs)return this.clerkjs.user}get organization(){if(this.clerkjs)return this.clerkjs.organization}get telemetry(){if(this.clerkjs)return this.clerkjs.telemetry}get __unstable__environment(){if(this.clerkjs)return this.clerkjs.__unstable__environment}get isSignedIn(){return this.clerkjs?this.clerkjs.isSignedIn:!1}get billing(){var n;return(n=this.clerkjs)==null?void 0:n.billing}get __internal_state(){return this.loaded&&this.clerkjs?this.clerkjs.__internal_state:xr(this,d_)}get apiKeys(){var n;return(n=this.clerkjs)==null?void 0:n.apiKeys}__unstable__setEnvironment(...n){if(this.clerkjs&&"__unstable__setEnvironment"in this.clerkjs)this.clerkjs.__unstable__setEnvironment(n);else return}};c_=new WeakMap;Jd=new WeakMap;ef=new WeakMap;Vl=new WeakMap;Uo=new WeakMap;d_=new WeakMap;Wl=new WeakMap;Cp=new WeakSet;f_=function(){return new Promise(e=>{this.addOnLoaded(()=>e(this.clerkjs))})};Ul(ax,Wl);var mb=ax;function Xk(e){const{isomorphicClerkOptions:n,initialState:t,children:a}=e,{isomorphicClerk:i,clerkStatus:l}=Yk(n),[u,d]=We.useState({client:i.client,session:i.session,user:i.user,organization:i.organization});We.useEffect(()=>i.addListener(ee=>d({...ee})),[]);const f=Vk(i.loaded,u,t),h=We.useMemo(()=>({value:i}),[l]),_=We.useMemo(()=>({value:u.client}),[u.client]),{sessionId:m,sessionStatus:p,sessionClaims:y,session:v,userId:x,user:L,orgId:T,actor:E,organization:I,orgRole:P,orgSlug:S,orgPermissions:k,factorVerificationAge:C}=f,D=We.useMemo(()=>({value:{sessionId:m,sessionStatus:p,sessionClaims:y,userId:x,actor:E,orgId:T,orgRole:P,orgSlug:S,orgPermissions:k,factorVerificationAge:C}}),[m,p,x,E,T,P,S,C,y?.__raw]),V=We.useMemo(()=>({value:v}),[m,v]),U=We.useMemo(()=>({value:L}),[x,L]),ne=We.useMemo(()=>({value:{organization:I}}),[T,I]);return We.createElement(FA.Provider,{value:h},We.createElement(MA.Provider,{value:_},We.createElement(xA.Provider,{value:V},We.createElement(CA,{...ne.value},We.createElement(LA.Provider,{value:D},We.createElement(bA.Provider,{value:U},We.createElement(EA,{value:void 0},a)))))))}var Yk=e=>{const n=We.useRef(mb.getOrCreateInstance(e)),[t,a]=We.useState(n.current.status);return We.useEffect(()=>{n.current.__unstable__updateProps({appearance:e.appearance})},[e.appearance]),We.useEffect(()=>{n.current.__unstable__updateProps({options:e})},[e.localization]),We.useEffect(()=>(n.current.on("status",a),()=>{n.current&&n.current.off("status",a),mb.clearInstance()}),[]),{isomorphicClerk:n.current,clerkStatus:t}};function Zk(e){const{initialState:n,children:t,__internal_bypassMissingPublishableKey:a,...i}=e,{publishableKey:l="",Clerk:u}=i;return!u&&!a&&(l?l&&!N0(l)&&wi.throwInvalidPublishableKeyError({key:l}):wi.throwMissingPublishableKeyError()),We.createElement(Xk,{initialState:n,isomorphicClerkOptions:i},t)}var ox=uk(Zk,"ClerkProvider",RA);ox.displayName="ClerkProvider";IA({packageName:"@clerk/clerk-react"});Rk("@clerk/clerk-react");const h_=new Map,gc=[],Jk=(e,n,t)=>{if(n&&typeof n.init=="function"&&typeof n.createInferenceSessionHandler=="function"){const a=h_.get(e);if(a===void 0)h_.set(e,{backend:n,priority:t});else{if(a.priority>t)return;if(a.priority===t&&a.backend!==n)throw new Error(`cannot register backend "${e}" using priority ${t}`)}if(t>=0){const i=gc.indexOf(e);i!==-1&&gc.splice(i,1);for(let l=0;l<gc.length;l++)if(h_.get(gc[l]).priority<=t){gc.splice(l,0,e);return}gc.push(e)}return}throw new TypeError("not a valid backend")},eO=async e=>{const n=h_.get(e);if(!n)return"backend not found.";if(n.initialized)return n.backend;if(n.aborted)return n.error;{const t=!!n.initPromise;try{return t||(n.initPromise=n.backend.init(e)),await n.initPromise,n.initialized=!0,n.backend}catch(a){return t||(n.error=`${a}`,n.aborted=!0),n.error}finally{delete n.initPromise}}},tO=async e=>{const n=e.executionProviders||[],t=n.map(f=>typeof f=="string"?f:f.name),a=t.length===0?gc:t;let i;const l=[],u=new Set;for(const f of a){const h=await eO(f);typeof h=="string"?l.push({name:f,err:h}):(i||(i=h),i===h&&u.add(f))}if(!i)throw new Error(`no available backend found. ERR: ${l.map(f=>`[${f.name}] ${f.err}`).join(", ")}`);for(const{name:f,err:h}of l)t.includes(f)&&console.warn(`removing requested execution provider "${f}" from session options because it is not available: ${h}`);const d=n.filter(f=>u.has(typeof f=="string"?f:f.name));return[i,new Proxy(e,{get:(f,h)=>h==="executionProviders"?d:Reflect.get(f,h)})]},nO="1.21.0";let _b="warning";const Mi={wasm:{},webgl:{},webgpu:{},versions:{common:nO},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);_b=e}},get logLevel(){return _b}};Object.defineProperty(Mi,"logLevel",{enumerable:!0});const rO=Mi,sO=(e,n)=>{const t=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);t.width=e.dims[3],t.height=e.dims[2];const a=t.getContext("2d");if(a!=null){let i,l;n?.tensorLayout!==void 0&&n.tensorLayout==="NHWC"?(i=e.dims[2],l=e.dims[3]):(i=e.dims[3],l=e.dims[2]);const u=n?.format!==void 0?n.format:"RGB",d=n?.norm;let f,h;d===void 0||d.mean===void 0?f=[255,255,255,255]:typeof d.mean=="number"?f=[d.mean,d.mean,d.mean,d.mean]:(f=[d.mean[0],d.mean[1],d.mean[2],0],d.mean[3]!==void 0&&(f[3]=d.mean[3])),d===void 0||d.bias===void 0?h=[0,0,0,0]:typeof d.bias=="number"?h=[d.bias,d.bias,d.bias,d.bias]:(h=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(h[3]=d.bias[3]));const _=l*i;let m=0,p=_,y=_*2,v=-1;u==="RGBA"?(m=0,p=_,y=_*2,v=_*3):u==="RGB"?(m=0,p=_,y=_*2):u==="RBG"&&(m=0,y=_,p=_*2);for(let x=0;x<l;x++)for(let L=0;L<i;L++){const T=(e.data[m++]-h[0])*f[0],E=(e.data[p++]-h[1])*f[1],I=(e.data[y++]-h[2])*f[2],P=v===-1?255:(e.data[v++]-h[3])*f[3];a.fillStyle="rgba("+T+","+E+","+I+","+P+")",a.fillRect(L,x,1,1)}if("toDataURL"in t)return t.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},aO=(e,n)=>{const t=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let a;if(t!=null){let i,l,u;n?.tensorLayout!==void 0&&n.tensorLayout==="NHWC"?(i=e.dims[2],l=e.dims[1],u=e.dims[3]):(i=e.dims[3],l=e.dims[2],u=e.dims[1]);const d=n!==void 0&&n.format!==void 0?n.format:"RGB",f=n?.norm;let h,_;f===void 0||f.mean===void 0?h=[255,255,255,255]:typeof f.mean=="number"?h=[f.mean,f.mean,f.mean,f.mean]:(h=[f.mean[0],f.mean[1],f.mean[2],255],f.mean[3]!==void 0&&(h[3]=f.mean[3])),f===void 0||f.bias===void 0?_=[0,0,0,0]:typeof f.bias=="number"?_=[f.bias,f.bias,f.bias,f.bias]:(_=[f.bias[0],f.bias[1],f.bias[2],0],f.bias[3]!==void 0&&(_[3]=f.bias[3]));const m=l*i;if(n!==void 0&&(n.format!==void 0&&u===4&&n.format!=="RGBA"||u===3&&n.format!=="RGB"&&n.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const p=4;let y=0,v=1,x=2,L=3,T=0,E=m,I=m*2,P=-1;d==="RGBA"?(T=0,E=m,I=m*2,P=m*3):d==="RGB"?(T=0,E=m,I=m*2):d==="RBG"&&(T=0,I=m,E=m*2),a=t.createImageData(i,l);for(let S=0;S<l*i;y+=p,v+=p,x+=p,L+=p,S++)a.data[y]=(e.data[T++]-_[0])*h[0],a.data[v]=(e.data[E++]-_[1])*h[1],a.data[x]=(e.data[I++]-_[2])*h[2],a.data[L]=P===-1?255:(e.data[P++]-_[3])*h[3]}else throw new Error("Can not access image data");return a},zg=(e,n)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(n.height===void 0||n.width===void 0)throw new Error("Image height and width must be defined");if(n.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:t,width:a}=n,i=n.norm??{mean:255,bias:0};let l,u;typeof i.mean=="number"?l=[i.mean,i.mean,i.mean,i.mean]:l=[i.mean[0],i.mean[1],i.mean[2],i.mean[3]??255],typeof i.bias=="number"?u=[i.bias,i.bias,i.bias,i.bias]:u=[i.bias[0],i.bias[1],i.bias[2],i.bias[3]??0];const d=n.format!==void 0?n.format:"RGBA",f=n.tensorFormat!==void 0&&n.tensorFormat!==void 0?n.tensorFormat:"RGB",h=t*a,_=f==="RGBA"?new Float32Array(h*4):new Float32Array(h*3);let m=4,p=0,y=1,v=2,x=3,L=0,T=h,E=h*2,I=-1;d==="RGB"&&(m=3,p=0,y=1,v=2,x=-1),f==="RGBA"?I=h*3:f==="RBG"?(L=0,E=h,T=h*2):f==="BGR"&&(E=0,T=h,L=h*2);for(let S=0;S<h;S++,p+=m,v+=m,y+=m,x+=m)_[L++]=(e[p]+u[0])/l[0],_[T++]=(e[y]+u[1])/l[1],_[E++]=(e[v]+u[2])/l[2],I!==-1&&x!==-1&&(_[I++]=(e[x]+u[3])/l[3]);return f==="RGBA"?new Ra("float32",_,[1,4,t,a]):new Ra("float32",_,[1,3,t,a])},iO=async(e,n)=>{const t=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,i=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,l=typeof e=="string";let u,d=n??{};const f=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},h=_=>typeof HTMLCanvasElement<"u"&&_ instanceof HTMLCanvasElement||_ instanceof OffscreenCanvas?_.getContext("2d"):null;if(t){const _=f();_.width=e.width,_.height=e.height;const m=h(_);if(m!=null){let p=e.height,y=e.width;if(n!==void 0&&n.resizedHeight!==void 0&&n.resizedWidth!==void 0&&(p=n.resizedHeight,y=n.resizedWidth),n!==void 0){if(d=n,n.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");d.tensorFormat="RGBA",d.height=p,d.width=y}else d.tensorFormat="RGBA",d.height=p,d.width=y;m.drawImage(e,0,0),u=m.getImageData(0,0,y,p).data}else throw new Error("Can not access image data")}else if(a){let _,m;if(n!==void 0&&n.resizedWidth!==void 0&&n.resizedHeight!==void 0?(_=n.resizedHeight,m=n.resizedWidth):(_=e.height,m=e.width),n!==void 0&&(d=n),d.format="RGBA",d.height=_,d.width=m,n!==void 0){const p=f();p.width=m,p.height=_;const y=h(p);if(y!=null)y.putImageData(e,0,0),u=y.getImageData(0,0,m,_).data;else throw new Error("Can not access image data")}else u=e.data}else if(i){if(n===void 0)throw new Error("Please provide image config with format for Imagebitmap");const _=f();_.width=e.width,_.height=e.height;const m=h(_);if(m!=null){const p=e.height,y=e.width;return m.drawImage(e,0,0,y,p),u=m.getImageData(0,0,y,p).data,d.height=p,d.width=y,zg(u,d)}else throw new Error("Can not access image data")}else{if(l)return new Promise((_,m)=>{const p=f(),y=h(p);if(!e||!y)return m();const v=new Image;v.crossOrigin="Anonymous",v.src=e,v.onload=()=>{p.width=v.width,p.height=v.height,y.drawImage(v,0,0,p.width,p.height);const x=y.getImageData(0,0,p.width,p.height);d.height=p.height,d.width=p.width,_(zg(x.data,d))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(u!==void 0)return zg(u,d);throw new Error("Input data provided is not supported - aborted tensor creation")},oO=(e,n)=>{const{width:t,height:a,download:i,dispose:l}=n,u=[1,a,t,4];return new Ra({location:"texture",type:"float32",texture:e,dims:u,download:i,dispose:l})},lO=(e,n)=>{const{dataType:t,dims:a,download:i,dispose:l}=n;return new Ra({location:"gpu-buffer",type:t??"float32",gpuBuffer:e,dims:a,download:i,dispose:l})},uO=(e,n)=>{const{dataType:t,dims:a,download:i,dispose:l}=n;return new Ra({location:"ml-tensor",type:t??"float32",mlTensor:e,dims:a,download:i,dispose:l})},cO=(e,n,t)=>new Ra({location:"cpu-pinned",type:e,data:n,dims:t??[n.length]}),rf=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),p_=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let gb=!1;const dO=()=>{if(!gb){gb=!0;const e=typeof BigInt64Array<"u"&&BigInt64Array.from,n=typeof BigUint64Array<"u"&&BigUint64Array.from,t=globalThis.Float16Array,a=typeof t<"u"&&t.from;e&&(rf.set("int64",BigInt64Array),p_.set(BigInt64Array,"int64")),n&&(rf.set("uint64",BigUint64Array),p_.set(BigUint64Array,"uint64")),a?(rf.set("float16",t),p_.set(t,"float16")):rf.set("float16",Uint16Array)}},fO=e=>{let n=1;for(let t=0;t<e.length;t++){const a=e[t];if(typeof a!="number"||!Number.isSafeInteger(a))throw new TypeError(`dims[${t}] must be an integer, got: ${a}`);if(a<0)throw new RangeError(`dims[${t}] must be a non-negative integer, got: ${a}`);n*=a}return n},hO=(e,n)=>{switch(e.location){case"cpu":return new Ra(e.type,e.data,n);case"cpu-pinned":return new Ra({location:"cpu-pinned",data:e.data,type:e.type,dims:n});case"texture":return new Ra({location:"texture",texture:e.texture,type:e.type,dims:n});case"gpu-buffer":return new Ra({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:n});case"ml-tensor":return new Ra({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:n});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}};let Ra=class{constructor(n,t,a){dO();let i,l;if(typeof n=="object"&&"location"in n)switch(this.dataLocation=n.location,i=n.type,l=n.dims,n.location){case"cpu-pinned":{const d=rf.get(i);if(!d)throw new TypeError(`unsupported type "${i}" to create tensor from pinned buffer`);if(!(n.data instanceof d))throw new TypeError(`buffer should be of type ${d.name}`);this.cpuData=n.data;break}case"texture":{if(i!=="float32")throw new TypeError(`unsupported type "${i}" to create tensor from texture`);this.gpuTextureData=n.texture,this.downloader=n.download,this.disposer=n.dispose;break}case"gpu-buffer":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="uint8"&&i!=="bool"&&i!=="uint4"&&i!=="int4")throw new TypeError(`unsupported type "${i}" to create tensor from gpu buffer`);this.gpuBufferData=n.gpuBuffer,this.downloader=n.download,this.disposer=n.dispose;break}case"ml-tensor":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="uint64"&&i!=="int8"&&i!=="uint8"&&i!=="bool"&&i!=="uint4"&&i!=="int4")throw new TypeError(`unsupported type "${i}" to create tensor from MLTensor`);this.mlTensorData=n.mlTensor,this.downloader=n.download,this.disposer=n.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let d,f;if(typeof n=="string")if(i=n,f=a,n==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");d=t}else{const h=rf.get(n);if(h===void 0)throw new TypeError(`Unsupported tensor type: ${n}.`);if(Array.isArray(t)){if(n==="float16"&&h===Uint16Array||n==="uint4"||n==="int4")throw new TypeError(`Creating a ${n} tensor from number array is not supported. Please use ${h.name} as data.`);n==="uint64"||n==="int64"?d=h.from(t,BigInt):d=h.from(t)}else if(t instanceof h)d=t;else if(t instanceof Uint8ClampedArray)if(n==="uint8")d=Uint8Array.from(t);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(n==="float16"&&t instanceof Uint16Array&&h!==Uint16Array)d=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw new TypeError(`A ${i} tensor's data must be type of ${h}`)}else if(f=t,Array.isArray(n)){if(n.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const h=typeof n[0];if(h==="string")i="string",d=n;else if(h==="boolean")i="bool",d=Uint8Array.from(n);else throw new TypeError(`Invalid element type of data array: ${h}.`)}else if(n instanceof Uint8ClampedArray)i="uint8",d=Uint8Array.from(n);else{const h=p_.get(n.constructor);if(h===void 0)throw new TypeError(`Unsupported type for tensor data: ${n.constructor}.`);i=h,d=n}if(f===void 0)f=[d.length];else if(!Array.isArray(f))throw new TypeError("A tensor's dims must be a number array");l=f,this.cpuData=d,this.dataLocation="cpu"}const u=fO(l);if(this.cpuData&&u!==this.cpuData.length&&!((i==="uint4"||i==="int4")&&Math.ceil(u/2)===this.cpuData.length))throw new Error(`Tensor's size(${u}) does not match data length(${this.cpuData.length}).`);this.type=i,this.dims=l,this.size=u}static async fromImage(n,t){return iO(n,t)}static fromTexture(n,t){return oO(n,t)}static fromGpuBuffer(n,t){return lO(n,t)}static fromMLTensor(n,t){return uO(n,t)}static fromPinnedBuffer(n,t,a){return cO(n,t,a)}toDataURL(n){return sO(this,n)}toImageData(n){return aO(this,n)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(n){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,n&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(n){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return hO(this,n)}};const tf=Ra,lx=(e,n)=>{(typeof Mi.trace>"u"?!Mi.wasm.trace:!Mi.trace)||console.timeStamp(`${e}::ORT::${n}`)},ux=(e,n)=>{const t=new Error().stack?.split(/\r\n|\r|\n/g)||[];let a=!1;for(let i=0;i<t.length;i++){if(a&&!t[i].includes("TRACE_FUNC")){let l=`FUNC_${e}::${t[i].trim().split(" ")[1]}`;n&&(l+=`::${n}`),lx("CPU",l);return}t[i].includes("TRACE_FUNC")&&(a=!0)}},ty=e=>{(typeof Mi.trace>"u"?!Mi.wasm.trace:!Mi.trace)||ux("BEGIN",e)},ny=e=>{(typeof Mi.trace>"u"?!Mi.wasm.trace:!Mi.trace)||ux("END",e)};let pO=class cx{constructor(n){this.handler=n}async run(n,t,a){ty();const i={};let l={};if(typeof n!="object"||n===null||n instanceof tf||Array.isArray(n))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof tf)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(const h of t){if(typeof h!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(h)===-1)throw new RangeError(`'fetches' contains invalid output name: ${h}.`);i[h]=null}if(typeof a=="object"&&a!==null)l=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let h=!1;const _=Object.getOwnPropertyNames(t);for(const m of this.outputNames)if(_.indexOf(m)!==-1){const p=t[m];(p===null||p instanceof tf)&&(h=!0,u=!1,i[m]=p)}if(h){if(typeof a=="object"&&a!==null)l=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else l=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const h of this.inputNames)if(typeof n[h]>"u")throw new Error(`input '${h}' is missing in 'feeds'.`);if(u)for(const h of this.outputNames)i[h]=null;const d=await this.handler.run(n,i,l),f={};for(const h in d)if(Object.hasOwnProperty.call(d,h)){const _=d[h];_ instanceof tf?f[h]=_:f[h]=new tf(_.type,_.data,_.dims)}return ny(),f}async release(){return this.handler.dispose()}static async create(n,t,a,i){ty();let l,u={};if(typeof n=="string"){if(l=n,typeof t=="object"&&t!==null)u=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(n instanceof Uint8Array){if(l=n,typeof t=="object"&&t!==null)u=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(n instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&n instanceof SharedArrayBuffer){const _=n;let m=0,p=n.byteLength;if(typeof t=="object"&&t!==null)u=t;else if(typeof t=="number"){if(m=t,!Number.isSafeInteger(m))throw new RangeError("'byteOffset' must be an integer.");if(m<0||m>=_.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${_.byteLength}).`);if(p=n.byteLength-m,typeof a=="number"){if(p=a,!Number.isSafeInteger(p))throw new RangeError("'byteLength' must be an integer.");if(p<=0||m+p>_.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${_.byteLength-m}].`);if(typeof i=="object"&&i!==null)u=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(typeof a<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof t<"u")throw new TypeError("'options' must be an object.");l=new Uint8Array(_,m,p)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[d,f]=await tO(u),h=await d.createInferenceSessionHandler(l,f);return ny(),new cx(h)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const mO=pO,_O=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:mO,TRACE:lx,TRACE_FUNC_BEGIN:ty,TRACE_FUNC_END:ny,Tensor:tf,env:rO,registerBackend:Jk},Symbol.toStringTag,{value:"Module"}));/*!
 * ONNX Runtime Web v1.22.0-dev.20250409-89f8206ba4
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var Dy=Object.defineProperty,gO=Object.getOwnPropertyDescriptor,yO=Object.getOwnPropertyNames,vO=Object.prototype.hasOwnProperty,bO=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(n,t)=>(typeof require<"u"?require:n)[t]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),ut=(e,n)=>()=>(e&&(n=e(e=0)),n),df=(e,n)=>{for(var t in n)Dy(e,t,{get:n[t],enumerable:!0})},wO=(e,n,t,a)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of yO(n))!vO.call(e,i)&&i!==t&&Dy(e,i,{get:()=>n[i],enumerable:!(a=gO(n,i))||a.enumerable});return e},Rp=e=>wO(Dy({},"__esModule",{value:!0}),e),gp,Bl,bc,yb,dx,fx=ut(()=>{gp=new Map,Bl=[],bc=(e,n,t)=>{if(n&&typeof n.init=="function"&&typeof n.createInferenceSessionHandler=="function"){let a=gp.get(e);if(a===void 0)gp.set(e,{backend:n,priority:t});else{if(a.priority>t)return;if(a.priority===t&&a.backend!==n)throw new Error(`cannot register backend "${e}" using priority ${t}`)}if(t>=0){let i=Bl.indexOf(e);i!==-1&&Bl.splice(i,1);for(let l=0;l<Bl.length;l++)if(gp.get(Bl[l]).priority<=t){Bl.splice(l,0,e);return}Bl.push(e)}return}throw new TypeError("not a valid backend")},yb=async e=>{let n=gp.get(e);if(!n)return"backend not found.";if(n.initialized)return n.backend;if(n.aborted)return n.error;{let t=!!n.initPromise;try{return t||(n.initPromise=n.backend.init(e)),await n.initPromise,n.initialized=!0,n.backend}catch(a){return t||(n.error=`${a}`,n.aborted=!0),n.error}finally{delete n.initPromise}}},dx=async e=>{let n=e.executionProviders||[],t=n.map(f=>typeof f=="string"?f:f.name),a=t.length===0?Bl:t,i,l=[],u=new Set;for(let f of a){let h=await yb(f);typeof h=="string"?l.push({name:f,err:h}):(i||(i=h),i===h&&u.add(f))}if(!i)throw new Error(`no available backend found. ERR: ${l.map(f=>`[${f.name}] ${f.err}`).join(", ")}`);for(let{name:f,err:h}of l)t.includes(f)&&console.warn(`removing requested execution provider "${f}" from session options because it is not available: ${h}`);let d=n.filter(f=>u.has(typeof f=="string"?f:f.name));return[i,new Proxy(e,{get:(f,h)=>h==="executionProviders"?d:Reflect.get(f,h)})]}}),MO=ut(()=>{fx()}),hx,xO=ut(()=>{hx="1.22.0-dev.20250409-89f8206ba4"}),Fg,za,px=ut(()=>{xO(),Fg="warning",za={wasm:{},webgl:{},webgpu:{},versions:{common:hx},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Fg=e}},get logLevel(){return Fg}},Object.defineProperty(za,"logLevel",{enumerable:!0})}),Jn,TO=ut(()=>{px(),Jn=za}),mx,_x,EO=ut(()=>{mx=(e,n)=>{let t=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);t.width=e.dims[3],t.height=e.dims[2];let a=t.getContext("2d");if(a!=null){let i,l;n?.tensorLayout!==void 0&&n.tensorLayout==="NHWC"?(i=e.dims[2],l=e.dims[3]):(i=e.dims[3],l=e.dims[2]);let u=n?.format!==void 0?n.format:"RGB",d=n?.norm,f,h;d===void 0||d.mean===void 0?f=[255,255,255,255]:typeof d.mean=="number"?f=[d.mean,d.mean,d.mean,d.mean]:(f=[d.mean[0],d.mean[1],d.mean[2],0],d.mean[3]!==void 0&&(f[3]=d.mean[3])),d===void 0||d.bias===void 0?h=[0,0,0,0]:typeof d.bias=="number"?h=[d.bias,d.bias,d.bias,d.bias]:(h=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(h[3]=d.bias[3]));let _=l*i,m=0,p=_,y=_*2,v=-1;u==="RGBA"?(m=0,p=_,y=_*2,v=_*3):u==="RGB"?(m=0,p=_,y=_*2):u==="RBG"&&(m=0,y=_,p=_*2);for(let x=0;x<l;x++)for(let L=0;L<i;L++){let T=(e.data[m++]-h[0])*f[0],E=(e.data[p++]-h[1])*f[1],I=(e.data[y++]-h[2])*f[2],P=v===-1?255:(e.data[v++]-h[3])*f[3];a.fillStyle="rgba("+T+","+E+","+I+","+P+")",a.fillRect(L,x,1,1)}if("toDataURL"in t)return t.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},_x=(e,n)=>{let t=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),a;if(t!=null){let i,l,u;n?.tensorLayout!==void 0&&n.tensorLayout==="NHWC"?(i=e.dims[2],l=e.dims[1],u=e.dims[3]):(i=e.dims[3],l=e.dims[2],u=e.dims[1]);let d=n!==void 0&&n.format!==void 0?n.format:"RGB",f=n?.norm,h,_;f===void 0||f.mean===void 0?h=[255,255,255,255]:typeof f.mean=="number"?h=[f.mean,f.mean,f.mean,f.mean]:(h=[f.mean[0],f.mean[1],f.mean[2],255],f.mean[3]!==void 0&&(h[3]=f.mean[3])),f===void 0||f.bias===void 0?_=[0,0,0,0]:typeof f.bias=="number"?_=[f.bias,f.bias,f.bias,f.bias]:(_=[f.bias[0],f.bias[1],f.bias[2],0],f.bias[3]!==void 0&&(_[3]=f.bias[3]));let m=l*i;if(n!==void 0&&(n.format!==void 0&&u===4&&n.format!=="RGBA"||u===3&&n.format!=="RGB"&&n.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let p=4,y=0,v=1,x=2,L=3,T=0,E=m,I=m*2,P=-1;d==="RGBA"?(T=0,E=m,I=m*2,P=m*3):d==="RGB"?(T=0,E=m,I=m*2):d==="RBG"&&(T=0,I=m,E=m*2),a=t.createImageData(i,l);for(let S=0;S<l*i;y+=p,v+=p,x+=p,L+=p,S++)a.data[y]=(e.data[T++]-_[0])*h[0],a.data[v]=(e.data[E++]-_[1])*h[1],a.data[x]=(e.data[I++]-_[2])*h[2],a.data[L]=P===-1?255:(e.data[P++]-_[3])*h[3]}else throw new Error("Can not access image data");return a}}),qm,gx,yx,vx,bx,wx,SO=ut(()=>{Iy(),qm=(e,n)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(n.height===void 0||n.width===void 0)throw new Error("Image height and width must be defined");if(n.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:t,width:a}=n,i=n.norm??{mean:255,bias:0},l,u;typeof i.mean=="number"?l=[i.mean,i.mean,i.mean,i.mean]:l=[i.mean[0],i.mean[1],i.mean[2],i.mean[3]??255],typeof i.bias=="number"?u=[i.bias,i.bias,i.bias,i.bias]:u=[i.bias[0],i.bias[1],i.bias[2],i.bias[3]??0];let d=n.format!==void 0?n.format:"RGBA",f=n.tensorFormat!==void 0&&n.tensorFormat!==void 0?n.tensorFormat:"RGB",h=t*a,_=f==="RGBA"?new Float32Array(h*4):new Float32Array(h*3),m=4,p=0,y=1,v=2,x=3,L=0,T=h,E=h*2,I=-1;d==="RGB"&&(m=3,p=0,y=1,v=2,x=-1),f==="RGBA"?I=h*3:f==="RBG"?(L=0,E=h,T=h*2):f==="BGR"&&(E=0,T=h,L=h*2);for(let P=0;P<h;P++,p+=m,v+=m,y+=m,x+=m)_[L++]=(e[p]+u[0])/l[0],_[T++]=(e[y]+u[1])/l[1],_[E++]=(e[v]+u[2])/l[2],I!==-1&&x!==-1&&(_[I++]=(e[x]+u[3])/l[3]);return f==="RGBA"?new ma("float32",_,[1,4,t,a]):new ma("float32",_,[1,3,t,a])},gx=async(e,n)=>{let t=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,i=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,l=typeof e=="string",u,d=n??{},f=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},h=_=>typeof HTMLCanvasElement<"u"&&_ instanceof HTMLCanvasElement||_ instanceof OffscreenCanvas?_.getContext("2d"):null;if(t){let _=f();_.width=e.width,_.height=e.height;let m=h(_);if(m!=null){let p=e.height,y=e.width;if(n!==void 0&&n.resizedHeight!==void 0&&n.resizedWidth!==void 0&&(p=n.resizedHeight,y=n.resizedWidth),n!==void 0){if(d=n,n.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");d.tensorFormat="RGBA",d.height=p,d.width=y}else d.tensorFormat="RGBA",d.height=p,d.width=y;m.drawImage(e,0,0),u=m.getImageData(0,0,y,p).data}else throw new Error("Can not access image data")}else if(a){let _,m;if(n!==void 0&&n.resizedWidth!==void 0&&n.resizedHeight!==void 0?(_=n.resizedHeight,m=n.resizedWidth):(_=e.height,m=e.width),n!==void 0&&(d=n),d.format="RGBA",d.height=_,d.width=m,n!==void 0){let p=f();p.width=m,p.height=_;let y=h(p);if(y!=null)y.putImageData(e,0,0),u=y.getImageData(0,0,m,_).data;else throw new Error("Can not access image data")}else u=e.data}else if(i){if(n===void 0)throw new Error("Please provide image config with format for Imagebitmap");let _=f();_.width=e.width,_.height=e.height;let m=h(_);if(m!=null){let p=e.height,y=e.width;return m.drawImage(e,0,0,y,p),u=m.getImageData(0,0,y,p).data,d.height=p,d.width=y,qm(u,d)}else throw new Error("Can not access image data")}else{if(l)return new Promise((_,m)=>{let p=f(),y=h(p);if(!e||!y)return m();let v=new Image;v.crossOrigin="Anonymous",v.src=e,v.onload=()=>{p.width=v.width,p.height=v.height,y.drawImage(v,0,0,p.width,p.height);let x=y.getImageData(0,0,p.width,p.height);d.height=p.height,d.width=p.width,_(qm(x.data,d))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(u!==void 0)return qm(u,d);throw new Error("Input data provided is not supported - aborted tensor creation")},yx=(e,n)=>{let{width:t,height:a,download:i,dispose:l}=n,u=[1,a,t,4];return new ma({location:"texture",type:"float32",texture:e,dims:u,download:i,dispose:l})},vx=(e,n)=>{let{dataType:t,dims:a,download:i,dispose:l}=n;return new ma({location:"gpu-buffer",type:t??"float32",gpuBuffer:e,dims:a,download:i,dispose:l})},bx=(e,n)=>{let{dataType:t,dims:a,download:i,dispose:l}=n;return new ma({location:"ml-tensor",type:t??"float32",mlTensor:e,dims:a,download:i,dispose:l})},wx=(e,n,t)=>new ma({location:"cpu-pinned",type:e,data:n,dims:t??[n.length]})}),yc,Pp,Rg,Mx,CO=ut(()=>{yc=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Pp=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Rg=!1,Mx=()=>{if(!Rg){Rg=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,n=typeof BigUint64Array<"u"&&BigUint64Array.from,t=globalThis.Float16Array,a=typeof t<"u"&&t.from;e&&(yc.set("int64",BigInt64Array),Pp.set(BigInt64Array,"int64")),n&&(yc.set("uint64",BigUint64Array),Pp.set(BigUint64Array,"uint64")),a?(yc.set("float16",t),Pp.set(t,"float16")):yc.set("float16",Uint16Array)}}}),xx,Tx,PO=ut(()=>{Iy(),xx=e=>{let n=1;for(let t=0;t<e.length;t++){let a=e[t];if(typeof a!="number"||!Number.isSafeInteger(a))throw new TypeError(`dims[${t}] must be an integer, got: ${a}`);if(a<0)throw new RangeError(`dims[${t}] must be a non-negative integer, got: ${a}`);n*=a}return n},Tx=(e,n)=>{switch(e.location){case"cpu":return new ma(e.type,e.data,n);case"cpu-pinned":return new ma({location:"cpu-pinned",data:e.data,type:e.type,dims:n});case"texture":return new ma({location:"texture",texture:e.texture,type:e.type,dims:n});case"gpu-buffer":return new ma({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:n});case"ml-tensor":return new ma({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:n});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),ma,Iy=ut(()=>{EO(),SO(),CO(),PO(),ma=class{constructor(e,n,t){Mx();let a,i;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,a=e.type,i=e.dims,e.location){case"cpu-pinned":{let u=yc.get(a);if(!u)throw new TypeError(`unsupported type "${a}" to create tensor from pinned buffer`);if(!(e.data instanceof u))throw new TypeError(`buffer should be of type ${u.name}`);this.cpuData=e.data;break}case"texture":{if(a!=="float32")throw new TypeError(`unsupported type "${a}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="uint8"&&a!=="bool"&&a!=="uint4"&&a!=="int4")throw new TypeError(`unsupported type "${a}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="uint64"&&a!=="int8"&&a!=="uint8"&&a!=="bool"&&a!=="uint4"&&a!=="int4")throw new TypeError(`unsupported type "${a}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let u,d;if(typeof e=="string")if(a=e,d=t,e==="string"){if(!Array.isArray(n))throw new TypeError("A string tensor's data must be a string array.");u=n}else{let f=yc.get(e);if(f===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(n)){if(e==="float16"&&f===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${f.name} as data.`);e==="uint64"||e==="int64"?u=f.from(n,BigInt):u=f.from(n)}else if(n instanceof f)u=n;else if(n instanceof Uint8ClampedArray)if(e==="uint8")u=Uint8Array.from(n);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(e==="float16"&&n instanceof Uint16Array&&f!==Uint16Array)u=new globalThis.Float16Array(n.buffer,n.byteOffset,n.length);else throw new TypeError(`A ${a} tensor's data must be type of ${f}`)}else if(d=n,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let f=typeof e[0];if(f==="string")a="string",u=e;else if(f==="boolean")a="bool",u=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${f}.`)}else if(e instanceof Uint8ClampedArray)a="uint8",u=Uint8Array.from(e);else{let f=Pp.get(e.constructor);if(f===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);a=f,u=e}if(d===void 0)d=[u.length];else if(!Array.isArray(d))throw new TypeError("A tensor's dims must be a number array");i=d,this.cpuData=u,this.dataLocation="cpu"}let l=xx(i);if(this.cpuData&&l!==this.cpuData.length&&!((a==="uint4"||a==="int4")&&Math.ceil(l/2)===this.cpuData.length))throw new Error(`Tensor's size(${l}) does not match data length(${this.cpuData.length}).`);this.type=a,this.dims=i,this.size=l}static async fromImage(e,n){return gx(e,n)}static fromTexture(e,n){return yx(e,n)}static fromGpuBuffer(e,n){return vx(e,n)}static fromMLTensor(e,n){return bx(e,n)}static fromPinnedBuffer(e,n,t){return wx(e,n,t)}toDataURL(e){return mx(this,e)}toImageData(e){return _x(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let n=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=n,e&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Tx(this,e)}}}),bi,Ex=ut(()=>{Iy(),bi=ma}),Bp,Bg,xi,Ba,Sx=ut(()=>{px(),Bp=(e,n)=>{(typeof za.trace>"u"?!za.wasm.trace:!za.trace)||console.timeStamp(`${e}::ORT::${n}`)},Bg=(e,n)=>{let t=new Error().stack?.split(/\r\n|\r|\n/g)||[],a=!1;for(let i=0;i<t.length;i++){if(a&&!t[i].includes("TRACE_FUNC")){let l=`FUNC_${e}::${t[i].trim().split(" ")[1]}`;n&&(l+=`::${n}`),Bp("CPU",l);return}t[i].includes("TRACE_FUNC")&&(a=!0)}},xi=e=>{(typeof za.trace>"u"?!za.wasm.trace:!za.trace)||Bg("BEGIN",e)},Ba=e=>{(typeof za.trace>"u"?!za.wasm.trace:!za.trace)||Bg("END",e)}}),Cx,AO=ut(()=>{fx(),Ex(),Sx(),Cx=class Px{constructor(n){this.handler=n}async run(n,t,a){xi();let i={},l={};if(typeof n!="object"||n===null||n instanceof bi||Array.isArray(n))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof bi)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(let h of t){if(typeof h!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(h)===-1)throw new RangeError(`'fetches' contains invalid output name: ${h}.`);i[h]=null}if(typeof a=="object"&&a!==null)l=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let h=!1,_=Object.getOwnPropertyNames(t);for(let m of this.outputNames)if(_.indexOf(m)!==-1){let p=t[m];(p===null||p instanceof bi)&&(h=!0,u=!1,i[m]=p)}if(h){if(typeof a=="object"&&a!==null)l=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else l=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let h of this.inputNames)if(typeof n[h]>"u")throw new Error(`input '${h}' is missing in 'feeds'.`);if(u)for(let h of this.outputNames)i[h]=null;let d=await this.handler.run(n,i,l),f={};for(let h in d)if(Object.hasOwnProperty.call(d,h)){let _=d[h];_ instanceof bi?f[h]=_:f[h]=new bi(_.type,_.data,_.dims)}return Ba(),f}async release(){return this.handler.dispose()}static async create(n,t,a,i){xi();let l,u={};if(typeof n=="string"){if(l=n,typeof t=="object"&&t!==null)u=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(n instanceof Uint8Array){if(l=n,typeof t=="object"&&t!==null)u=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(n instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&n instanceof SharedArrayBuffer){let _=n,m=0,p=n.byteLength;if(typeof t=="object"&&t!==null)u=t;else if(typeof t=="number"){if(m=t,!Number.isSafeInteger(m))throw new RangeError("'byteOffset' must be an integer.");if(m<0||m>=_.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${_.byteLength}).`);if(p=n.byteLength-m,typeof a=="number"){if(p=a,!Number.isSafeInteger(p))throw new RangeError("'byteLength' must be an integer.");if(p<=0||m+p>_.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${_.byteLength-m}].`);if(typeof i=="object"&&i!==null)u=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(typeof a<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof t<"u")throw new TypeError("'options' must be an object.");l=new Uint8Array(_,m,p)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[d,f]=await dx(u),h=await d.createInferenceSessionHandler(l,f);return Ba(),new Px(h)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),Ly,kO=ut(()=>{AO(),Ly=Cx}),OO=ut(()=>{}),$O=ut(()=>{}),DO=ut(()=>{}),IO=ut(()=>{}),Ax={};df(Ax,{InferenceSession:()=>Ly,TRACE:()=>Bp,TRACE_FUNC_BEGIN:()=>xi,TRACE_FUNC_END:()=>Ba,Tensor:()=>bi,env:()=>Jn,registerBackend:()=>bc});var Ti=ut(()=>{MO(),TO(),kO(),Ex(),OO(),$O(),Sx(),DO(),IO()}),zy=ut(()=>{}),kx={};df(kx,{default:()=>Ox});var jg,Ng,Ox,LO=ut(()=>{zS(),Ec(),Fy(),jg="ort-wasm-proxy-worker",Ng=globalThis.self?.name===jg,Ng&&(self.onmessage=e=>{let{type:n,in:t}=e.data;try{switch(n){case"init-wasm":Ry(t.wasm).then(()=>{nv(t).then(()=>{postMessage({type:n})},a=>{postMessage({type:n,err:a})})},a=>{postMessage({type:n,err:a})});break;case"init-ep":{let{epName:a,env:i}=t;rv(i,a).then(()=>{postMessage({type:n})},l=>{postMessage({type:n,err:l})});break}case"copy-from":{let{buffer:a}=t,i=P_(a);postMessage({type:n,out:i});break}case"create":{let{model:a,options:i}=t;sv(a,i).then(l=>{postMessage({type:n,out:l})},l=>{postMessage({type:n,err:l})});break}case"release":av(t),postMessage({type:n});break;case"run":{let{sessionId:a,inputIndices:i,inputs:l,outputIndices:u,options:d}=t;iv(a,i,l,u,new Array(u.length).fill(null),d).then(f=>{f.some(h=>h[3]!=="cpu")?postMessage({type:n,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:n,out:f},lv([...l,...f]))},f=>{postMessage({type:n,err:f})});break}case"end-profiling":ov(t),postMessage({type:n});break;default:}}catch(a){postMessage({type:n,err:a})}}),Ox=Ng?null:e=>new Worker(e??pa,{type:"module",name:jg})}),$x={};df($x,{default:()=>Dx});var Ug,Vg,Dx,vb,zO=ut(()=>{Vg=(Ug=import.meta.url,async function(e={}){var n,t,a=e,i=new Promise((b,$)=>{n=b,t=$}),l=typeof window=="object",u=typeof WorkerGlobalScope<"u",d=u&&self.name?.startsWith("em-pthread");a.mountExternalData=(b,$)=>{b.startsWith("./")&&(b=b.substring(2)),(a.Eb||(a.Eb=new Map)).set(b,$)},a.unmountExternalData=()=>{delete a.Eb};var f=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,pc:!0}).buffer.constructor;let h=b=>async(...$)=>{try{if(a.Fb)throw Error("Session already started");let N=a.Fb={dc:$[0],errors:[]},K=await b(...$);if(a.Fb!==N)throw Error("Session mismatch");a.Jb?.flush();let re=N.errors;if(0<re.length){let ye=await Promise.all(re);if(ye=ye.filter(He=>He),0<ye.length)throw Error(ye.join(`
`))}return K}finally{a.Fb=null}};a.jsepInit=(b,$)=>{if(b==="webgpu"){[a.Jb,a.Ub,a.Yb,a.Kb,a.Xb,a.jb,a.Zb,a.ac,a.Vb,a.Wb,a.$b]=$;let N=a.Jb;a.jsepRegisterBuffer=(K,re,ye,He)=>N.registerBuffer(K,re,ye,He),a.jsepGetBuffer=K=>N.getBuffer(K),a.jsepCreateDownloader=(K,re,ye)=>N.createDownloader(K,re,ye),a.jsepOnCreateSession=K=>{N.onCreateSession(K)},a.jsepOnReleaseSession=K=>{N.onReleaseSession(K)},a.jsepOnRunStart=K=>N.onRunStart(K),a.bc=(K,re)=>{N.upload(K,re)}}else if(b==="webnn"){let N=$[0];[a.nc,a.Nb,a.webnnEnsureTensor,a.Ob,a.webnnDownloadTensor]=$.slice(1),a.webnnReleaseTensorId=a.Nb,a.webnnUploadTensor=a.Ob,a.webnnOnRunStart=K=>N.onRunStart(K),a.webnnOnRunEnd=N.onRunEnd.bind(N),a.webnnRegisterMLContext=(K,re)=>{N.registerMLContext(K,re)},a.webnnOnReleaseSession=K=>{N.onReleaseSession(K)},a.webnnCreateMLTensorDownloader=(K,re)=>N.createMLTensorDownloader(K,re),a.webnnRegisterMLTensor=(K,re,ye,He)=>N.registerMLTensor(K,re,ye,He),a.webnnCreateMLContext=K=>N.createMLContext(K),a.webnnRegisterMLConstant=(K,re,ye,He,at,yt)=>N.registerMLConstant(K,re,ye,He,at,a.Eb,yt),a.webnnRegisterGraphInput=N.registerGraphInput.bind(N),a.webnnIsGraphInput=N.isGraphInput.bind(N),a.webnnCreateTemporaryTensor=N.createTemporaryTensor.bind(N),a.webnnIsInt64Supported=N.isInt64Supported.bind(N)}};let _=()=>{let b=($,N,K)=>(...re)=>{let ye=Cn,He=N?.();re=$(...re);let at=N?.();return He!==at&&($=at,K(He),N=K=null),Cn!=ye?new Promise((yt,Pt)=>{nr={resolve:yt,reject:Pt}}):re};(()=>{for(let $ of["_OrtAppendExecutionProvider","_OrtCreateSession","_OrtRun","_OrtRunWithBinding","_OrtBindInput"])a[$]=b(a[$],()=>a[$],N=>a[$]=N)})(),h!==void 0&&(a._OrtRun=h(a._OrtRun),a._OrtRunWithBinding=h(a._OrtRunWithBinding)),_=void 0};a.asyncInit=()=>{_?.()};var m,p,y=Object.assign({},a),v=(b,$)=>{throw $},x="";(l||u)&&(u?x=self.location.href:typeof document<"u"&&document.currentScript&&(x=document.currentScript.src),Ug&&(x=Ug),x=x.startsWith("blob:")?"":x.slice(0,x.replace(/[?#].*/,"").lastIndexOf("/")+1),u&&(p=b=>{var $=new XMLHttpRequest;return $.open("GET",b,!1),$.responseType="arraybuffer",$.send(null),new Uint8Array($.response)}),m=async b=>{if(_e(b))return new Promise((N,K)=>{var re=new XMLHttpRequest;re.open("GET",b,!0),re.responseType="arraybuffer",re.onload=()=>{re.status==200||re.status==0&&re.response?N(re.response):K(re.status)},re.onerror=K,re.send(null)});var $=await fetch(b,{credentials:"same-origin"});if($.ok)return $.arrayBuffer();throw Error($.status+" : "+$.url)});var L=console.log.bind(console),T=console.error.bind(console),E=L,I=T;Object.assign(a,y),y=null;var P,S,k,C,D,V,U,ne,ee,H,oe,ae,W,te=a.wasmBinary,ie=!1,_e=b=>b.startsWith("file://");function q(){return P.buffer!=C.buffer&&je(),C}function B(){return P.buffer!=C.buffer&&je(),D}function R(){return P.buffer!=C.buffer&&je(),V}function Q(){return P.buffer!=C.buffer&&je(),U}function G(){return P.buffer!=C.buffer&&je(),ne}function fe(){return P.buffer!=C.buffer&&je(),ee}function Te(){return P.buffer!=C.buffer&&je(),H}function ze(){return P.buffer!=C.buffer&&je(),W}if(d){let b=function($){try{var N=$.data,K=N.Bb;if(K==="load"){let re=[];self.onmessage=ye=>re.push(ye),self.startWorker=()=>{postMessage({Bb:"loaded"});for(let ye of re)b(ye);self.onmessage=b};for(let ye of N.Rb)a[ye]&&!a[ye].proxy||(a[ye]=(...He)=>{postMessage({Bb:"callHandler",Qb:ye,args:He})},ye=="print"&&(E=a[ye]),ye=="printErr"&&(I=a[ye]));P=N.kc,je(),Ue(N.lc)}else if(K==="run"){er(N.Ab),Hr(N.Ab,0,0,1,0,0),Or(),de(N.Ab),ft||(du(),ft=!0);try{jr(N.fc,N.Hb)}catch(re){if(re!="unwind")throw re}}else N.target!=="setimmediate"&&(K==="checkMailbox"?ft&&me():K&&(I(`worker: received unknown command ${K}`),I(N)))}catch(re){throw Ha(),re}};var Ue,ft=!1;I=function(...$){$=$.join(" "),console.error($)},self.alert=function(...$){postMessage({Bb:"alert",text:$.join(" "),ic:uo()})},self.onunhandledrejection=$=>{throw $.reason||$},self.onmessage=b}function je(){var b=P.buffer;a.HEAP8=C=new Int8Array(b),a.HEAP16=V=new Int16Array(b),a.HEAPU8=D=new Uint8Array(b),a.HEAPU16=U=new Uint16Array(b),a.HEAP32=ne=new Int32Array(b),a.HEAPU32=ee=new Uint32Array(b),a.HEAPF32=H=new Float32Array(b),a.HEAPF64=W=new Float64Array(b),a.HEAP64=oe=new BigInt64Array(b),a.HEAPU64=ae=new BigUint64Array(b)}function le(){d?startWorker(a):$t.Ca()}d||(P=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),je());var J,be=0,Ae=null;function Ne(){if(--be==0&&Ae){var b=Ae;Ae=null,b()}}function De(b){throw I(b="Aborted("+b+")"),ie=!0,b=new WebAssembly.RuntimeError(b+". Build with -sASSERTIONS for more info."),t(b),b}function xe(){return{a:{L:Ge,Aa:Ee,b:ga,$:Ss,A:Kt,pa:Js,X,Z:ue,qa:pe,na:ke,ga:Qe,ma:Tt,J:At,Y:mt,V:Zt,oa:qt,W:On,va:Sn,E:Vs,Q:ya,O:Gs,D:Zr,u:et,r:ot,P:Et,z:Si,R:we,ja:F,T:Ie,aa:gt,M:vt,F:wt,ia:de,sa:dt,t:Dn,Ba:Kn,w:ms,o:As,l:Yn,c:mr,n:cs,j:ro,v:Ql,p:Cc,f:Pc,s:Ci,m:Qo,e:Ac,k:kc,i:Oc,g:$c,d:Pi,da:Xl,ea:Dc,fa:so,ba:eu,ca:tu,N:Xo,xa:Ic,ua:ff,h:su,C:Jo,G:Lc,ta:ru,x:el,ra:Ai,U:zc,q:nu,y:au,K:iu,S:ou,za:tl,ya:lu,ka:Wa,la:$i,_:lt,B:uu,I:ao,ha:rl,H:io,a:P,wa:ct}}}var Ve={829644:(b,$,N,K,re)=>{if(a===void 0||!a.Eb)return 1;if((b=En(Number(b>>>0))).startsWith("./")&&(b=b.substring(2)),!(b=a.Eb.get(b)))return 2;if($=Number($>>>0),N=Number(N>>>0),K=Number(K>>>0),$+N>b.byteLength)return 3;try{let ye=b.subarray($,$+N);switch(re){case 0:B().set(ye,K>>>0);break;case 1:a.mc?a.mc(K,ye):a.bc(K,ye);break;default:return 4}return 0}catch{return 4}},830468:(b,$,N)=>{a.Ob(b,B().subarray($>>>0,$+N>>>0))},830532:()=>a.nc(),830574:b=>{a.Nb(b)},830611:()=>{a.Vb()},830642:()=>{a.Wb()},830671:()=>{a.$b()},830696:b=>a.Ub(b),830729:b=>a.Yb(b),830761:(b,$,N)=>{a.Kb(Number(b),Number($),Number(N),!0)},830824:(b,$,N)=>{a.Kb(Number(b),Number($),Number(N))},830881:()=>typeof wasmOffsetConverter<"u",830938:b=>{a.jb("Abs",b,void 0)},830989:b=>{a.jb("Neg",b,void 0)},831040:b=>{a.jb("Floor",b,void 0)},831093:b=>{a.jb("Ceil",b,void 0)},831145:b=>{a.jb("Reciprocal",b,void 0)},831203:b=>{a.jb("Sqrt",b,void 0)},831255:b=>{a.jb("Exp",b,void 0)},831306:b=>{a.jb("Erf",b,void 0)},831357:b=>{a.jb("Sigmoid",b,void 0)},831412:(b,$,N)=>{a.jb("HardSigmoid",b,{alpha:$,beta:N})},831491:b=>{a.jb("Log",b,void 0)},831542:b=>{a.jb("Sin",b,void 0)},831593:b=>{a.jb("Cos",b,void 0)},831644:b=>{a.jb("Tan",b,void 0)},831695:b=>{a.jb("Asin",b,void 0)},831747:b=>{a.jb("Acos",b,void 0)},831799:b=>{a.jb("Atan",b,void 0)},831851:b=>{a.jb("Sinh",b,void 0)},831903:b=>{a.jb("Cosh",b,void 0)},831955:b=>{a.jb("Asinh",b,void 0)},832008:b=>{a.jb("Acosh",b,void 0)},832061:b=>{a.jb("Atanh",b,void 0)},832114:b=>{a.jb("Tanh",b,void 0)},832166:b=>{a.jb("Not",b,void 0)},832217:(b,$,N)=>{a.jb("Clip",b,{min:$,max:N})},832286:b=>{a.jb("Clip",b,void 0)},832338:(b,$)=>{a.jb("Elu",b,{alpha:$})},832396:b=>{a.jb("Gelu",b,void 0)},832448:b=>{a.jb("Relu",b,void 0)},832500:(b,$)=>{a.jb("LeakyRelu",b,{alpha:$})},832564:(b,$)=>{a.jb("ThresholdedRelu",b,{alpha:$})},832634:(b,$)=>{a.jb("Cast",b,{to:$})},832692:b=>{a.jb("Add",b,void 0)},832743:b=>{a.jb("Sub",b,void 0)},832794:b=>{a.jb("Mul",b,void 0)},832845:b=>{a.jb("Div",b,void 0)},832896:b=>{a.jb("Pow",b,void 0)},832947:b=>{a.jb("Equal",b,void 0)},833e3:b=>{a.jb("Greater",b,void 0)},833055:b=>{a.jb("GreaterOrEqual",b,void 0)},833117:b=>{a.jb("Less",b,void 0)},833169:b=>{a.jb("LessOrEqual",b,void 0)},833228:(b,$,N,K,re)=>{a.jb("ReduceMean",b,{keepDims:!!$,noopWithEmptyAxes:!!N,axes:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[]})},833403:(b,$,N,K,re)=>{a.jb("ReduceMax",b,{keepDims:!!$,noopWithEmptyAxes:!!N,axes:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[]})},833577:(b,$,N,K,re)=>{a.jb("ReduceMin",b,{keepDims:!!$,noopWithEmptyAxes:!!N,axes:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[]})},833751:(b,$,N,K,re)=>{a.jb("ReduceProd",b,{keepDims:!!$,noopWithEmptyAxes:!!N,axes:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[]})},833926:(b,$,N,K,re)=>{a.jb("ReduceSum",b,{keepDims:!!$,noopWithEmptyAxes:!!N,axes:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[]})},834100:(b,$,N,K,re)=>{a.jb("ReduceL1",b,{keepDims:!!$,noopWithEmptyAxes:!!N,axes:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[]})},834273:(b,$,N,K,re)=>{a.jb("ReduceL2",b,{keepDims:!!$,noopWithEmptyAxes:!!N,axes:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[]})},834446:(b,$,N,K,re)=>{a.jb("ReduceLogSum",b,{keepDims:!!$,noopWithEmptyAxes:!!N,axes:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[]})},834623:(b,$,N,K,re)=>{a.jb("ReduceSumSquare",b,{keepDims:!!$,noopWithEmptyAxes:!!N,axes:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[]})},834803:(b,$,N,K,re)=>{a.jb("ReduceLogSumExp",b,{keepDims:!!$,noopWithEmptyAxes:!!N,axes:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[]})},834983:b=>{a.jb("Where",b,void 0)},835036:(b,$,N)=>{a.jb("Transpose",b,{perm:$?Array.from(G().subarray(Number($)>>>0,Number(N)>>>0)):[]})},835160:(b,$,N,K)=>{a.jb("DepthToSpace",b,{blocksize:$,mode:En(N),format:K?"NHWC":"NCHW"})},835293:(b,$,N,K)=>{a.jb("DepthToSpace",b,{blocksize:$,mode:En(N),format:K?"NHWC":"NCHW"})},835426:(b,$,N,K,re,ye,He,at,yt,Pt,jt,Xt,gn,Pn,Ir)=>{a.jb("ConvTranspose",b,{format:yt?"NHWC":"NCHW",autoPad:$,dilations:[N],group:K,kernelShape:[re],pads:[ye,He],strides:[at],wIsConst:()=>!!q()[Pt>>>0],outputPadding:jt?Array.from(G().subarray(Number(jt)>>>0,Number(Xt)>>>0)):[],outputShape:gn?Array.from(G().subarray(Number(gn)>>>0,Number(Pn)>>>0)):[],activation:En(Ir)})},835859:(b,$,N,K,re,ye,He,at,yt,Pt,jt,Xt,gn,Pn)=>{a.jb("ConvTranspose",b,{format:at?"NHWC":"NCHW",autoPad:$,dilations:Array.from(G().subarray(Number(N)>>>0,2+(Number(N)>>>0)>>>0)),group:K,kernelShape:Array.from(G().subarray(Number(re)>>>0,2+(Number(re)>>>0)>>>0)),pads:Array.from(G().subarray(Number(ye)>>>0,4+(Number(ye)>>>0)>>>0)),strides:Array.from(G().subarray(Number(He)>>>0,2+(Number(He)>>>0)>>>0)),wIsConst:()=>!!q()[yt>>>0],outputPadding:Pt?Array.from(G().subarray(Number(Pt)>>>0,Number(jt)>>>0)):[],outputShape:Xt?Array.from(G().subarray(Number(Xt)>>>0,Number(gn)>>>0)):[],activation:En(Pn)})},836520:(b,$,N,K,re,ye,He,at,yt,Pt,jt,Xt,gn,Pn,Ir)=>{a.jb("ConvTranspose",b,{format:yt?"NHWC":"NCHW",autoPad:$,dilations:[N],group:K,kernelShape:[re],pads:[ye,He],strides:[at],wIsConst:()=>!!q()[Pt>>>0],outputPadding:jt?Array.from(G().subarray(Number(jt)>>>0,Number(Xt)>>>0)):[],outputShape:gn?Array.from(G().subarray(Number(gn)>>>0,Number(Pn)>>>0)):[],activation:En(Ir)})},836953:(b,$,N,K,re,ye,He,at,yt,Pt,jt,Xt,gn,Pn)=>{a.jb("ConvTranspose",b,{format:at?"NHWC":"NCHW",autoPad:$,dilations:Array.from(G().subarray(Number(N)>>>0,2+(Number(N)>>>0)>>>0)),group:K,kernelShape:Array.from(G().subarray(Number(re)>>>0,2+(Number(re)>>>0)>>>0)),pads:Array.from(G().subarray(Number(ye)>>>0,4+(Number(ye)>>>0)>>>0)),strides:Array.from(G().subarray(Number(He)>>>0,2+(Number(He)>>>0)>>>0)),wIsConst:()=>!!q()[yt>>>0],outputPadding:Pt?Array.from(G().subarray(Number(Pt)>>>0,Number(jt)>>>0)):[],outputShape:Xt?Array.from(G().subarray(Number(Xt)>>>0,Number(gn)>>>0)):[],activation:En(Pn)})},837614:(b,$)=>{a.jb("GlobalAveragePool",b,{format:$?"NHWC":"NCHW"})},837705:(b,$,N,K,re,ye,He,at,yt,Pt,jt,Xt,gn,Pn)=>{a.jb("AveragePool",b,{format:Pn?"NHWC":"NCHW",auto_pad:$,ceil_mode:N,count_include_pad:K,storage_order:re,dilations:ye?Array.from(G().subarray(Number(ye)>>>0,Number(He)>>>0)):[],kernel_shape:at?Array.from(G().subarray(Number(at)>>>0,Number(yt)>>>0)):[],pads:Pt?Array.from(G().subarray(Number(Pt)>>>0,Number(jt)>>>0)):[],strides:Xt?Array.from(G().subarray(Number(Xt)>>>0,Number(gn)>>>0)):[]})},838184:(b,$)=>{a.jb("GlobalAveragePool",b,{format:$?"NHWC":"NCHW"})},838275:(b,$,N,K,re,ye,He,at,yt,Pt,jt,Xt,gn,Pn)=>{a.jb("AveragePool",b,{format:Pn?"NHWC":"NCHW",auto_pad:$,ceil_mode:N,count_include_pad:K,storage_order:re,dilations:ye?Array.from(G().subarray(Number(ye)>>>0,Number(He)>>>0)):[],kernel_shape:at?Array.from(G().subarray(Number(at)>>>0,Number(yt)>>>0)):[],pads:Pt?Array.from(G().subarray(Number(Pt)>>>0,Number(jt)>>>0)):[],strides:Xt?Array.from(G().subarray(Number(Xt)>>>0,Number(gn)>>>0)):[]})},838754:(b,$)=>{a.jb("GlobalMaxPool",b,{format:$?"NHWC":"NCHW"})},838841:(b,$,N,K,re,ye,He,at,yt,Pt,jt,Xt,gn,Pn)=>{a.jb("MaxPool",b,{format:Pn?"NHWC":"NCHW",auto_pad:$,ceil_mode:N,count_include_pad:K,storage_order:re,dilations:ye?Array.from(G().subarray(Number(ye)>>>0,Number(He)>>>0)):[],kernel_shape:at?Array.from(G().subarray(Number(at)>>>0,Number(yt)>>>0)):[],pads:Pt?Array.from(G().subarray(Number(Pt)>>>0,Number(jt)>>>0)):[],strides:Xt?Array.from(G().subarray(Number(Xt)>>>0,Number(gn)>>>0)):[]})},839316:(b,$)=>{a.jb("GlobalMaxPool",b,{format:$?"NHWC":"NCHW"})},839403:(b,$,N,K,re,ye,He,at,yt,Pt,jt,Xt,gn,Pn)=>{a.jb("MaxPool",b,{format:Pn?"NHWC":"NCHW",auto_pad:$,ceil_mode:N,count_include_pad:K,storage_order:re,dilations:ye?Array.from(G().subarray(Number(ye)>>>0,Number(He)>>>0)):[],kernel_shape:at?Array.from(G().subarray(Number(at)>>>0,Number(yt)>>>0)):[],pads:Pt?Array.from(G().subarray(Number(Pt)>>>0,Number(jt)>>>0)):[],strides:Xt?Array.from(G().subarray(Number(Xt)>>>0,Number(gn)>>>0)):[]})},839878:(b,$,N,K,re)=>{a.jb("Gemm",b,{alpha:$,beta:N,transA:K,transB:re})},839982:b=>{a.jb("MatMul",b,void 0)},840036:(b,$,N,K)=>{a.jb("ArgMax",b,{keepDims:!!$,selectLastIndex:!!N,axis:K})},840144:(b,$,N,K)=>{a.jb("ArgMin",b,{keepDims:!!$,selectLastIndex:!!N,axis:K})},840252:(b,$)=>{a.jb("Softmax",b,{axis:$})},840315:(b,$)=>{a.jb("Concat",b,{axis:$})},840375:(b,$,N,K,re)=>{a.jb("Split",b,{axis:$,numOutputs:N,splitSizes:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[]})},840531:b=>{a.jb("Expand",b,void 0)},840585:(b,$)=>{a.jb("Gather",b,{axis:Number($)})},840656:(b,$)=>{a.jb("GatherElements",b,{axis:Number($)})},840735:(b,$)=>{a.jb("GatherND",b,{batch_dims:Number($)})},840814:(b,$,N,K,re,ye,He,at,yt,Pt,jt)=>{a.jb("Resize",b,{antialias:$,axes:N?Array.from(G().subarray(Number(N)>>>0,Number(K)>>>0)):[],coordinateTransformMode:En(re),cubicCoeffA:ye,excludeOutside:He,extrapolationValue:at,keepAspectRatioPolicy:En(yt),mode:En(Pt),nearestMode:En(jt)})},841176:(b,$,N,K,re,ye,He)=>{a.jb("Slice",b,{starts:$?Array.from(G().subarray(Number($)>>>0,Number(N)>>>0)):[],ends:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[],axes:ye?Array.from(G().subarray(Number(ye)>>>0,Number(He)>>>0)):[]})},841440:b=>{a.jb("Tile",b,void 0)},841492:(b,$,N)=>{a.jb("InstanceNormalization",b,{epsilon:$,format:N?"NHWC":"NCHW"})},841606:(b,$,N)=>{a.jb("InstanceNormalization",b,{epsilon:$,format:N?"NHWC":"NCHW"})},841720:b=>{a.jb("Range",b,void 0)},841773:(b,$)=>{a.jb("Einsum",b,{equation:En($)})},841854:(b,$,N,K,re)=>{a.jb("Pad",b,{mode:$,value:N,pads:K?Array.from(G().subarray(Number(K)>>>0,Number(re)>>>0)):[]})},841997:(b,$,N,K,re,ye)=>{a.jb("BatchNormalization",b,{epsilon:$,momentum:N,spatial:!!re,trainingMode:!!K,format:ye?"NHWC":"NCHW"})},842166:(b,$,N,K,re,ye)=>{a.jb("BatchNormalization",b,{epsilon:$,momentum:N,spatial:!!re,trainingMode:!!K,format:ye?"NHWC":"NCHW"})},842335:(b,$,N)=>{a.jb("CumSum",b,{exclusive:Number($),reverse:Number(N)})},842432:(b,$,N)=>{a.jb("DequantizeLinear",b,{axis:$,blockSize:N})},842522:(b,$,N,K,re)=>{a.jb("GridSample",b,{align_corners:$,mode:En(N),padding_mode:En(K),format:re?"NHWC":"NCHW"})},842692:(b,$,N,K,re)=>{a.jb("GridSample",b,{align_corners:$,mode:En(N),padding_mode:En(K),format:re?"NHWC":"NCHW"})},842862:(b,$)=>{a.jb("ScatterND",b,{reduction:En($)})},842947:(b,$,N,K,re,ye,He,at,yt)=>{a.jb("Attention",b,{numHeads:$,isUnidirectional:N,maskFilterValue:K,scale:re,doRotary:ye,qkvHiddenSizes:He?Array.from(G().subarray(Number(at)>>>0,Number(at)+He>>>0)):[],pastPresentShareBuffer:!!yt})},843219:b=>{a.jb("BiasAdd",b,void 0)},843274:b=>{a.jb("BiasSplitGelu",b,void 0)},843335:b=>{a.jb("FastGelu",b,void 0)},843391:(b,$,N,K,re,ye,He,at,yt,Pt,jt,Xt,gn,Pn,Ir,Ta)=>{a.jb("Conv",b,{format:Xt?"NHWC":"NCHW",auto_pad:$,dilations:N?Array.from(G().subarray(Number(N)>>>0,Number(K)>>>0)):[],group:re,kernel_shape:ye?Array.from(G().subarray(Number(ye)>>>0,Number(He)>>>0)):[],pads:at?Array.from(G().subarray(Number(at)>>>0,Number(yt)>>>0)):[],strides:Pt?Array.from(G().subarray(Number(Pt)>>>0,Number(jt)>>>0)):[],w_is_const:()=>!!q()[Number(gn)>>>0],activation:En(Pn),activation_params:Ir?Array.from(Te().subarray(Number(Ir)>>>0,Number(Ta)>>>0)):[]})},843975:b=>{a.jb("Gelu",b,void 0)},844027:(b,$,N,K,re,ye,He,at,yt)=>{a.jb("GroupQueryAttention",b,{numHeads:$,kvNumHeads:N,scale:K,softcap:re,doRotary:ye,rotaryInterleaved:He,smoothSoftmax:at,localWindowSize:yt})},844244:(b,$,N,K)=>{a.jb("LayerNormalization",b,{axis:$,epsilon:N,simplified:!!K})},844355:(b,$,N,K)=>{a.jb("LayerNormalization",b,{axis:$,epsilon:N,simplified:!!K})},844466:(b,$,N,K,re,ye)=>{a.jb("MatMulNBits",b,{k:$,n:N,accuracyLevel:K,bits:re,blockSize:ye})},844593:(b,$,N,K,re,ye)=>{a.jb("MultiHeadAttention",b,{numHeads:$,isUnidirectional:N,maskFilterValue:K,scale:re,doRotary:ye})},844752:(b,$)=>{a.jb("QuickGelu",b,{alpha:$})},844816:(b,$,N,K,re)=>{a.jb("RotaryEmbedding",b,{interleaved:!!$,numHeads:N,rotaryEmbeddingDim:K,scale:re})},844955:(b,$,N)=>{a.jb("SkipLayerNormalization",b,{epsilon:$,simplified:!!N})},845057:(b,$,N)=>{a.jb("SkipLayerNormalization",b,{epsilon:$,simplified:!!N})},845159:(b,$,N,K)=>{a.jb("GatherBlockQuantized",b,{gatherAxis:$,quantizeAxis:N,blockSize:K})},845280:b=>{a.Zb(b)},845314:(b,$)=>a.ac(Number(b),Number($),a.Fb.dc,a.Fb.errors)};function Ee(b,$,N){return ps(async()=>{await a.Xb(Number(b),Number($),Number(N))})}function Ge(){return typeof wasmOffsetConverter<"u"}class Ye{name="ExitStatus";constructor($){this.message=`Program terminated with exit(${$})`,this.status=$}}var _t=b=>{b.terminate(),b.onmessage=()=>{}},Re=[],xt=b=>{Mt.length==0&&($r(),Br(Mt[0]));var $=Mt.pop();if(!$)return 6;tn.push($),Ft[b.Ab]=$,$.Ab=b.Ab;var N={Bb:"run",fc:b.ec,Hb:b.Hb,Ab:b.Ab};return $.postMessage(N,b.Mb),0},st=0,nt=(b,$,...N)=>{for(var K=2*N.length,re=xa(),ye=Li(8*K),He=ye>>>3,at=0;at<N.length;at++){var yt=N[at];typeof yt=="bigint"?(oe[He+2*at]=1n,oe[He+2*at+1]=yt):(oe[He+2*at]=0n,ze()[He+2*at+1>>>0]=yt)}return b=co(b,0,K,ye,$),Os(re),b};function ct(b){if(d)return nt(0,1,b);if(k=b,!(0<st)){for(var $ of tn)_t($);for($ of Mt)_t($);Mt=[],tn=[],Ft={},ie=!0}v(0,new Ye(b))}function pt(b){if(d)return nt(1,0,b);lt(b)}var lt=b=>{if(k=b,d)throw pt(b),"unwind";ct(b)},Mt=[],tn=[],an=[],Ft={},or=b=>{var $=b.Ab;delete Ft[$],Mt.push(b),tn.splice(tn.indexOf(b),1),b.Ab=0,al($)};function Or(){an.forEach(b=>b())}var Br=b=>new Promise($=>{b.onmessage=re=>{var ye=(re=re.data).Bb;if(re.Gb&&re.Gb!=uo()){var He=Ft[re.Gb];He?He.postMessage(re,re.Mb):I(`Internal error! Worker sent a message "${ye}" to target pthread ${re.Gb}, but that thread no longer exists!`)}else ye==="checkMailbox"?me():ye==="spawnThread"?xt(re):ye==="cleanupThread"?or(Ft[re.hc]):ye==="loaded"?(b.loaded=!0,$(b)):ye==="alert"?alert(`Thread ${re.ic}: ${re.text}`):re.target==="setimmediate"?b.postMessage(re):ye==="callHandler"?a[re.Qb](...re.args):ye&&I(`worker sent an unknown command ${ye}`)},b.onerror=re=>{throw I(`worker sent an error! ${re.filename}:${re.lineno}: ${re.message}`),re};var N,K=[];for(N of[])a.propertyIsEnumerable(N)&&K.push(N);b.postMessage({Bb:"load",Rb:K,kc:P,lc:S})});function $r(){var b=new Worker((()=>{let $=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new $("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});Mt.push(b)}var er=b=>{je();var $=fe()[b+52>>>2>>>0];b=fe()[b+56>>>2>>>0],fu($,$-b),Os($)},jr=(b,$)=>{st=0,b=zi(b,$),0<st?k=b:fo(b)};class ja{constructor($){this.Ib=$-24}}function ga(b,$,N){var K=new ja(b>>>=0);throw $>>>=0,N>>>=0,fe()[K.Ib+16>>>2>>>0]=0,fe()[K.Ib+4>>>2>>>0]=$,fe()[K.Ib+8>>>2>>>0]=N,b}function Es(b,$,N,K){return d?nt(2,1,b,$,N,K):Ss(b,$,N,K)}function Ss(b,$,N,K){if(b>>>=0,N>>>=0,K>>>=0,f===void 0)return 6;var re=[];return d&&re.length===0?Es(b,$>>>=0,N,K):(b={ec:N,Ab:b,Hb:K,Mb:re},d?(b.Bb="spawnThread",postMessage(b,re),0):xt(b))}var zt=typeof TextDecoder<"u"?new TextDecoder:void 0,Zs=(b,$=0,N=NaN)=>{var K=($>>>=0)+N;for(N=$;b[N]&&!(N>=K);)++N;if(16<N-$&&b.buffer&&zt)return zt.decode(b.buffer instanceof ArrayBuffer?b.subarray($,N):b.slice($,N));for(K="";$<N;){var re=b[$++];if(128&re){var ye=63&b[$++];if((224&re)==192)K+=String.fromCharCode((31&re)<<6|ye);else{var He=63&b[$++];65536>(re=(240&re)==224?(15&re)<<12|ye<<6|He:(7&re)<<18|ye<<12|He<<6|63&b[$++])?K+=String.fromCharCode(re):(re-=65536,K+=String.fromCharCode(55296|re>>10,56320|1023&re))}}else K+=String.fromCharCode(re)}return K},En=(b,$)=>(b>>>=0)?Zs(B(),b,$):"";function Kt(b,$,N){return d?nt(3,1,b,$,N):0}function Js(b,$){if(d)return nt(4,1,b,$)}var z=b=>{for(var $=0,N=0;N<b.length;++N){var K=b.charCodeAt(N);127>=K?$++:2047>=K?$+=2:55296<=K&&57343>=K?($+=4,++N):$+=3}return $},ce=(b,$,N)=>{var K=B();if($>>>=0,0<N){var re=$;N=$+N-1;for(var ye=0;ye<b.length;++ye){var He=b.charCodeAt(ye);if(55296<=He&&57343>=He&&(He=65536+((1023&He)<<10)|1023&b.charCodeAt(++ye)),127>=He){if($>=N)break;K[$++>>>0]=He}else{if(2047>=He){if($+1>=N)break;K[$++>>>0]=192|He>>6}else{if(65535>=He){if($+2>=N)break;K[$++>>>0]=224|He>>12}else{if($+3>=N)break;K[$++>>>0]=240|He>>18,K[$++>>>0]=128|He>>12&63}K[$++>>>0]=128|He>>6&63}K[$++>>>0]=128|63&He}}K[$>>>0]=0,b=$-re}else b=0;return b};function X(b,$){if(d)return nt(5,1,b,$)}function ue(b,$,N){if(d)return nt(6,1,b,$,N)}function pe(b,$,N){return d?nt(7,1,b,$,N):0}function ke(b,$){if(d)return nt(8,1,b,$)}function Qe(b,$,N){if(d)return nt(9,1,b,$,N)}function Tt(b,$,N,K){if(d)return nt(10,1,b,$,N,K)}function At(b,$,N,K){if(d)return nt(11,1,b,$,N,K)}function mt(b,$,N,K){if(d)return nt(12,1,b,$,N,K)}function Zt(b){if(d)return nt(13,1,b)}function qt(b,$){if(d)return nt(14,1,b,$)}function On(b,$,N){if(d)return nt(15,1,b,$,N)}var wn,Un,Sn=()=>De(""),Bn=b=>{for(var $="";B()[b>>>0];)$+=wn[B()[b++>>>0]];return $},hr={},pr={};function lr(b,$,N={}){return(function(K,re,ye={}){var He=re.name;if(!K)throw new Un(`type "${He}" must have a positive integer typeid pointer`);if(pr.hasOwnProperty(K)){if(ye.Sb)return;throw new Un(`Cannot register type '${He}' twice`)}pr[K]=re,hr.hasOwnProperty(K)&&(re=hr[K],delete hr[K],re.forEach(at=>at()))})(b,$,N)}var ea=(b,$,N)=>{switch($){case 1:return N?K=>q()[K>>>0]:K=>B()[K>>>0];case 2:return N?K=>R()[K>>>1>>>0]:K=>Q()[K>>>1>>>0];case 4:return N?K=>G()[K>>>2>>>0]:K=>fe()[K>>>2>>>0];case 8:return N?K=>oe[K>>>3]:K=>ae[K>>>3];default:throw new TypeError(`invalid integer width (${$}): ${b}`)}};function Vs(b,$,N){N>>>=0,lr(b>>>=0,{name:$=Bn($>>>0),fromWireType:K=>K,toWireType:function(K,re){if(typeof re!="bigint"&&typeof re!="number")throw re=re===null?"null":(K=typeof re)=="object"||K==="array"||K==="function"?re.toString():""+re,new TypeError(`Cannot convert "${re}" to ${this.name}`);return typeof re=="number"&&(re=BigInt(re)),re},Cb:Xr,readValueFromPointer:ea($,N,$.indexOf("u")==-1),Db:null})}var Xr=8;function ya(b,$,N,K){lr(b>>>=0,{name:$=Bn($>>>0),fromWireType:function(re){return!!re},toWireType:function(re,ye){return ye?N:K},Cb:Xr,readValueFromPointer:function(re){return this.fromWireType(B()[re>>>0])},Db:null})}var Vr=[],ur=[];function mr(b){9<(b>>>=0)&&--ur[b+1]==0&&(ur[b]=void 0,Vr.push(b))}var tr=b=>{if(!b)throw new Un("Cannot use deleted val. handle = "+b);return ur[b]},Er=b=>{switch(b){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let $=Vr.pop()||ur.length;return ur[$]=b,ur[$+1]=1,$}};function Yr(b){return this.fromWireType(fe()[b>>>2>>>0])}var ls={name:"emscripten::val",fromWireType:b=>{var $=tr(b);return mr(b),$},toWireType:(b,$)=>Er($),Cb:Xr,readValueFromPointer:Yr,Db:null};function Gs(b){return lr(b>>>0,ls)}var Na=(b,$)=>{switch($){case 4:return function(N){return this.fromWireType(Te()[N>>>2>>>0])};case 8:return function(N){return this.fromWireType(ze()[N>>>3>>>0])};default:throw new TypeError(`invalid float width (${$}): ${b}`)}};function Zr(b,$,N){N>>>=0,lr(b>>>=0,{name:$=Bn($>>>0),fromWireType:K=>K,toWireType:(K,re)=>re,Cb:Xr,readValueFromPointer:Na($,N),Db:null})}function et(b,$,N,K,re){if(b>>>=0,N>>>=0,$=Bn($>>>0),re===-1&&(re=4294967295),re=at=>at,K===0){var ye=32-8*N;re=at=>at<<ye>>>ye}var He=$.includes("unsigned")?function(at,yt){return yt>>>0}:function(at,yt){return yt};lr(b,{name:$,fromWireType:re,toWireType:He,Cb:Xr,readValueFromPointer:ea($,N,K!==0),Db:null})}function ot(b,$,N){function K(ye){var He=fe()[ye>>>2>>>0];return ye=fe()[ye+4>>>2>>>0],new re(q().buffer,ye,He)}var re=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][$];lr(b>>>=0,{name:N=Bn(N>>>0),fromWireType:K,Cb:Xr,readValueFromPointer:K},{Sb:!0})}function Et(b,$){lr(b>>>=0,{name:$=Bn($>>>0),fromWireType:function(N){for(var K,re=fe()[N>>>2>>>0],ye=N+4,He=ye,at=0;at<=re;++at){var yt=ye+at;at!=re&&B()[yt>>>0]!=0||(He=En(He,yt-He),K===void 0?K=He:(K+="\0",K+=He),He=yt+1)}return ks(N),K},toWireType:function(N,K){K instanceof ArrayBuffer&&(K=new Uint8Array(K));var re=typeof K=="string";if(!(re||K instanceof Uint8Array||K instanceof Uint8ClampedArray||K instanceof Int8Array))throw new Un("Cannot pass non-string to std::string");var ye=re?z(K):K.length,He=Ii(4+ye+1),at=He+4;if(fe()[He>>>2>>>0]=ye,re)ce(K,at,ye+1);else if(re)for(re=0;re<ye;++re){var yt=K.charCodeAt(re);if(255<yt)throw ks(He),new Un("String has UTF-16 code units that do not fit in 8 bits");B()[at+re>>>0]=yt}else for(re=0;re<ye;++re)B()[at+re>>>0]=K[re];return N!==null&&N.push(ks,He),He},Cb:Xr,readValueFromPointer:Yr,Db(N){ks(N)}})}var $n=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,va=(b,$)=>{for(var N=b>>1,K=N+$/2;!(N>=K)&&Q()[N>>>0];)++N;if(32<(N<<=1)-b&&$n)return $n.decode(B().slice(b,N));for(N="",K=0;!(K>=$/2);++K){var re=R()[b+2*K>>>1>>>0];if(re==0)break;N+=String.fromCharCode(re)}return N},Cs=(b,$,N)=>{if(N??=2147483647,2>N)return 0;var K=$;N=(N-=2)<2*b.length?N/2:b.length;for(var re=0;re<N;++re){var ye=b.charCodeAt(re);R()[$>>>1>>>0]=ye,$+=2}return R()[$>>>1>>>0]=0,$-K},Ps=b=>2*b.length,Gr=(b,$)=>{for(var N=0,K="";!(N>=$/4);){var re=G()[b+4*N>>>2>>>0];if(re==0)break;++N,65536<=re?(re-=65536,K+=String.fromCharCode(55296|re>>10,56320|1023&re)):K+=String.fromCharCode(re)}return K},Ua=(b,$,N)=>{if($>>>=0,N??=2147483647,4>N)return 0;var K=$;N=K+N-4;for(var re=0;re<b.length;++re){var ye=b.charCodeAt(re);if(55296<=ye&&57343>=ye&&(ye=65536+((1023&ye)<<10)|1023&b.charCodeAt(++re)),G()[$>>>2>>>0]=ye,($+=4)+4>N)break}return G()[$>>>2>>>0]=0,$-K},Ei=b=>{for(var $=0,N=0;N<b.length;++N){var K=b.charCodeAt(N);55296<=K&&57343>=K&&++N,$+=4}return $};function Si(b,$,N){if(b>>>=0,$>>>=0,N=Bn(N>>>=0),$===2)var K=va,re=Cs,ye=Ps,He=at=>Q()[at>>>1>>>0];else $===4&&(K=Gr,re=Ua,ye=Ei,He=at=>fe()[at>>>2>>>0]);lr(b,{name:N,fromWireType:at=>{for(var yt,Pt=fe()[at>>>2>>>0],jt=at+4,Xt=0;Xt<=Pt;++Xt){var gn=at+4+Xt*$;Xt!=Pt&&He(gn)!=0||(jt=K(jt,gn-jt),yt===void 0?yt=jt:(yt+="\0",yt+=jt),jt=gn+$)}return ks(at),yt},toWireType:(at,yt)=>{if(typeof yt!="string")throw new Un(`Cannot pass non-string to C++ string type ${N}`);var Pt=ye(yt),jt=Ii(4+Pt+$);return fe()[jt>>>2>>>0]=Pt/$,re(yt,jt+4,Pt+$),at!==null&&at.push(ks,jt),jt},Cb:Xr,readValueFromPointer:Yr,Db(at){ks(at)}})}function we(b,$){lr(b>>>=0,{Tb:!0,name:$=Bn($>>>0),Cb:0,fromWireType:()=>{},toWireType:()=>{}})}function F(b){Hr(b>>>0,!u,1,!l,131072,!1),Or()}var se=b=>{if(!ie)try{if(b(),!(0<st))try{d?fo(k):lt(k)}catch($){$ instanceof Ye||$=="unwind"||v(0,$)}}catch($){$ instanceof Ye||$=="unwind"||v(0,$)}};function de(b){b>>>=0,typeof Atomics.jc=="function"&&(Atomics.jc(G(),b>>>2,b).value.then(me),b+=128,Atomics.store(G(),b>>>2,1))}var me=()=>{var b=uo();b&&(de(b),se(po))};function Ie(b,$){(b>>>=0)==$>>>0?setTimeout(me):d?postMessage({Gb:b,Bb:"checkMailbox"}):(b=Ft[b])&&b.postMessage({Bb:"checkMailbox"})}var Ke=[];function gt(b,$,N,K,re){for($>>>=0,K/=2,Ke.length=K,N=re>>>0>>>3,re=0;re<K;re++)Ke[re]=oe[N+2*re]?oe[N+2*re+1]:ze()[N+2*re+1>>>0];return($?Ve[$]:cu[b])(...Ke)}var vt=()=>{st=0};function wt(b){b>>>=0,d?postMessage({Bb:"cleanupThread",hc:b}):or(Ft[b])}function dt(b){}var Qt=(b,$)=>{var N=pr[b];if(N===void 0)throw b=lo(b),N=Bn(b),ks(b),new Un(`${$} has unknown type ${N}`);return N},Ut=(b,$,N)=>{var K=[];return b=b.toWireType(K,N),K.length&&(fe()[$>>>2>>>0]=Er(K)),b};function Dn(b,$,N){return $>>>=0,N>>>=0,b=tr(b>>>0),$=Qt($,"emval::as"),Ut($,N,b)}function Kn(b,$){return $>>>=0,b=tr(b>>>0),($=Qt($,"emval::as")).toWireType(null,b)}var jn=b=>{try{b()}catch($){De($)}},Vn=0,Cn=null,Wr=0,Dr=[],_r={},us={},vn=0,nr=null,gr=[];function ps(b){return(function($){if(!ie){if(Vn===0){var N=!1,K=!1;$((re=0)=>{if(!ie&&(Wr=re,N=!0,K)){Vn=2,jn(()=>ra(Cn)),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.resume(),re=!1;try{var ye=(function(){var yt=G()[Cn+8>>>2>>>0];return yt=$t[us[yt]],--st,yt()})()}catch(yt){ye=yt,re=!0}var He=!1;if(!Cn){var at=nr;at&&(nr=null,(re?at.reject:at.resolve)(ye),He=!0)}if(re&&!He)throw ye}}),K=!0,N||(Vn=1,Cn=(function(){var re=Ii(65548),ye=re+12;fe()[re>>>2>>>0]=ye,fe()[re+4>>>2>>>0]=ye+65536,ye=Dr[0];var He=_r[ye];return He===void 0&&(He=vn++,_r[ye]=He,us[He]=ye),ye=He,G()[re+8>>>2>>>0]=ye,re})(),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.pause(),jn(()=>il(Cn)))}else Vn===2?(Vn=0,jn(mo),ks(Cn),Cn=null,gr.forEach(se)):De(`invalid state: ${Vn}`);return Wr}})($=>{b().then($)})}function ms(b){return b>>>=0,ps(async()=>{var $=await tr(b);return Er($)})}var rr=[];function As(b,$,N,K){return N>>>=0,K>>>=0,(b=rr[b>>>0])(null,$=tr($>>>0),N,K)}var _n={},Mn=b=>{var $=_n[b];return $===void 0?Bn(b):$};function Yn(b,$,N,K,re){return N>>>=0,K>>>=0,re>>>=0,(b=rr[b>>>0])($=tr($>>>0),$[N=Mn(N)],K,re)}var Nn=()=>typeof globalThis=="object"?globalThis:Function("return this")();function cs(b){return(b>>>=0)==0?Er(Nn()):(b=Mn(b),Er(Nn()[b]))}var ba=b=>{var $=rr.length;return rr.push(b),$},Ws=(b,$)=>{for(var N=Array(b),K=0;K<b;++K)N[K]=Qt(fe()[$+4*K>>>2>>>0],"parameter "+K);return N},Va=(b,$)=>Object.defineProperty($,"name",{value:b});function ro(b,$,N){var K=($=Ws(b,$>>>0)).shift();b--;var re=`return function (obj, func, destructorsRef, args) {
`,ye=0,He=[];N===0&&He.push("obj");for(var at=["retType"],yt=[K],Pt=0;Pt<b;++Pt)He.push("arg"+Pt),at.push("argType"+Pt),yt.push($[Pt]),re+=`  var arg${Pt} = argType${Pt}.readValueFromPointer(args${ye?"+"+ye:""});
`,ye+=$[Pt].Cb;return re+=`  var rv = ${N===1?"new func":"func.call"}(${He.join(", ")});
`,K.Tb||(at.push("emval_returnValue"),yt.push(Ut),re+=`  return emval_returnValue(retType, destructorsRef, rv);
`),at.push(re+`};
`),b=(function(jt){var Xt=Function;if(!(Xt instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof Xt} which is not a function`);var gn=Va(Xt.name||"unknownFunctionName",function(){});return gn.prototype=Xt.prototype,gn=new gn,(jt=Xt.apply(gn,jt))instanceof Object?jt:gn})(at)(...yt),N=`methodCaller<(${$.map(jt=>jt.name).join(", ")}) => ${K.name}>`,ba(Va(N,b))}function Ql(b){return b=Mn(b>>>0),Er(a[b])}function Cc(b,$){return $>>>=0,b=tr(b>>>0),$=tr($),Er(b[$])}function Pc(b){9<(b>>>=0)&&(ur[b+1]+=1)}function Ci(){return Er([])}function Qo(b){b=tr(b>>>0);for(var $=Array(b.length),N=0;N<b.length;N++)$[N]=b[N];return Er($)}function Ac(b){return Er(Mn(b>>>0))}function kc(){return Er({})}function Oc(b){for(var $=tr(b>>>=0);$.length;){var N=$.pop();$.pop()(N)}mr(b)}function $c(b,$,N){$>>>=0,N>>>=0,b=tr(b>>>0),$=tr($),N=tr(N),b[$]=N}function Pi(b,$){return $>>>=0,b=(b=Qt(b>>>0,"_emval_take_value")).readValueFromPointer($),Er(b)}function Xl(b,$){b=-9007199254740992>b||9007199254740992<b?NaN:Number(b),$>>>=0,b=new Date(1e3*b),G()[$>>>2>>>0]=b.getUTCSeconds(),G()[$+4>>>2>>>0]=b.getUTCMinutes(),G()[$+8>>>2>>>0]=b.getUTCHours(),G()[$+12>>>2>>>0]=b.getUTCDate(),G()[$+16>>>2>>>0]=b.getUTCMonth(),G()[$+20>>>2>>>0]=b.getUTCFullYear()-1900,G()[$+24>>>2>>>0]=b.getUTCDay(),b=(b.getTime()-Date.UTC(b.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,G()[$+28>>>2>>>0]=b}var Yl=b=>b%4==0&&(b%100!=0||b%400==0),Zl=[0,31,60,91,121,152,182,213,244,274,305,335],Jl=[0,31,59,90,120,151,181,212,243,273,304,334];function Dc(b,$){b=-9007199254740992>b||9007199254740992<b?NaN:Number(b),$>>>=0,b=new Date(1e3*b),G()[$>>>2>>>0]=b.getSeconds(),G()[$+4>>>2>>>0]=b.getMinutes(),G()[$+8>>>2>>>0]=b.getHours(),G()[$+12>>>2>>>0]=b.getDate(),G()[$+16>>>2>>>0]=b.getMonth(),G()[$+20>>>2>>>0]=b.getFullYear()-1900,G()[$+24>>>2>>>0]=b.getDay();var N=(Yl(b.getFullYear())?Zl:Jl)[b.getMonth()]+b.getDate()-1|0;G()[$+28>>>2>>>0]=N,G()[$+36>>>2>>>0]=-60*b.getTimezoneOffset(),N=new Date(b.getFullYear(),6,1).getTimezoneOffset();var K=new Date(b.getFullYear(),0,1).getTimezoneOffset();b=0|(N!=K&&b.getTimezoneOffset()==Math.min(K,N)),G()[$+32>>>2>>>0]=b}function so(b){b>>>=0;var $=new Date(G()[b+20>>>2>>>0]+1900,G()[b+16>>>2>>>0],G()[b+12>>>2>>>0],G()[b+8>>>2>>>0],G()[b+4>>>2>>>0],G()[b>>>2>>>0],0),N=G()[b+32>>>2>>>0],K=$.getTimezoneOffset(),re=new Date($.getFullYear(),6,1).getTimezoneOffset(),ye=new Date($.getFullYear(),0,1).getTimezoneOffset(),He=Math.min(ye,re);return 0>N?G()[b+32>>>2>>>0]=+(re!=ye&&He==K):0<N!=(He==K)&&(re=Math.max(ye,re),$.setTime($.getTime()+6e4*((0<N?He:re)-K))),G()[b+24>>>2>>>0]=$.getDay(),N=(Yl($.getFullYear())?Zl:Jl)[$.getMonth()]+$.getDate()-1|0,G()[b+28>>>2>>>0]=N,G()[b>>>2>>>0]=$.getSeconds(),G()[b+4>>>2>>>0]=$.getMinutes(),G()[b+8>>>2>>>0]=$.getHours(),G()[b+12>>>2>>>0]=$.getDate(),G()[b+16>>>2>>>0]=$.getMonth(),G()[b+20>>>2>>>0]=$.getYear(),b=$.getTime(),BigInt(isNaN(b)?-1:b/1e3)}function eu(b,$,N,K,re,ye,He){return d?nt(16,1,b,$,N,K,re,ye,He):-52}function tu(b,$,N,K,re,ye){if(d)return nt(17,1,b,$,N,K,re,ye)}var Ga={},nu=()=>performance.timeOrigin+performance.now();function Xo(b,$){if(d)return nt(18,1,b,$);if(Ga[b]&&(clearTimeout(Ga[b].id),delete Ga[b]),!$)return 0;var N=setTimeout(()=>{delete Ga[b],se(()=>ho(b,performance.timeOrigin+performance.now()))},$);return Ga[b]={id:N,qc:$},0}function Ic(b,$,N,K){b>>>=0,$>>>=0,N>>>=0,K>>>=0;var re=new Date().getFullYear(),ye=new Date(re,0,1).getTimezoneOffset();re=new Date(re,6,1).getTimezoneOffset();var He=Math.max(ye,re);fe()[b>>>2>>>0]=60*He,G()[$>>>2>>>0]=+(ye!=re),b=($=at=>{var yt=Math.abs(at);return`UTC${0<=at?"-":"+"}${String(Math.floor(yt/60)).padStart(2,"0")}${String(yt%60).padStart(2,"0")}`})(ye),$=$(re),re<ye?(ce(b,N,17),ce($,K,17)):(ce(b,K,17),ce($,N,17))}var ru=()=>Date.now();function ff(b,$,N){return 0<=b&&3>=b?(b===0?b=Date.now():b=performance.timeOrigin+performance.now(),oe[N>>>0>>>3]=BigInt(Math.round(1e6*b)),0):28}var Yo=[],Zo=(b,$)=>{Yo.length=0;for(var N;N=B()[b++>>>0];){var K=N!=105;$+=(K&=N!=112)&&$%8?4:0,Yo.push(N==112?fe()[$>>>2>>>0]:N==106?oe[$>>>3]:N==105?G()[$>>>2>>>0]:ze()[$>>>3>>>0]),$+=K?8:4}return Yo};function su(b,$,N){return b>>>=0,$=Zo($>>>0,N>>>0),Ve[b](...$)}function Jo(b,$,N){return b>>>=0,$=Zo($>>>0,N>>>0),Ve[b](...$)}var Lc=()=>{};function el(b,$){return I(En(b>>>0,$>>>0))}var Ai=()=>{throw st+=1,"unwind"};function zc(){return 4294901760}var au=()=>navigator.hardwareConcurrency;function iu(){return De("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function ou(b){b>>>=0;var $=B().length;if(b<=$||4294901760<b)return!1;for(var N=1;4>=N;N*=2){var K=$*(1+.2/N);K=Math.min(K,b+100663296);e:{K=(Math.min(4294901760,65536*Math.ceil(Math.max(b,K)/65536))-P.buffer.byteLength+65535)/65536|0;try{P.grow(K),je();var re=1;break e}catch{}re=void 0}if(re)return!0}return!1}var ki=()=>(De("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),wa={},Ma=b=>{b.forEach($=>{ki()})};function tl(){var b=Error().stack.toString().split(`
`);return b[0]=="Error"&&b.shift(),Ma(b),wa.Lb=ki(),wa.cc=b,wa.Lb}function lu(b,$,N){if(b>>>=0,$>>>=0,wa.Lb==b)var K=wa.cc;else(K=Error().stack.toString().split(`
`))[0]=="Error"&&K.shift(),Ma(K);for(var re=3;K[re]&&ki()!=b;)++re;for(b=0;b<N&&K[b+re];++b)G()[$+4*b>>>2>>>0]=ki();return b}var nl,Oi={},ta=()=>{if(!nl){var b,$={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(b in Oi)Oi[b]===void 0?delete $[b]:$[b]=Oi[b];var N=[];for(b in $)N.push(`${b}=${$[b]}`);nl=N}return nl};function Wa(b,$){if(d)return nt(19,1,b,$);b>>>=0,$>>>=0;var N=0;return ta().forEach((K,re)=>{var ye=$+N;for(re=fe()[b+4*re>>>2>>>0]=ye,ye=0;ye<K.length;++ye)q()[re++>>>0]=K.charCodeAt(ye);q()[re>>>0]=0,N+=K.length+1}),0}function $i(b,$){if(d)return nt(20,1,b,$);b>>>=0,$>>>=0;var N=ta();fe()[b>>>2>>>0]=N.length;var K=0;return N.forEach(re=>K+=re.length+1),fe()[$>>>2>>>0]=K,0}function uu(b){return d?nt(21,1,b):52}function ao(b,$,N,K){return d?nt(22,1,b,$,N,K):52}function rl(b,$,N,K){return d?nt(23,1,b,$,N,K):70}var sl=[null,[],[]];function io(b,$,N,K){if(d)return nt(24,1,b,$,N,K);$>>>=0,N>>>=0,K>>>=0;for(var re=0,ye=0;ye<N;ye++){var He=fe()[$>>>2>>>0],at=fe()[$+4>>>2>>>0];$+=8;for(var yt=0;yt<at;yt++){var Pt=B()[He+yt>>>0],jt=sl[b];Pt===0||Pt===10?((b===1?E:I)(Zs(jt)),jt.length=0):jt.push(Pt)}re+=at}return fe()[K>>>2>>>0]=re,0}d||(function(){for(var b=a.numThreads-1;b--;)$r();Re.unshift(()=>{be++,(function($){d?$():Promise.all(Mt.map(Br)).then($)})(()=>Ne())})})();for(var oo=Array(256),Di=0;256>Di;++Di)oo[Di]=String.fromCharCode(Di);wn=oo,Un=a.BindingError=class extends Error{constructor(b){super(b),this.name="BindingError"}},a.InternalError=class extends Error{constructor(b){super(b),this.name="InternalError"}},ur.push(0,1,void 0,1,null,1,!0,1,!1,1),a.count_emval_handles=()=>ur.length/2-5-Vr.length;var $t,cu=[ct,pt,Es,Kt,Js,X,ue,pe,ke,Qe,Tt,At,mt,Zt,qt,On,eu,tu,Xo,Wa,$i,uu,ao,rl,io];(async function(){function b(K,re){return $t=K.exports,$t=(function(){var ye=$t,He={};for(let[at,yt]of Object.entries(ye))He[at]=typeof yt=="function"?(...Pt)=>{Dr.push(at);try{return yt(...Pt)}finally{ie||(Dr.pop(),Cn&&Vn===1&&Dr.length===0&&(Vn=0,st+=1,jn(na),typeof Fibers<"u"&&Fibers.rc()))}}:yt;return He})(),$t=(function(){var ye=$t,He=yt=>Pt=>yt(Pt)>>>0,at=yt=>()=>yt()>>>0;return(ye=Object.assign({},ye)).Da=He(ye.Da),ye.fb=at(ye.fb),ye.hb=He(ye.hb),ye.tb=He(ye.tb),ye.ub=at(ye.ub),ye.__cxa_get_exception_ptr=He(ye.__cxa_get_exception_ptr),ye})(),an.push($t.ib),S=re,Ne(),$t}be++;var $=xe();if(a.instantiateWasm)return new Promise(K=>{a.instantiateWasm($,(re,ye)=>{b(re,ye),K(re.exports)})});if(d)return new Promise(K=>{Ue=re=>{var ye=new WebAssembly.Instance(re,xe());K(b(ye,re))}});J??=a.locateFile?a.locateFile?a.locateFile("ort-wasm-simd-threaded.jsep.wasm",x):x+"ort-wasm-simd-threaded.jsep.wasm":new URL("/BG-REMOVAL/assets/ort-wasm-simd-threaded.jsep-B0T3yYHD.wasm",import.meta.url).href;try{var N=await(async function(K){var re=J;if(!te&&typeof WebAssembly.instantiateStreaming=="function"&&!_e(re))try{var ye=fetch(re,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(ye,K)}catch(He){I(`wasm streaming compile failed: ${He}`),I("falling back to ArrayBuffer instantiation")}return(async function(He,at){try{var yt=await(async function(Pt){if(!te)try{var jt=await m(Pt);return new Uint8Array(jt)}catch{}if(Pt==J&&te)Pt=new Uint8Array(te);else{if(!p)throw"both async and sync fetching of the wasm failed";Pt=p(Pt)}return Pt})(He);return await WebAssembly.instantiate(yt,at)}catch(Pt){I(`failed to asynchronously prepare wasm: ${Pt}`),De(Pt)}})(re,K)})($);return b(N.instance,N.module)}catch(K){return t(K),Promise.reject(K)}})();var lo=b=>(lo=$t.Da)(b),du=()=>(du=$t.Ea)();a._OrtInit=(b,$)=>(a._OrtInit=$t.Fa)(b,$),a._OrtGetLastError=(b,$)=>(a._OrtGetLastError=$t.Ga)(b,$),a._OrtCreateSessionOptions=(b,$,N,K,re,ye,He,at,yt,Pt)=>(a._OrtCreateSessionOptions=$t.Ha)(b,$,N,K,re,ye,He,at,yt,Pt),a._OrtAppendExecutionProvider=(b,$,N,K,re)=>(a._OrtAppendExecutionProvider=$t.Ia)(b,$,N,K,re),a._OrtAddFreeDimensionOverride=(b,$,N)=>(a._OrtAddFreeDimensionOverride=$t.Ja)(b,$,N),a._OrtAddSessionConfigEntry=(b,$,N)=>(a._OrtAddSessionConfigEntry=$t.Ka)(b,$,N),a._OrtReleaseSessionOptions=b=>(a._OrtReleaseSessionOptions=$t.La)(b),a._OrtCreateSession=(b,$,N)=>(a._OrtCreateSession=$t.Ma)(b,$,N),a._OrtReleaseSession=b=>(a._OrtReleaseSession=$t.Na)(b),a._OrtGetInputOutputCount=(b,$,N)=>(a._OrtGetInputOutputCount=$t.Oa)(b,$,N),a._OrtGetInputOutputMetadata=(b,$,N,K)=>(a._OrtGetInputOutputMetadata=$t.Pa)(b,$,N,K),a._OrtFree=b=>(a._OrtFree=$t.Qa)(b),a._OrtCreateTensor=(b,$,N,K,re,ye)=>(a._OrtCreateTensor=$t.Ra)(b,$,N,K,re,ye),a._OrtGetTensorData=(b,$,N,K,re)=>(a._OrtGetTensorData=$t.Sa)(b,$,N,K,re),a._OrtReleaseTensor=b=>(a._OrtReleaseTensor=$t.Ta)(b),a._OrtCreateRunOptions=(b,$,N,K)=>(a._OrtCreateRunOptions=$t.Ua)(b,$,N,K),a._OrtAddRunConfigEntry=(b,$,N)=>(a._OrtAddRunConfigEntry=$t.Va)(b,$,N),a._OrtReleaseRunOptions=b=>(a._OrtReleaseRunOptions=$t.Wa)(b),a._OrtCreateBinding=b=>(a._OrtCreateBinding=$t.Xa)(b),a._OrtBindInput=(b,$,N)=>(a._OrtBindInput=$t.Ya)(b,$,N),a._OrtBindOutput=(b,$,N,K)=>(a._OrtBindOutput=$t.Za)(b,$,N,K),a._OrtClearBoundOutputs=b=>(a._OrtClearBoundOutputs=$t._a)(b),a._OrtReleaseBinding=b=>(a._OrtReleaseBinding=$t.$a)(b),a._OrtRunWithBinding=(b,$,N,K,re)=>(a._OrtRunWithBinding=$t.ab)(b,$,N,K,re),a._OrtRun=(b,$,N,K,re,ye,He,at)=>(a._OrtRun=$t.bb)(b,$,N,K,re,ye,He,at),a._OrtEndProfiling=b=>(a._OrtEndProfiling=$t.cb)(b),a._JsepOutput=(b,$,N)=>(a._JsepOutput=$t.db)(b,$,N),a._JsepGetNodeName=b=>(a._JsepGetNodeName=$t.eb)(b);var uo=()=>(uo=$t.fb)(),ks=a._free=b=>(ks=a._free=$t.gb)(b),Ii=a._malloc=b=>(Ii=a._malloc=$t.hb)(b),Hr=(b,$,N,K,re,ye)=>(Hr=$t.kb)(b,$,N,K,re,ye),Ha=()=>(Ha=$t.lb)(),co=(b,$,N,K,re)=>(co=$t.mb)(b,$,N,K,re),al=b=>(al=$t.nb)(b),fo=b=>(fo=$t.ob)(b),ho=(b,$)=>(ho=$t.pb)(b,$),po=()=>(po=$t.qb)(),fu=(b,$)=>(fu=$t.rb)(b,$),Os=b=>(Os=$t.sb)(b),Li=b=>(Li=$t.tb)(b),xa=()=>(xa=$t.ub)(),zi=a.dynCall_ii=(b,$)=>(zi=a.dynCall_ii=$t.vb)(b,$),il=b=>(il=$t.wb)(b),na=()=>(na=$t.xb)(),ra=b=>(ra=$t.yb)(b),mo=()=>(mo=$t.zb)();return a.stackSave=()=>xa(),a.stackRestore=b=>Os(b),a.stackAlloc=b=>Li(b),a.setValue=function(b,$,N="i8"){switch(N.endsWith("*")&&(N="*"),N){case"i1":case"i8":q()[b>>>0]=$;break;case"i16":R()[b>>>1>>>0]=$;break;case"i32":G()[b>>>2>>>0]=$;break;case"i64":oe[b>>>3]=BigInt($);break;case"float":Te()[b>>>2>>>0]=$;break;case"double":ze()[b>>>3>>>0]=$;break;case"*":fe()[b>>>2>>>0]=$;break;default:De(`invalid type for setValue: ${N}`)}},a.getValue=function(b,$="i8"){switch($.endsWith("*")&&($="*"),$){case"i1":case"i8":return q()[b>>>0];case"i16":return R()[b>>>1>>>0];case"i32":return G()[b>>>2>>>0];case"i64":return oe[b>>>3];case"float":return Te()[b>>>2>>>0];case"double":return ze()[b>>>3>>>0];case"*":return fe()[b>>>2>>>0];default:De(`invalid type for getValue: ${$}`)}},a.UTF8ToString=En,a.stringToUTF8=ce,a.lengthBytesUTF8=z,(function b(){if(0<be)Ae=b;else if(d)n(a),le();else{for(;0<Re.length;)Re.shift()(a);0<be?Ae=b:(a.calledRun=!0,ie||(le(),n(a)))}})(),a.PTR_SIZE=4,i}),Dx=Vg,vb=globalThis.self?.name?.startsWith("em-pthread"),vb&&Vg()}),Gg,ry,bb,pa,Ix,Qm,wb,Mb,Wg,xb,Hg,Lx,Kg,zx,Fy=ut(()=>{zy(),Gg=typeof location>"u"?void 0:location.origin,ry=import.meta.url>"file:"&&import.meta.url<"file;",bb=()=>{{if(ry){let e=URL;return new URL(new e("ort.bundle.min.mjs",import.meta.url).href,Gg).href}return import.meta.url}},pa=bb(),Ix=()=>{if(pa&&!pa.startsWith("blob:"))return pa.substring(0,pa.lastIndexOf("/")+1)},Qm=(e,n)=>{try{let t=n??pa;return(t?new URL(e,t):new URL(e)).origin===Gg}catch{return!1}},wb=(e,n)=>{let t=n??pa;try{return(t?new URL(e,t):new URL(e)).href}catch{return}},Mb=(e,n)=>`${n??"./"}${e}`,Wg=async e=>{let n=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(n)},xb=async e=>(await import(e)).default,Hg=(LO(),Rp(kx)).default,Lx=async()=>{if(!pa)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Qm(pa))return[void 0,Hg()];let e=await Wg(pa);return[e,Hg(e)]},Kg=(zO(),Rp($x)).default,zx=async(e,n,t)=>{if(!e&&!n&&Kg&&pa&&Qm(pa))return[void 0,Kg];{let a="ort-wasm-simd-threaded.jsep.mjs",i=e??wb(a,n),l=t&&i&&!Qm(i,n),u=l?await Wg(i):i??Mb(a,n);return[l?u:void 0,await xb(u)]}}}),qg,Xm,yp,Qg,Tb,Eb,Sb,Ry,Xn,Ec=ut(()=>{Fy(),Xm=!1,yp=!1,Qg=!1,Tb=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Eb=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Sb=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},Ry=async e=>{if(Xm)return Promise.resolve();if(yp)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Qg)throw new Error("previous call to 'initializeWebAssembly()' failed.");yp=!0;let n=e.initTimeout,t=e.numThreads;if(e.simd!==!1){if(e.simd==="relaxed"){if(!Sb())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!Eb())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let a=Tb();t>1&&!a&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+t+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=t=1);let i=e.wasmPaths,l=typeof i=="string"?i:void 0,u=i?.mjs,d=u?.href??u,f=i?.wasm,h=f?.href??f,_=e.wasmBinary,[m,p]=await zx(d,l,t>1),y=!1,v=[];if(n>0&&v.push(new Promise(x=>{setTimeout(()=>{y=!0,x()},n)})),v.push(new Promise((x,L)=>{let T={numThreads:t};if(_)T.wasmBinary=_;else if(h||l)T.locateFile=E=>h??l+E;else if(d&&d.indexOf("blob:")!==0)T.locateFile=E=>new URL(E,d).href;else if(m){let E=Ix();E&&(T.locateFile=I=>E+I)}p(T).then(E=>{yp=!1,Xm=!0,qg=E,x(),m&&URL.revokeObjectURL(m)},E=>{yp=!1,Qg=!0,L(E)})})),await Promise.race(v),y)throw new Error(`WebAssembly backend initializing failed due to timeout: ${n}ms`)},Xn=()=>{if(Xm&&qg)return qg;throw new Error("WebAssembly is not initialized yet.")}}),yi,M_,Rn,By=ut(()=>{Ec(),yi=(e,n)=>{let t=Xn(),a=t.lengthBytesUTF8(e)+1,i=t._malloc(a);return t.stringToUTF8(e,i,a),n.push(i),i},M_=(e,n,t,a)=>{if(typeof e=="object"&&e!==null){if(t.has(e))throw new Error("Circular reference in options");t.add(e)}Object.entries(e).forEach(([i,l])=>{let u=n?n+i:i;if(typeof l=="object")M_(l,u+".",t,a);else if(typeof l=="string"||typeof l=="number")a(u,l.toString());else if(typeof l=="boolean")a(u,l?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof l}`)})},Rn=e=>{let n=Xn(),t=n.stackSave();try{let a=n.PTR_SIZE,i=n.stackAlloc(2*a);n._OrtGetLastError(i,i+a);let l=Number(n.getValue(i,a===4?"i32":"i64")),u=n.getValue(i+a,"*"),d=u?n.UTF8ToString(u):"";throw new Error(`${e} ERROR_CODE: ${l}, ERROR_MESSAGE: ${d}`)}finally{n.stackRestore(t)}}}),Fx,FO=ut(()=>{Ec(),By(),Fx=e=>{let n=Xn(),t=0,a=[],i=e||{};try{if(e?.logSeverityLevel===void 0)i.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)i.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(i.terminate=!1);let l=0;return e?.tag!==void 0&&(l=yi(e.tag,a)),t=n._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,l),t===0&&Rn("Can't create run options."),e?.extra!==void 0&&M_(e.extra,"",new WeakSet,(u,d)=>{let f=yi(u,a),h=yi(d,a);n._OrtAddRunConfigEntry(t,f,h)!==0&&Rn(`Can't set a run config entry: ${u} - ${d}.`)}),[t,a]}catch(l){throw t!==0&&n._OrtReleaseRunOptions(t),a.forEach(u=>n._free(u)),l}}}),Cb,Pb,Ab,vp,kb,Rx,RO=ut(()=>{Ec(),By(),Cb=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Pb=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Ab=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let n=e.extra.session;n.use_ort_model_bytes_directly||(n.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(t=>(typeof t=="string"?t:t.name)==="webgpu")&&(e.enableMemPattern=!1)},vp=(e,n,t,a)=>{let i=yi(n,a),l=yi(t,a);Xn()._OrtAddSessionConfigEntry(e,i,l)!==0&&Rn(`Can't set a session config entry: ${n} - ${t}.`)},kb=async(e,n,t)=>{for(let a of n){let i=typeof a=="string"?a:a.name,l=[];switch(i){case"webnn":if(i="WEBNN",typeof a!="string"){let _=a?.deviceType;_&&vp(e,"deviceType",_,t)}break;case"webgpu":if(i="JS",typeof a!="string"){let _=a;if(_?.preferredLayout){if(_.preferredLayout!=="NCHW"&&_.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${_.preferredLayout}`);vp(e,"preferredLayout",_.preferredLayout,t)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${i}`)}let u=yi(i,t),d=l.length,f=0,h=0;if(d>0){f=Xn()._malloc(d*Xn().PTR_SIZE),t.push(f),h=Xn()._malloc(d*Xn().PTR_SIZE),t.push(h);for(let _=0;_<d;_++)Xn().setValue(f+_*Xn().PTR_SIZE,l[_][0],"*"),Xn().setValue(h+_*Xn().PTR_SIZE,l[_][1],"*")}await Xn()._OrtAppendExecutionProvider(e,u,f,h,d)!==0&&Rn(`Can't append execution provider: ${i}.`)}},Rx=async e=>{let n=Xn(),t=0,a=[],i=e||{};Ab(i);try{let l=Cb(i.graphOptimizationLevel??"all"),u=Pb(i.executionMode??"sequential"),d=typeof i.logId=="string"?yi(i.logId,a):0,f=i.logSeverityLevel??2;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log serverity level is not valid: ${f}`);let h=i.logVerbosityLevel??0;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log verbosity level is not valid: ${h}`);let _=typeof i.optimizedModelFilePath=="string"?yi(i.optimizedModelFilePath,a):0;if(t=n._OrtCreateSessionOptions(l,!!i.enableCpuMemArena,!!i.enableMemPattern,u,!!i.enableProfiling,0,d,f,h,_),t===0&&Rn("Can't create session options."),i.executionProviders&&await kb(t,i.executionProviders,a),i.enableGraphCapture!==void 0){if(typeof i.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${i.enableGraphCapture}`);vp(t,"enableGraphCapture",i.enableGraphCapture.toString(),a)}if(i.freeDimensionOverrides)for(let[m,p]of Object.entries(i.freeDimensionOverrides)){if(typeof m!="string")throw new Error(`free dimension override name must be a string: ${m}`);if(typeof p!="number"||!Number.isInteger(p)||p<0)throw new Error(`free dimension override value must be a non-negative integer: ${p}`);let y=yi(m,a);n._OrtAddFreeDimensionOverride(t,y,p)!==0&&Rn(`Can't set a free dimension override: ${m} - ${p}.`)}return i.extra!==void 0&&M_(i.extra,"",new WeakSet,(m,p)=>{vp(t,m,p,a)}),[t,a]}catch(l){throw t!==0&&n._OrtReleaseSessionOptions(t)!==0&&Rn("Can't release session options."),a.forEach(u=>n._free(u)),l}}}),nf,Vo,vc,jy,x_,Ny,Uy,sy,Bt=ut(()=>{nf=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},Vo=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},vc=(e,n)=>{let t=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],a=typeof n=="number"?n:n.reduce((i,l)=>i*l,1);return t>0?Math.ceil(a*t):void 0},jy=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},x_=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Ny=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",Uy=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",sy=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),Vy,Bx=ut(()=>{zy(),Vy=async e=>{if(typeof e=="string"){let n=await fetch(e);if(!n.ok)throw new Error(`failed to load external data file: ${e}`);let t=n.headers.get("Content-Length"),a=t?parseInt(t,10):0;if(a<1073741824)return new Uint8Array(await n.arrayBuffer());{if(!n.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let i=n.body.getReader(),l;try{l=new ArrayBuffer(a)}catch(d){if(d instanceof RangeError){let f=Math.ceil(a/65536);l=new WebAssembly.Memory({initial:f,maximum:f}).buffer}else throw d}let u=0;for(;;){let{done:d,value:f}=await i.read();if(d)break;let h=f.byteLength;new Uint8Array(l,u,h).set(f),u+=h}return new Uint8Array(l,0,a)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),Ob,$b,Db,Ib,Gy,Lb,mn,qo=ut(()=>{Bt(),Ob=["V","I","W","E","F"],$b=(e,n)=>{console.log(`[${Ob[e]},${new Date().toISOString()}]${n}`)},Gy=(e,n)=>{Db=e,Ib=n},Lb=(e,n)=>{let t=x_(e),a=x_(Db);t>=a&&$b(t,typeof n=="function"?n():n)},mn=(...e)=>{Ib&&Lb(...e)}}),zb,of,Be,T_,jx,Nx,Ux,en=ut(()=>{zb=class{static calcMatMulShape(e,n){return e[1]!==n[0]?void 0:[e[0],n[1]]}},of=class{static calcShape(e,n,t=!1){let a=e.length,i=n.length;if(a===0)return n;if(i===0)return e;let l=Math.max(e.length,n.length),u=new Array(l);if(t){if(a<2||i<2)return;let d=zb.calcMatMulShape([e[a-2],e[a-1]],[n[i-2],n[i-1]]);if(d===void 0)return;[u[l-2],u[l-1]]=d}for(let d=t?3:1;d<=l;d++){let f=a-d<0?1:e[a-d],h=i-d<0?1:n[i-d];if(f!==h&&f>1&&h>1)return;let _=Math.max(f,h);if(f&&h)u[l-d]=Math.max(f,h);else{if(_>1)return;u[l-d]=0}}return u}static isValidBroadcast(e,n){let t=e.length,a=n.length;if(t>a)return!1;for(let i=1;i<=t;i++)if(e[t-i]!==1&&e[t-i]!==n[a-i])return!1;return!0}},Be=class m_{static size(n){return m_.getSizeFromDimensionRange(n,0,n.length)}static convertShape(n,t=4){let a=n.length;if(a===0)return[];let i=new Array(a),l=a-1;for(;l>=0;){if(n[l]%t===0){i[l]=n[l]/t;break}if(t%n[l]!==0)throw new Error("cannot convert shape");i[l]=1,t/=n[l],l--}for(l--;l>=0;l--)i[l]=n[l];return i}static sizeFromDimension(n,t){if(t<0||t>n.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${n.length} dimensions.`);return m_.getSizeFromDimensionRange(n,t,n.length)}static sizeToDimension(n,t){if(t<0||t>n.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${n.length} dimensions.`);return m_.getSizeFromDimensionRange(n,0,t)}static getSizeFromDimensionRange(n,t,a){let i=1;for(let l=t;l<a;l++){if(n[l]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");i*=Number(n[l])}return i}static computeStrides(n){let t=n.length;if(t===0)return[];if(t===1)return[1];let a=new Array(t);a[t-1]=1,a[t-2]=n[t-1];for(let i=t-3;i>=0;--i)a[i]=a[i+1]*n[i+1];return a}static normalizeAxis(n,t){if(n<-t&&n>=t)throw new Error("unsupported axis for this operation.");return n<0?n+t:n}static normalizeAxes(n,t){return n.map(a=>this.normalizeAxis(a,t??n.length))}static sortBasedOnPerm(n,t){return t?t.map(a=>n[a]):n.slice().reverse()}static padShape(n,t){let a=n.length;return n.map((i,l)=>i+t[l]+t[l+a])}static areEqual(n,t){return n.length!==t.length?!1:n.every((a,i)=>a===t[i])}},T_=class Ap{static adjustPoolAttributes(n,t,a,i,l,u){if(!n&&a.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(n)for(let d=0;d<t.length-2;d++)d>=a.length?a.push(t[d+2]):a[d]=t[d+2];for(let d=0;d<a.length;d++)if(d<i.length){if(i[d]<0)throw new Error("strides should be greater than or equal to 1")}else i.push(1);for(let d=0;d<a.length;d++)if(d<l.length){if(l[d]<0)throw new Error("dilations should be greater than or equal to 1")}else l.push(1);for(let d=0;d<a.length*2;d++)if(d<u.length){if(u[d]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let d=0;d<a.length;d++){if(a[d]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[d]>=a[d]||u[d+a.length]>=a[d])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(n,t,a,i,l,u,d){if(d){if(l.length!==2*(n.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==n.length-2)throw new Error("length of strides should be the length of data dimensions");if(i.length!==n.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let f=0;f<n.length-2;f++)Ap.adjustPadAndReturnShape(n[f+(u?1:2)],t[f],a[f],i[f],l,f,f+n.length-2,d)}}static computePoolOutputShape(n,t,a,i,l,u,d){if(t.length<=0)throw new Error("input shape must be of size greater than 0");let f=[t[0],t[1]];return Ap.computeShapeHelper(n,t,f,a,i,l,u,d),f}static computeConvOutputShape(n,t,a,i,l,u,d){if(n.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let f=[n[0],t[0]];return Ap.computeShapeHelper(!1,n,f,a,i,l,u,d),f}static computeShapeHelper(n,t,a,i,l,u,d,f){if(n)for(let h=0;h<t.length-2;h++)a.push(1);else for(let h=0;h<t.length-2;h++)a.push(Ap.adjustPadAndReturnShape(t[h+2],i[h],l[h],u[h],d,h,h+t.length-2,f))}static adjustPadAndReturnShape(n,t,a,i,l,u,d,f){let h=a*(i-1)+1;if(f&&f!=="NOTSET")switch(f){case"VALID":return l[u]=0,l[d]=0,Math.floor((n-h)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(a!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let _=((n+t-1)/t-1)*t+i-n;return l[u]=Math.floor(f==="SAME_LOWER"?(_+1)/2:_/2),l[d]=_-l[u],Math.floor((n+_-i)/t+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((n+l[u]+l[d]-h)/t+1)}},jx=class{static getShapeOfGemmResult(e,n,t,a,i){if(e.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let l,u,d;n?(l=e[1],u=e[0]):(l=e[0],u=e[1]);let f=-1;if(a?(d=t[0],f=1):(d=t[1],f=0),t[f]!==u)throw new Error("dimension mismatch");if(l<=0||d<=0||u<=0)throw new Error("invalid shape specified");if(i&&!of.isValidBroadcast(i,[l,d]))throw new Error("gemm: invalid bias shape for broadcast");return[l,d,u]}},Nx=-34028234663852886e22,Ux=34028234663852886e22}),Wy,Vx=ut(()=>{Bt(),Wy=(e,n)=>new(jy(n))(e)}),ay,Xg,Fb,Yg,Rb,Zg,Jg,e0,Bb,Gx,BO=ut(()=>{qo(),ay=(e,n=!0)=>{if(e.byteLength%8!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 8 (BigInt).");let t=e.byteLength/8,a=new BigInt64Array(e.buffer,e.byteOffset,t),i=new Int32Array(t);for(let l=0;l<t;l++){let u=a[l];if(u>2147483647n||u<-2147483648n)throw new Error(`Overflow occurred when converting BigInt to Int32 at index ${l}: ${u}`);i[l]=Number(u)}return n?new Uint8Array(i.buffer):i},Xg=(e,n=!0)=>{if(e.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (Int32).");let t=e.byteLength/4,a=new Int32Array(e.buffer,e.byteOffset,t),i=BigInt64Array.from(a,BigInt);return n?new Uint8Array(i.buffer):i},Fb=1,Yg=()=>Fb++,Rb=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),Zg=(e,n)=>{let t=Rb.get(e);if(!t)throw new Error("Unsupported data type.");return n.length>0?Math.ceil(n.reduce((a,i)=>a*i)*t/8):0},Jg=class{constructor(e){this.shouldConvertInt64toInt32=!1,this.isInt64ToInt32Converted=!1;let{sessionId:n,context:t,tensor:a,dataType:i,shape:l,shouldConvertInt64toInt32:u=!1}=e;this.sessionId=n,this.mlContext=t,this.mlTensor=a,this.dataType=i,this.tensorShape=l,this.shouldConvertInt64toInt32=u}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return Zg(this.dataType,this.tensorShape)}destroy(){mn("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e,n){if(e){let t=await this.mlContext.readTensor(this.mlTensor),a=Xg(new Uint8Array(t));if(n){(n instanceof ArrayBuffer?new Uint8Array(n):new Uint8Array(n.buffer,n.byteOffset,n.byteLength)).set(a);return}else return a.buffer}else return n?this.mlContext.readTensor(this.mlTensor,n):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(e,n,t){return this.mlContext===e&&this.dataType===n&&this.tensorShape.length===t.length&&this.tensorShape.every((a,i)=>a===t[i])}setIsInt64ToInt32Converted(e){this.isInt64ToInt32Converted=e}},e0=class{constructor(e,n){this.tensorManager=e,this.wrapper=n}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,n,t,a){let i=n,l=this.tensorManager.getMLContext(e),u=i==="int64"&&!l.opSupportLimits().input.dataTypes.includes("int64");if(u&&(i="int32",mn("verbose",()=>"[WebNN] TensorIdTracker.ensureTensor: convert dataType from int64 to int32")),this.wrapper){if(this.wrapper.canReuseTensor(l,i,t))return this.wrapper.tensor;if(a){if(this.wrapper.byteLength!==Zg(i,t))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let d=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,i,t,d,!0,!0,u),a&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){let n=e;if(this.wrapper)if(this.wrapper.shouldConvertInt64toInt32&&(n=ay(e,!0),this.wrapper.setIsInt64ToInt32Converted(!0)),n.byteLength===this.wrapper.byteLength){this.wrapper.write(n);return}else mn("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor();this.activeUpload?this.activeUpload.set(n):this.activeUpload=new Uint8Array(n)}async download(e){if(this.activeUpload){let n=this.wrapper?.isInt64ToInt32Converted?Xg(this.activeUpload):this.activeUpload;if(e){e instanceof ArrayBuffer?new Uint8Array(e).set(n):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(n);return}else return n.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(this.wrapper?.shouldConvertInt64toInt32,e):this.wrapper.read(this.wrapper?.shouldConvertInt64toInt32)}},Bb=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(e){let n=this.backend.getMLContext(e);if(!n)throw new Error("MLContext not found for session.");return n}reserveTensorId(){let e=Yg();return this.tensorTrackersById.set(e,new e0(this)),e}releaseTensorId(e){let n=this.tensorTrackersById.get(e);n&&(this.tensorTrackersById.delete(e),n.tensorWrapper&&this.releaseTensor(n.tensorWrapper))}async ensureTensor(e,n,t,a,i){mn("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${n}, dataType: ${t}, shape: ${a}, copyOld: ${i}}`);let l=this.tensorTrackersById.get(n);if(!l)throw new Error("Tensor not found.");return l.ensureTensor(e,t,a,i)}upload(e,n){let t=this.tensorTrackersById.get(e);if(!t)throw new Error("Tensor not found.");t.upload(n)}async download(e,n){mn("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${n?.byteLength}}`);let t=this.tensorTrackersById.get(e);if(!t)throw new Error("Tensor not found.");return t.download(n)}releaseTensorsForSession(e){for(let n of this.freeTensors)n.sessionId===e&&n.destroy();this.freeTensors=this.freeTensors.filter(n=>n.sessionId!==e)}registerTensor(e,n,t,a){let i=this.getMLContext(e),l=Yg(),u=new Jg({sessionId:e,context:i,tensor:n,dataType:t,shape:a});return this.tensorTrackersById.set(l,new e0(this,u)),this.externalTensors.add(u),l}async getCachedTensor(e,n,t,a,i,l,u=!1){let d=this.getMLContext(e);for(let[h,_]of this.freeTensors.entries())if(_.canReuseTensor(d,n,t)){mn("verbose",()=>`[WebNN] Reusing tensor {dataType: ${n}, shape: ${t}}`);let m=this.freeTensors.splice(h,1)[0];return m.sessionId=e,m}mn("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${n}, shape: ${t}}`);let f=await d.createTensor({dataType:n,shape:t,dimensions:t,usage:a,writable:i,readable:l});return new Jg({sessionId:e,context:d,tensor:f,dataType:n,shape:t,shouldConvertInt64toInt32:u})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},Gx=(...e)=>new Bb(...e)}),Ym,jb,Wx,jO=ut(()=>{Bt(),Ec(),Vx(),BO(),qo(),Ym=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),jb=(e,n)=>{if(e===n)return!0;if(e===void 0||n===void 0)return!1;let t=Object.keys(e).sort(),a=Object.keys(n).sort();return t.length===a.length&&t.every((i,l)=>i===a[l]&&e[i]===n[i])},Wx=class{constructor(e){this.tensorManager=Gx(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,Gy(e.logLevel,!!e.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(e){mn("verbose",()=>`[WebNN] onRunStart {sessionId: ${e}}`),this.activeSessionId=e}onRunEnd(e){mn("verbose",()=>`[WebNN] onRunEnd {sessionId: ${e}}`);let n=this.temporarySessionTensorIds.get(e);if(n){for(let t of n)mn("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let t=this.mlContextCache.findIndex(a=>a.gpuDevice===e);if(t!==-1)return this.mlContextCache[t].mlContext;{let a=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:a}),a}}else if(e===void 0){let t=this.mlContextCache.findIndex(a=>a.options===void 0&&a.gpuDevice===void 0);if(t!==-1)return this.mlContextCache[t].mlContext;{let a=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:a}),a}}let n=this.mlContextCache.findIndex(t=>jb(t.options,e));if(n!==-1)return this.mlContextCache[n].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:t}),t}}registerMLContext(e,n){this.mlContextBySessionId.set(e,n);let t=this.sessionIdsByMLContext.get(n);t||(t=new Set,this.sessionIdsByMLContext.set(n,t)),t.add(e),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e);let n=this.mlContextBySessionId.get(e);if(!n)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let t=this.sessionIdsByMLContext.get(n);if(t.delete(e),t.size===0){this.sessionIdsByMLContext.delete(n);let a=this.mlContextCache.findIndex(i=>i.mlContext===n);a!==-1&&this.mlContextCache.splice(a,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){mn("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,n,t,a,i){let l=Ym.get(t);if(!l)throw new Error(`Unsupported ONNX data type: ${t}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,n,l,a,i)}async createTemporaryTensor(e,n,t){mn("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${n}, shape: ${t}}`);let a=Ym.get(n);if(!a)throw new Error(`Unsupported ONNX data type: ${n}`);let i=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,i,a,t,!1);let l=this.temporarySessionTensorIds.get(e);return l?l.push(i):this.temporarySessionTensorIds.set(e,[i]),i}uploadTensor(e,n){if(!Xn().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");mn("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${n.byteLength}}`),this.tensorManager.upload(e,n)}async downloadTensor(e,n){return this.tensorManager.download(e,n)}createMLTensorDownloader(e,n){return async()=>{let t=await this.tensorManager.download(e);return Wy(t,n)}}registerMLTensor(e,n,t,a){let i=Ym.get(t);if(!i)throw new Error(`Unsupported ONNX data type: ${t}`);let l=this.tensorManager.registerTensor(e,n,i,a);return mn("verbose",()=>`[WebNN] registerMLTensor {tensor: ${n}, dataType: ${i}, dimensions: ${a}} -> {tensorId: ${l}}`),l}registerMLConstant(e,n,t,a,i,l,u=!1){if(!l)throw new Error("External mounted files are not available.");let d=e;e.startsWith("./")&&(d=e.substring(2));let f=l.get(d);if(!f)throw new Error(`File with name ${d} not found in preloaded files.`);if(n+t>f.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let h=f.slice(n,n+t).buffer,_;switch(i.dataType){case"float32":_=new Float32Array(h);break;case"float16":_=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(h):new Uint16Array(h);break;case"int32":_=new Int32Array(h);break;case"uint32":_=new Uint32Array(h);break;case"int64":u?(_=ay(new Uint8Array(h),!1),i.dataType="int32"):_=new BigInt64Array(h);break;case"uint64":_=new BigUint64Array(h);break;case"int8":_=new Int8Array(h);break;case"int4":case"uint4":case"uint8":_=new Uint8Array(h);break;default:throw new Error(`Unsupported data type: ${i.dataType} in creating WebNN Constant from external data.`)}return mn("verbose",()=>`[WebNN] registerMLConstant {dataType: ${i.dataType}, shape: ${i.shape}}} ${u?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),a.constant(i,_)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}isGraphInput(e,n){let t=this.sessionGraphInputs.get(e);return t?t.includes(n):!1}isInt64Supported(e){return!!this.mlContextBySessionId.get(e)?.opSupportLimits().input.dataTypes.includes("int64")}flush(){}}}),Hy=ut(()=>{}),t0,Zm,Jm,Nb,Ub,n0,iy,Vb,Hx,NO=ut(()=>{qo(),Hy(),t0=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Zm=[],Jm=e=>Math.ceil(Number(e)/16)*16,Nb=e=>{for(let n=0;n<Zm.length;n++){let t=Zm[n];if(e<=t)return t}return Math.ceil(e/16)*16},Ub=1,n0=()=>Ub++,iy=async(e,n,t,a)=>{let i=Jm(t),l=e.device.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(n,0,l,0,i),e.flush(),await l.mapAsync(GPUMapMode.READ);let d=l.getMappedRange();if(a){let f=a();return f.set(new Uint8Array(d,0,t)),f}else return new Uint8Array(d.slice(0,t))}finally{l.destroy()}},Vb=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[n]of t0)Zm.push(n),this.freeBuffers.set(n,[]),this.freeUniformBuffers.set(n,[]);this.sessionCount=0}upload(e,n){let t=n.buffer,a=n.byteOffset,i=n.byteLength,l=Jm(i),u=this.storageCache.get(e);if(!u)throw new Error("gpu data for uploading does not exist");if(Number(u.originalSize)!==i)throw new Error(`inconsistent data size. gpu data size=${u.originalSize}, data size=${i}`);let d=this.backend.device.createBuffer({mappedAtCreation:!0,size:l,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),f=d.getMappedRange();new Uint8Array(f).set(new Uint8Array(t,a,i)),d.unmap();let h=this.backend.device.createCommandEncoder();h.copyBufferToBuffer(d,0,u.gpuData.buffer,0,l),this.backend.device.queue.submit([h.finish()]),d.destroy(),mn("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`)}memcpy(e,n){let t=this.storageCache.get(e);if(!t)throw new Error("source gpu data for memcpy does not exist");let a=this.storageCache.get(n);if(!a)throw new Error("destination gpu data for memcpy does not exist");if(t.originalSize!==a.originalSize)throw new Error("inconsistent source and destination gpu data size");let i=Jm(t.originalSize),l=this.backend.getCommandEncoder();this.backend.endComputePass(),l.copyBufferToBuffer(t.gpuData.buffer,0,a.gpuData.buffer,0,i)}registerExternalBuffer(e,n,t){let a;if(t){if(a=t[0],e===t[1])return mn("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${n}) => id=${a}, buffer is the same, skip.`),a;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else a=n0();return this.storageCache.set(a,{gpuData:{id:a,type:0,buffer:e},originalSize:n}),mn("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${n}) => id=${a}, registered.`),a}unregisterExternalBuffer(e){e!==void 0&&(this.storageCache.delete(e),mn("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(e,n=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let t=Nb(e),a,i=(n&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,l=(n&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(i||l){let d=(i?this.freeBuffers:this.freeUniformBuffers).get(t);d?d.length>0?a=d.pop():a=this.backend.device.createBuffer({size:t,usage:n}):a=this.backend.device.createBuffer({size:t,usage:n})}else a=this.backend.device.createBuffer({size:t,usage:n});let u={id:n0(),type:0,buffer:a};return this.storageCache.set(u.id,{gpuData:u,originalSize:Number(e)}),mn("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${u.id}`),u}get(e){return this.storageCache.get(e)?.gpuData}release(e){let n=typeof e=="bigint"?Number(e):e,t=this.storageCache.get(n);if(!t){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return mn("verbose",()=>`[WebGPU] GpuDataManager.release(id=${n}), gpuDataId=${t.gpuData.id}`),this.storageCache.delete(n),this.buffersPending.push(t.gpuData.buffer),t.originalSize}async download(e,n){let t=this.storageCache.get(Number(e));if(!t)throw new Error("data does not exist");await iy(this.backend,t.gpuData.buffer,t.originalSize,n)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let e of this.buffersPending){let n=t0.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let t=this.freeBuffers.get(e.size)||[];n===void 0||t.length>=n?e.destroy():t.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let t=this.freeUniformBuffers.get(e.size)||[];n===void 0||t.length>=n?e.destroy():t.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let n of this.buffersPending)e.push(n);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(e=>{e.forEach(n=>{n.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(n=>{n.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(e=>{e.forEach(n=>{n.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let n=this.capturedPendingBuffers.get(e);n&&(n.forEach(t=>{t.destroy()}),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,this.sessionCount===0&&(mn("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Hx=(...e)=>new Vb(...e)}),Gb,kn,kr=ut(()=>{Gb=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},kn=e=>new Gb(e)}),lf,e_,ns,xs,It,Tr,oy,sf,Kl,Ot,bp,qe,kt,Kx,Ky,Wb,qx,rn=ut(()=>{Bt(),en(),lf=64,e_=(e,n)=>{if(n===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return n>1?`vec${n}<f16>`:"f16";case 1:return n>1?`vec${n}<f32>`:"f32";case 6:return n>1?`vec${n}<i32>`:"i32";case 12:return n>1?`vec${n}<u32>`:"u32";case 7:if(n>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(n>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(n!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},ns=(e,n=1)=>{let t=e_(e,n);return typeof t=="string"?t:t[0]},xs=(e,n=1)=>{let t=e_(e,n);return typeof t=="string"?t:t[1]},It=(...e)=>{let n=[];return e.forEach(t=>{t.length!==0&&n.push({type:12,data:t},{type:12,data:Be.computeStrides(t)})}),n},Tr=e=>e%4===0?4:e%2===0?2:1,oy=(e="f32",n,t="0")=>!n||n===1?`${e}(${t})`:`vec${n}<${e}>(${t})`,sf=(e,n,t)=>e==="f32"?t:n===1?`f32(${t})`:`vec${n}<f32>(${t})`,Kl=(e,n)=>n===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:n===2?`(${e}.x + ${e}.y)`:n===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Ot=(e,n,t,a)=>e.startsWith("uniforms.")&&t>4?typeof n=="string"?a==="f16"?`${e}[(${n}) / 8][(${n}) % 8 / 4][(${n}) % 8 % 4]`:`${e}[(${n}) / 4][(${n}) % 4]`:a==="f16"?`${e}[${Math.floor(n/8)}][${Math.floor(n%8/4)}][${n%8%4}]`:`${e}[${Math.floor(n/4)}][${n%4}]`:t>1?`${e}[${n}]`:e,bp=(e,n,t,a,i)=>{let l=typeof t=="number",u=l?t:t.length,d=[...new Array(u).keys()],f=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,h=e_(n,i),_=typeof h=="string"?h:h[1],m=typeof h=="string"?h:h[0],p={indices:f,value:_,storage:m,tensor:n},y=B=>typeof B=="string"?B:`${B}u`,v={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},x=l?"uniforms.":"",L=`${x}${e}_shape`,T=`${x}${e}_strides`,E="";for(let B=0;B<u-1;B++)E+=`
    let dim${B} = current / ${Ot(T,B,u)};
    let rest${B} = current % ${Ot(T,B,u)};
    indices[${B}] = dim${B};
    current = rest${B};
    `;E+=`indices[${u-1}] = current;`;let I=u<2?"":`
  fn o2i_${e}(offset: u32) -> ${p.indices} {
    var indices: ${p.indices};
    var current = offset;
    ${E}
    return indices;
  }`,P=B=>(v.offsetToIndices=!0,u<2?B:`o2i_${e}(${B})`),S=[];if(u>=2)for(let B=u-1;B>=0;B--)S.push(`${Ot(T,B,u)} * (indices[${B}])`);let k=u<2?"":`
  fn i2o_${e}(indices: ${p.indices}) -> u32 {
    return ${S.join("+")};
  }`,C=B=>(v.indicesToOffset=!0,u<2?B:`i2o_${e}(${B})`),D=(...B)=>u===0?"0u":`${p.indices}(${B.map(y).join(",")})`,V=(B,R)=>u<2?`${B}`:`${Ot(B,R,u)}`,U=(B,R,Q)=>u<2?`${B}=${Q};`:`${Ot(B,R,u)}=${Q};`,ne={},ee=(B,R)=>{v.broadcastedIndicesToOffset=!0;let Q=`${R.name}broadcastedIndicesTo${e}Offset`;if(Q in ne)return`${Q}(${B})`;let G=[];for(let fe=u-1;fe>=0;fe--){let Te=R.indicesGet("outputIndices",fe+R.rank-u);G.push(`${V(T,fe)} * (${Te} % ${V(L,fe)})`)}return ne[Q]=`fn ${Q}(outputIndices: ${R.type.indices}) -> u32 {
             return ${G.length>0?G.join("+"):"0u"};
           }`,`${Q}(${B})`},H=(B,R)=>(()=>{if(p.storage===p.value)return`${e}[${B}]=${R};`;if(p.storage==="vec2<u32>"&&p.value==="i32")return`${e}[${B}]=vec2<u32>(u32(${R}), select(0u, 0xFFFFFFFFu, ${R} < 0));`;if(p.storage==="vec2<u32>"&&p.value==="u32")return`${e}[${B}]=vec2<u32>(u32(${R}), 0u);`;if(p.storage==="u32"&&p.value==="vec4<bool>")return`${e}[${B}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${R}));`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),oe=B=>(()=>{if(p.storage===p.value)return`${e}[${B}]`;if(p.storage==="vec2<u32>"&&p.value==="i32")return`i32(${e}[${B}].x)`;if(p.storage==="vec2<u32>"&&p.value==="u32")return`u32(${e}[${B}].x)`;if(p.storage==="u32"&&p.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${B}] & 0xFFu), bool(${e}[${B}] & 0xFF00u), bool(${e}[${B}] & 0xFF0000u), bool(${e}[${B}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),ae=u<2?"":`
  fn get_${e}ByIndices(indices: ${p.indices}) -> ${_} {
    return ${oe(`i2o_${e}(indices)`)};
  }`,W=u<2?"":(()=>{let B=d.map(Q=>`d${Q}: u32`).join(", "),R=d.map(Q=>`d${Q}`).join(", ");return`
  fn get_${e}(${B}) -> ${_} {
    return get_${e}ByIndices(${D(R)});
  }`})(),te=(...B)=>{if(B.length!==u)throw new Error(`indices length must be ${u}`);let R=B.map(y).join(",");return u===0?oe("0u"):u===1?oe(R[0]):(v.get=!0,v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}(${R})`)},ie=B=>u<2?oe(B):(v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}ByIndices(${B})`),_e=u<2?"":`
  fn set_${e}ByIndices(indices: ${p.indices}, value: ${_}) {
    ${H(`i2o_${e}(indices)`,"value")}
  }`,q=u<2?"":(()=>{let B=d.map(Q=>`d${Q}: u32`).join(", "),R=d.map(Q=>`d${Q}`).join(", ");return`
  fn set_${e}(${B}, value: ${_}) {
    set_${e}ByIndices(${D(R)}, value);
  }`})();return{impl:()=>{let B=[],R=!1;return v.offsetToIndices&&(B.push(I),R=!0),v.indicesToOffset&&(B.push(k),R=!0),v.broadcastedIndicesToOffset&&(Object.values(ne).forEach(Q=>B.push(Q)),R=!0),v.set&&(B.push(q),R=!0),v.setByIndices&&(B.push(_e),R=!0),v.get&&(B.push(W),R=!0),v.getByIndices&&(B.push(ae),R=!0),!l&&R&&B.unshift(`const ${L} = ${p.indices}(${t.join(",")});`,`const ${T} = ${p.indices}(${Be.computeStrides(t).join(",")});`),B.join(`
`)},type:p,offsetToIndices:P,indicesToOffset:C,broadcastedIndicesToOffset:ee,indices:D,indicesGet:V,indicesSet:U,set:(...B)=>{if(B.length!==u+1)throw new Error(`indices length must be ${u}`);let R=B[u];if(typeof R!="string")throw new Error("value must be string");let Q=B.slice(0,u).map(y).join(",");return u===0?H("0u",R):u===1?H(Q[0],R):(v.set=!0,v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}(${Q}, ${R})`)},setByOffset:H,setByIndices:(B,R)=>u<2?H(B,R):(v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}ByIndices(${B}, ${R});`),get:te,getByOffset:oe,getByIndices:ie,usage:a,name:e,strides:T,shape:L,rank:u}},qe=(e,n,t,a=1)=>bp(e,n,t,"input",a),kt=(e,n,t,a=1)=>bp(e,n,t,"output",a),Kx=(e,n,t)=>bp(e,n,t,"atomicOutput",1),Ky=(e,n,t,a=1)=>bp(e,n,t,"internal",a),Wb=class{constructor(e,n){this.normalizedDispatchGroup=e,this.limits=n,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${typeof e=="number"?`${e}u`:e}) { return; }`}mainStart(e=lf){let n=typeof e=="number"?e:e[0],t=typeof e=="number"?1:e[1],a=typeof e=="number"?1:e[2];if(n>this.limits.maxComputeWorkgroupSizeX||t>this.limits.maxComputeWorkgroupSizeY||a>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${n}, ${t}, ${a}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(n*t*a>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${n}, ${t}, ${a}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let i=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,l=i?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,u=i?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${n*t*a}u + local_idx;`;return`@compute @workgroup_size(${n}, ${t}, ${a})
  fn main(${l}) {
    ${u}
  `}appendVariableUniforms(e){e.rank!==0&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,n){if(e.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let t=e.usage==="input"?"read":"read_write",a=e.usage==="atomicOutput"?"atomic<i32>":e.type.storage;return`@group(0) @binding(${n}) var<storage, ${t}> ${e.name}: array<${a}>;`}declareVariables(...e){return e.map(n=>this.declareVariable(n,this.variableIndex++)).join(`
`)}registerInternalVariable(e){if(e.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach(n=>this.registerInternalVariable(n)),this}registerUniform(e,n,t=1){return this.uniforms.push({name:e,type:n,length:t}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let e=[];for(let{name:n,type:t,length:a}of this.uniforms)if(a&&a>4)t==="f16"?e.push(`@align(16) ${n}:array<mat2x4<${t}>, ${Math.ceil(a/8)}>`):e.push(`${n}:array<vec4<${t}>, ${Math.ceil(a/4)}>`);else{let i=a==null||a===1?t:`vec${a}<${t}>`;e.push(`${n}:${i}`)}return`
      struct Uniforms { ${e.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(e=>e.impl()).join(`
`)+this.internalVariables.map(e=>e.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let e=n=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(n)];return this.uniforms.map(n=>[e(n.type),n.length??1])}},qx=(e,n)=>new Wb(e,n)}),Hb,r0,Kb,qb,Qb,Xb,_a,Qx,Xx,ql=ut(()=>{Bt(),en(),kr(),rn(),Hb=(e,n)=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(n.length!==0&&n.length!==e[0].dims.length)throw new Error(`perm size ${n.length} does not match input rank ${e[0].dims.length}`)},r0=(e,n)=>n.length!==0?n:[...new Array(e).keys()].reverse(),Kb=(e,n)=>Be.sortBasedOnPerm(e,r0(e.length,n)),qb=(e,n,t,a)=>{let i=`fn perm(i: ${a.type.indices}) -> ${t.type.indices} {
    var a: ${t.type.indices};`;for(let l=0;l<n;++l)i+=`a[${e[l]}]=i[${l}];`;return i+="return a;}"},Qb=(e,n)=>{let t=[],a=[];for(let i=0;i<e.length;++i)e[i]!==1&&t.push(e[i]),e[n[i]]!==1&&a.push(n[i]);return{newShape:t,newPerm:a}},Xb=(e,n)=>{let t=0;for(let a=0;a<e.length;++a)if(n[e[a]]!==1){if(e[a]<t)return!1;t=e[a]}return!0},_a=(e,n)=>{let t=e.dataType,a=e.dims.length,i=r0(a,n),l=Kb(e.dims,i),u=e.dims,d=l,f=a<2||Xb(i,e.dims),h;if(f)return h=v=>{let x=qe("input",t,u,4),L=kt("output",t,d,4);return`
  ${v.registerUniform("output_size","u32").declareVariables(x,L)}
  ${v.mainStart()}
    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let v=Be.size(l);return{outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(v/64/4)},programUniforms:[{type:12,data:Math.ceil(v/4)}]}},getShaderSource:h};let{newShape:_,newPerm:m}=Qb(e.dims,i),p=Be.areEqual(m,[2,3,1]),y=Be.areEqual(m,[3,1,2]);if(_.length===2||p||y){u=p?[_[0],_[1]*_[2]]:y?[_[0]*_[1],_[2]]:_,d=[u[1],u[0]];let v=16;return h=x=>{let L=qe("a",t,u.length),T=kt("output",t,d.length);return`
  ${x.registerUniform("output_size","u32").declareVariables(L,T)}
  var<workgroup> tile : array<array<${T.type.value}, ${v+1}>, ${v}>;
  ${x.mainStart([v,v,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${v} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${v}u + local_id.x;
    let input_row = workgroup_id_x * ${v}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${L.getByIndices(`${L.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${v}u + local_id.x;
    let output_row = workgroup_id_y * ${v}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${T.setByIndices(`${T.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let x=Be.size(l);return{outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(d[1]/v),y:Math.ceil(d[0]/v)},programUniforms:[{type:12,data:x},...It(u,d)]}},getShaderSource:h}}return h=v=>{let x=qe("a",t,u.length),L=kt("output",t,d.length);return`
  ${v.registerUniform("output_size","u32").declareVariables(x,L)}

  ${qb(i,a,x,L)}

  ${v.mainStart()}
    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${L.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${L.setByOffset("global_idx",x.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${n}`,inputDependencies:["rank"]},getRunData:()=>{let v=Be.size(l);return{outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:[{type:12,data:v},...It(u,d)]}},getShaderSource:h}},Qx=(e,n)=>{Hb(e.inputs,n.perm),e.compute(_a(e.inputs[0],n.perm))},Xx=e=>kn({perm:e.perm})}),Yb,Zb,Jb,ew,tw,nw,rw,sw,aw,iw,hi,Yx,Zx,Jx,eT,tT,nT,rT,sT,aT,iT,UO=ut(()=>{Bt(),en(),rn(),qy(),ql(),Yb={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Zb={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Jb={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},ew={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},tw=(e,n)=>{let t=[];for(let a=n-e;a<n;++a)t.push(a);return t},nw=(e,n)=>{let t=[],a=e.length;for(let l=0;l<a;l++)n.indexOf(l)===-1&&t.push(e[l]);let i=n.map(l=>e[l]);return[t,i]},rw=(e,n)=>{let t=e.length+n.length,a=[],i=0;for(let l=0;l<t;l++)n.indexOf(l)===-1?a.push(e[i++]):a.push(1);return a},sw=(e,n)=>{for(let t=0;t<e.length;++t)if(e[e.length-t-1]!==n-1-t)return!1;return!0},aw=(e,n)=>{let t=[];if(!sw(e,n)){for(let a=0;a<n;++a)e.indexOf(a)===-1&&t.push(a);e.forEach(a=>t.push(a))}return t},iw=(e,n,t,a,i,l,u)=>{let d=t[0].dims,f=Be.size(l),h=Be.size(u),_=qe("_A",t[0].dataType,d),m=kt("output",i,l),p=64;f===1&&(p=256);let y=`
          var<workgroup> aBestValues : array<f32, ${p}>;
       `,v=x=>`
        ${x.registerUniform("reduceSize","u32").declareVariables(_,m)}
        ${y}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${x.mainStart(p)}

          let outputIndex = global_idx / ${p};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${Jb[a]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${p}) {
           let candidate = f32(${_.getByOffset("offset + k")});
           bestValue = ${Yb[a]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${p}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Zb[a]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${m.setByOffset("outputIndex",`${a==="mean"?`${m.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${m.type.storage}(${ew[a]})`}`)};
         }
        }`;return{name:e,shaderCache:{hint:`${n};${p}`,inputDependencies:["type"]},getShaderSource:v,getRunData:()=>({outputs:[{dims:l,dataType:i}],dispatchGroup:{x:f},programUniforms:[{type:12,data:h}]})}},hi=(e,n,t,a)=>{let i=e.inputs.length===1?t:ly(e.inputs,t),l=i.axes;l.length===0&&!i.noopWithEmptyAxes&&(l=e.inputs[0].dims.map((y,v)=>v));let u=Be.normalizeAxes(l,e.inputs[0].dims.length),d=u,f=e.inputs[0],h=aw(d,e.inputs[0].dims.length);h.length>0&&(f=e.compute(_a(e.inputs[0],h),{inputs:[0],outputs:[-1]})[0],d=tw(d.length,f.dims.length));let[_,m]=nw(f.dims,d),p=_;i.keepDims&&(p=rw(_,u)),e.compute(iw(n,i.cacheKey,[f],a,e.inputs[0].dataType,p,m),{inputs:[f]})},Yx=(e,n)=>{hi(e,"ReduceMeanShared",n,"mean")},Zx=(e,n)=>{hi(e,"ReduceL1Shared",n,"l1")},Jx=(e,n)=>{hi(e,"ReduceL2Shared",n,"l2")},eT=(e,n)=>{hi(e,"ReduceLogSumExpShared",n,"logSumExp")},tT=(e,n)=>{hi(e,"ReduceMaxShared",n,"max")},nT=(e,n)=>{hi(e,"ReduceMinShared",n,"min")},rT=(e,n)=>{hi(e,"ReduceProdShared",n,"prod")},sT=(e,n)=>{hi(e,"ReduceSumShared",n,"sum")},aT=(e,n)=>{hi(e,"ReduceSumSquareShared",n,"sumSquare")},iT=(e,n)=>{hi(e,"ReduceLogSumShared",n,"logSum")}}),pi,ow,E_,ly,mi,lw,uw,cw,dw,fw,hw,pw,mw,_w,gw,_i,oT,lT,uT,cT,dT,fT,hT,pT,mT,_T,qy=ut(()=>{Bt(),en(),kr(),rn(),UO(),pi=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},ow=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],E_=(e,n,t,a,i,l,u=!1,d=!1)=>{let f=[],h=t[0].dims,_=h.length,m=Be.normalizeAxes(i,_),p=!d&&m.length===0;h.forEach((x,L)=>{p||m.indexOf(L)>=0?u&&f.push(1):f.push(x)});let y=f.length,v=Be.size(f);return{name:e,shaderCache:n,getShaderSource:x=>{let L=[],T=qe("_A",t[0].dataType,_),E=kt("output",l,y),I=a(T,E,m),P=I[2];for(let S=0,k=0;S<_;S++)p||m.indexOf(S)>=0?(u&&k++,P=`for(var j${S}: u32 = 0; j${S} < ${h[S]}; j${S}++) {
                  ${I[2].includes("last_index")?`let last_index = j${S};`:""}
                  ${T.indicesSet("input_indices",S,`j${S}`)}
                  ${P}
                }`):(L.push(`${T.indicesSet("input_indices",S,E.indicesGet("output_indices",k))};`),k++);return`

        ${x.registerUniform("output_size","u32").declareVariables(T,E)}

        ${x.mainStart()}
          ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${T.type.indices};
          let output_indices = ${E.offsetToIndices("global_idx")};

          ${L.join(`
`)}
          ${I[0]}       // init ops for reduce max/min
          ${I[1]}
          ${P}
          ${I[3]}
          ${I.length===4?E.setByOffset("global_idx","value"):I.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:f,dataType:l}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:[{type:12,data:v},...It(h,f)]})}},ly=(e,n)=>{let t=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(a=>t.push(Number(a))),kn({axes:t,keepDims:n.keepDims,noopWithEmptyAxes:n.noopWithEmptyAxes})},mi=(e,n,t,a)=>{let i=e.inputs,l=i.length===1?t:ly(i,t);e.compute(E_(n,{hint:l.cacheKey,inputDependencies:["rank"]},[i[0]],l.noopWithEmptyAxes&&l.axes.length===0?ow:a,l.axes,i[0].dataType,l.keepDims,l.noopWithEmptyAxes),{inputs:[0]})},lw=(e,n)=>{pi(e.inputs),mi(e,"ReduceLogSum",n,(t,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${t.getByIndices("input_indices")};`,"value = log(value);"])},uw=(e,n)=>{pi(e.inputs),mi(e,"ReduceL1",n,(t,a)=>[`var value = ${a.type.storage}(0);`,"",`value += abs(${t.getByIndices("input_indices")});`,""])},cw=(e,n)=>{pi(e.inputs),mi(e,"ReduceL2",n,(t,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${t.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},dw=(e,n)=>{pi(e.inputs),mi(e,"ReduceLogSumExp",n,(t,a)=>[`var value = ${a.type.storage}(0);`,"",`value += exp(${t.getByIndices("input_indices")});`,"value = log(value);"])},fw=(e,n)=>{pi(e.inputs),mi(e,"ReduceMax",n,(t,a,i)=>{let l=[];for(let u=0;u<t.rank;u++)(i.indexOf(u)>=0||i.length===0)&&l.push(t.indicesSet("input_indices",u,0));return[`${l.join(`
`)}`,`var value = ${t.getByIndices("input_indices")};`,`value = max(value, ${t.getByIndices("input_indices")});`,""]})},hw=(e,n)=>{pi(e.inputs),mi(e,"ReduceMean",n,(t,a,i)=>{let l=1;for(let u=0;u<t.rank;u++)(i.indexOf(u)>=0||i.length===0)&&(l*=e.inputs[0].dims[u]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${a.type.value}(sum / ${l});`]})},pw=(e,n)=>{pi(e.inputs),mi(e,"ReduceMin",n,(t,a,i)=>{let l=[];for(let u=0;u<t.rank;u++)(i.indexOf(u)>=0||i.length===0)&&l.push(`input_indices[${u}] = 0;`);return[`${l.join(`
`)}`,`var value = ${t.getByIndices("input_indices")};`,`value = min(value, ${t.getByIndices("input_indices")});`,""]})},mw=(e,n)=>{pi(e.inputs),mi(e,"ReduceProd",n,(t,a)=>[`var value = ${a.type.storage}(1);`,"",`value *= ${t.getByIndices("input_indices")};`,""])},_w=(e,n)=>{pi(e.inputs),mi(e,"ReduceSum",n,(t,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${t.getByIndices("input_indices")};`,""])},gw=(e,n)=>{pi(e.inputs),mi(e,"ReduceSumSquare",n,(t,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${t.getByIndices("input_indices")}; value += t * t;`,""])},_i=(e,n,t)=>{if(n.length===0)return t;let a=1,i=1;for(let l=0;l<n.length;l++)n.indexOf(l)===-1?a*=e[l]:i*=e[l];return i<32&&a>1024},oT=(e,n)=>{_i(e.inputs[0].dims,n.axes,n.noopWithEmptyAxes)?hw(e,n):Yx(e,n)},lT=(e,n)=>{_i(e.inputs[0].dims,n.axes,n.noopWithEmptyAxes)?uw(e,n):Zx(e,n)},uT=(e,n)=>{_i(e.inputs[0].dims,n.axes,n.noopWithEmptyAxes)?cw(e,n):Jx(e,n)},cT=(e,n)=>{_i(e.inputs[0].dims,n.axes,n.noopWithEmptyAxes)?dw(e,n):eT(e,n)},dT=(e,n)=>{_i(e.inputs[0].dims,n.axes,n.noopWithEmptyAxes)?fw(e,n):tT(e,n)},fT=(e,n)=>{_i(e.inputs[0].dims,n.axes,n.noopWithEmptyAxes)?pw(e,n):nT(e,n)},hT=(e,n)=>{_i(e.inputs[0].dims,n.axes,n.noopWithEmptyAxes)?mw(e,n):rT(e,n)},pT=(e,n)=>{_i(e.inputs[0].dims,n.axes,n.noopWithEmptyAxes)?_w(e,n):sT(e,n)},mT=(e,n)=>{_i(e.inputs[0].dims,n.axes,n.noopWithEmptyAxes)?gw(e,n):aT(e,n)},_T=(e,n)=>{_i(e.inputs[0].dims,n.axes,n.noopWithEmptyAxes)?lw(e,n):iT(e,n)}}),s0,gT,yT,uy,VO=ut(()=>{Bt(),kr(),qy(),s0=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},gT=(e,n)=>{s0(e.inputs);let t=(a,i,l)=>{let u=[];for(let d=0;d<a.rank;d++)(l.indexOf(d)>=0||l.length===0)&&u.push(`input_indices[${d}] = 0;`);return[`${u.join(`
`)}`,`var value = ${a.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${a.getByIndices("input_indices")} ${n.selectLastIndex>0?"<=":"<"} value) {
         value = ${a.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(E_("ArgMin",{hint:n.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],t,[n.axis],7,n.keepDims),{inputs:[0]})},yT=(e,n)=>{s0(e.inputs);let t=(a,i,l)=>{let u=[];for(let d=0;d<a.rank;d++)(l.indexOf(d)>=0||l.length===0)&&u.push(`input_indices[${d}] = 0;`);return[`${u.join(`
`)}`,`var value = ${a.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${a.getByIndices("input_indices")} ${n.selectLastIndex>0?">=":">"} value) {
         value = ${a.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(E_("argMax",{hint:n.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],t,[n.axis],7,n.keepDims),{inputs:[0]})},uy=e=>kn(e)}),yw,t_,vw,bw,ww,jp,Mw,vT,Qy=ut(()=>{Bt(),en(),Hy(),rn(),yw=(e,n)=>{let t=e[0],a=e[1],i=e[2],l=e[3],u=e[4],d=e[5];if(u&&d)throw new Error("Attention cannot have both past and attention_bias");if(t.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let f=t.dims[0],h=t.dims[1],_=t.dims[2];if(i.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(a.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(a.dims[0]!==_)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(i.dims[0]!==a.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let m=i.dims[0]/3,p=m,y=p;if(n.qkvHiddenSizes.length>0){if(n.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let I of n.qkvHiddenSizes)if(I%n.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");m=n.qkvHiddenSizes[0],p=n.qkvHiddenSizes[1],y=n.qkvHiddenSizes[2]}let v=h;if(m!==p)throw new Error("qkv_hidden_sizes first element should be same as the second");if(i.dims[0]!==m+p+y)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let x=0;if(u){if(p!==y)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(u.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(u.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(u.dims[1]!==f)throw new Error('Input "past" second dimension must be batch_size');if(u.dims[2]!==n.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(u.dims[4]!==p/n.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');n.pastPresentShareBuffer||(x=u.dims[3])}let L=v+x,T=-1,E=0;if(l)throw new Error("Mask not supported");if(u)throw new Error("past is not supported");if(d){if(d.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(d.dims[0]!==f||d.dims[1]!==n.numHeads||d.dims[2]!==h||d.dims[3]!==L)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:f,sequenceLength:h,pastSequenceLength:x,kvSequenceLength:v,totalSequenceLength:L,maxSequenceLength:T,inputHiddenSize:_,hiddenSize:m,vHiddenSize:y,headSize:Math.floor(m/n.numHeads),vHeadSize:Math.floor(y/n.numHeads),numHeads:n.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:n.maskFilterValue,maskType:E,scale:n.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},t_=(e,n,t)=>n&&e?`
      let total_sequence_length_input = u32(${n.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${e?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${t?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,vw=(e,n,t,a,i,l,u,d)=>{let f=Tr(u?1:l),h=64,_=l/f;_<h&&(h=32);let m=Math.ceil(l/f/h),p=[{type:12,data:n},{type:12,data:t},{type:12,data:a},{type:12,data:i},{type:12,data:_},{type:12,data:m}],y=ns(e.dataType,f),v=xs(1,f),x=["type"];u&&x.push("type"),d&&x.push("type");let L=T=>{let E=kt("x",e.dataType,e.dims,f),I=[E],P=u?qe("seq_lens",u.dataType,u.dims):void 0;P&&I.push(P);let S=d?qe("total_sequence_length_input",d.dataType,d.dims):void 0;S&&I.push(S);let k=xs(e.dataType),C=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${h}>;
  var<workgroup> thread_sum: array<f32, ${h}>;
  ${T.registerUniforms(C).declareVariables(...I)}
  ${T.mainStart([h,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${t_(P,S,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${h}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${u?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${v}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${v}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(f){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${f}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${h}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${v}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${v}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(f){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${f}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${h}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${E.type.value}(${k}(1.0) / ${k}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${v}(x[offset + i]);
        x[offset + i] = ${E.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${u?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${E.type.value}(${k}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${h};${y};${f}`,inputDependencies:x},getShaderSource:L,getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:i,z:n*t},programUniforms:p})}},bw=(e,n,t,a,i,l,u,d,f)=>{let h=u+l.kvSequenceLength,_=[l.batchSize,l.numHeads,l.sequenceLength,h],m=e>1&&a,p=l.kvNumHeads?l.kvNumHeads:l.numHeads,y=m?[l.batchSize,p,h,l.headSize]:void 0,v=l.nReps?l.nReps:1,x=l.scale===0?1/Math.sqrt(l.headSize):l.scale,L=Tr(l.headSize),T=l.headSize/L,E=12,I={x:Math.ceil(h/E),y:Math.ceil(l.sequenceLength/E),z:l.batchSize*l.numHeads},P=[{type:12,data:l.sequenceLength},{type:12,data:T},{type:12,data:h},{type:12,data:l.numHeads},{type:12,data:l.headSize},{type:1,data:x},{type:12,data:u},{type:12,data:l.kvSequenceLength},{type:12,data:v}],S=m&&a&&Be.size(a.dims)>0,k=["type","type"];S&&k.push("type"),i&&k.push("type"),d&&k.push("type"),f&&k.push("type");let C=[{dims:_,dataType:n.dataType,gpuDataType:0}];m&&C.push({dims:y,dataType:n.dataType,gpuDataType:0});let D=V=>{let U=qe("q",n.dataType,n.dims,L),ne=qe("key",t.dataType,t.dims,L),ee=[U,ne];if(S){let _e=qe("past_key",a.dataType,a.dims,L);ee.push(_e)}i&&ee.push(qe("attention_bias",i.dataType,i.dims));let H=d?qe("seq_lens",d.dataType,d.dims):void 0;H&&ee.push(H);let oe=f?qe("total_sequence_length_input",f.dataType,f.dims):void 0;oe&&ee.push(oe);let ae=kt("output",n.dataType,_),W=[ae];m&&W.push(kt("present_key",n.dataType,y,L));let te=xs(1,L),ie=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${E}u;

  var<workgroup> tileQ: array<${U.type.storage}, ${E*E}>;
  var<workgroup> tileK: array<${U.type.storage}, ${E*E}>;
  ${V.registerUniforms(ie).declareVariables(...ee,...W)}
  ${V.mainStart([E,E,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${v===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${v===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${t_(H,oe,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${S&&m?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${m?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${te}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${S&&m?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${m?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${te}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(L){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${L}`)}})()};
        output[outputIdx] = ${ae.type.value} (sum * uniforms.alpha) + ${i?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${L};${i!==void 0};${a!==void 0};${e}`,inputDependencies:k},getRunData:()=>({outputs:C,dispatchGroup:I,programUniforms:P}),getShaderSource:D}},ww=(e,n,t,a,i,l,u=void 0,d=void 0)=>{let f=l+i.kvSequenceLength,h=i.nReps?i.nReps:1,_=i.vHiddenSize*h,m=e>1&&a,p=i.kvNumHeads?i.kvNumHeads:i.numHeads,y=m?[i.batchSize,p,f,i.headSize]:void 0,v=[i.batchSize,i.sequenceLength,_],x=12,L={x:Math.ceil(i.vHeadSize/x),y:Math.ceil(i.sequenceLength/x),z:i.batchSize*i.numHeads},T=[{type:12,data:i.sequenceLength},{type:12,data:f},{type:12,data:i.vHeadSize},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:12,data:_},{type:12,data:l},{type:12,data:i.kvSequenceLength},{type:12,data:h}],E=m&&a&&Be.size(a.dims)>0,I=["type","type"];E&&I.push("type"),u&&I.push("type"),d&&I.push("type");let P=[{dims:v,dataType:n.dataType,gpuDataType:0}];m&&P.push({dims:y,dataType:n.dataType,gpuDataType:0});let S=k=>{let C=qe("probs",n.dataType,n.dims),D=qe("v",t.dataType,t.dims),V=[C,D];E&&V.push(qe("past_value",a.dataType,a.dims));let U=u?qe("seq_lens",u.dataType,u.dims):void 0;u&&V.push(U);let ne=d?qe("total_sequence_length_input",d.dataType,d.dims):void 0;d&&V.push(ne);let ee=[kt("output",n.dataType,v)];m&&ee.push(kt("present_value",n.dataType,y));let H=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${x}u;
  var<workgroup> tileQ: array<${C.type.value}, ${x*x}>;
  var<workgroup> tileV: array<${C.type.value}, ${x*x}>;
  ${k.registerUniforms(H).declareVariables(...V,...ee)}
  ${k.mainStart([x,x,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${h===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${h===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${t_(U,ne,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${E&&m?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${m?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${C.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${E&&m?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${m?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${a!==void 0};${e}`,inputDependencies:I},getRunData:()=>({outputs:P,dispatchGroup:L,programUniforms:T}),getShaderSource:S}},jp=(e,n,t,a,i,l,u,d,f,h,_=void 0,m=void 0)=>{let p=Math.min(e.outputCount,1+(u?1:0)+(d?1:0)),y=p>1?h.pastSequenceLength:0,v=y+h.kvSequenceLength,x=f&&Be.size(f.dims)>0?f:void 0,L=[n,t];p>1&&u&&Be.size(u.dims)>0&&L.push(u),x&&L.push(x),_&&L.push(_),m&&L.push(m);let T=e.compute(bw(p,n,t,u,x,h,y,_,m),{inputs:L,outputs:p>1?[-1,1]:[-1]})[0];e.compute(vw(T,h.batchSize,h.numHeads,y,h.sequenceLength,v,_,m),{inputs:_&&m?[T,_,m]:[T],outputs:[]});let E=[T,a];p>1&&d&&Be.size(d.dims)>0&&E.push(d),_&&E.push(_),m&&E.push(m),e.compute(ww(p,T,a,d,h,y,_,m),{inputs:E,outputs:p>1?[0,2]:[0]})},Mw=(e,n)=>{let t=[n.batchSize,n.numHeads,n.sequenceLength,n.headSize],a=n.sequenceLength,i=n.inputHiddenSize,l=n.headSize,u=12,d={x:Math.ceil(n.headSize/u),y:Math.ceil(n.sequenceLength/u),z:n.batchSize*n.numHeads},f=[e.inputs[0],e.inputs[1],e.inputs[2]],h=[{type:12,data:a},{type:12,data:i},{type:12,data:l},{type:12,data:n.numHeads},{type:12,data:n.headSize},{type:12,data:n.hiddenSize},{type:12,data:n.hiddenSize+n.hiddenSize+n.vHiddenSize}],_=m=>{let p=kt("output_q",f[0].dataType,t),y=kt("output_k",f[0].dataType,t),v=kt("output_v",f[0].dataType,t),x=qe("input",f[0].dataType,f[0].dims),L=qe("weight",f[1].dataType,f[1].dims),T=qe("bias",f[2].dataType,f[2].dims),E=x.type.storage,I=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${u}u;
  var<workgroup> tileInput: array<${E}, ${u*u}>;
  var<workgroup> tileWeightQ: array<${E}, ${u*u}>;
  var<workgroup> tileWeightK: array<${E}, ${u*u}>;
  var<workgroup> tileWeightV: array<${E}, ${u*u}>;
  ${m.registerUniforms(I).declareVariables(x,L,T,p,y,v)}
  ${m.mainStart([u,u,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${E}(0);
    var valueK = ${E}(0);
    var valueV = ${E}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:t,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:t,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:t,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:d,programUniforms:h}),getShaderSource:_},{inputs:f,outputs:[-1,-1,-1]})},vT=(e,n)=>{let t=yw(e.inputs,n),[a,i,l]=Mw(e,t);return jp(e,a,i,l,e.inputs[4],void 0,void 0,void 0,e.inputs[5],t)}}),xw,Tw,Ew,bT,GO=ut(()=>{Ti(),Bt(),en(),kr(),rn(),xw=(e,n)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let t=(a,i,l)=>{let u=i.length;if(u!==a.length)throw new Error(`${l}: num dimensions != ${u}`);i.forEach((d,f)=>{if(d!==a[f])throw new Error(`${l}: dim[${f}] do not match`)})};if(e[0].dims.length>1){let a=n.format==="NHWC"?n.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,n.spatial?2:void 0);t(e[1].dims,a,"Invalid input scale"),t(e[2].dims,a,"Invalid input B"),t(e[3].dims,a,"Invalid input mean"),t(e[4].dims,a,"Invalid input var")}else t(e[1].dims,[1],"Invalid input scale"),t(e[2].dims,[1],"Invalid input B"),t(e[3].dims,[1],"Invalid input mean"),t(e[4].dims,[1],"Invalid input var")},Tw=(e,n)=>{let{epsilon:t,spatial:a,format:i}=n,l=e[0].dims,u=a?Tr(l[l.length-1]):1,d=i==="NHWC"&&l.length>1?u:1,f=Be.size(l)/u,h=a,_=h?l.length:l,m=qe("x",e[0].dataType,e[0].dims,u),p=qe("scale",e[1].dataType,e[1].dims,d),y=qe("bias",e[2].dataType,e[2].dims,d),v=qe("inputMean",e[3].dataType,e[3].dims,d),x=qe("inputVar",e[4].dataType,e[4].dims,d),L=kt("y",e[0].dataType,_,u),T=()=>{let I="";if(a)I=`let cOffset = ${l.length===1?"0u":i==="NHWC"?`outputIndices[${l.length-1}] / ${u}`:"outputIndices[1]"};`;else if(i==="NCHW")I=`
            ${L.indicesSet("outputIndices","0","0")}
            let cOffset = ${L.indicesToOffset("outputIndices")};`;else{I=`var cIndices = ${p.type.indices}(0);
                       cIndices[0] = outputIndices[${l.length-1}];`;for(let P=1;P<p.rank;P++)I+=`cIndices[${P}] = outputIndices[${P}];`;I+=`let cOffset = ${p.indicesToOffset("cIndices")};`}return I},E=I=>`
  const epsilon = ${t};
  ${I.registerUniform("outputSize","u32").declareVariables(m,p,y,v,x,L)}
  ${I.mainStart()}
  ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${L.offsetToIndices(`global_idx * ${u}`)};
    ${T()}
    let scale = ${p.getByOffset("cOffset")};
    let bias = ${y.getByOffset("cOffset")};
    let inputMean = ${v.getByOffset("cOffset")};
    let inputVar = ${x.getByOffset("cOffset")};
    let x = ${m.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${L.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${n.epsilon}_${n.format}_${a}_${u}`,inputDependencies:h?["rank","type","type","type","type"]:void 0},getShaderSource:E,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:h?[{type:12,data:f},...It(l)]:[{type:12,data:f}]})}},Ew=e=>kn(e),bT=(e,n)=>{let{inputs:t,outputCount:a}=e,i=Ew({...n,outputCount:a});if(Jn.webgpu.validateInputContent&&xw(t,i),n.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(Tw(t,i))}}),Sw,Cw,wT,WO=ut(()=>{en(),rn(),Sw=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Cw=e=>{let n=e[0].dims,t=e[0].dims[2],a=Be.size(n)/4,i=e[0].dataType,l=qe("input",i,n,4),u=qe("bias",i,[t],4),d=qe("residual",i,n,4),f=kt("output",i,n,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:h=>`
  const channels = ${t}u / 4;
  ${h.declareVariables(l,u,d,f)}

  ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes(a)}
    let value = ${l.getByOffset("global_idx")}
      + ${u.getByOffset("global_idx % channels")} + ${d.getByOffset("global_idx")};
    ${f.setByOffset("global_idx","value")}
  }`}},wT=e=>{Sw(e.inputs),e.compute(Cw(e.inputs))}}),Pw,Tn,MT,xT,TT,ET,ST,CT,PT,AT,kT,Aw,OT,$T,DT,IT,kp,LT,__,zT,FT,RT,BT,jT,NT,UT,VT,GT,WT,HT,KT,qT,QT,XT,YT,a0,ZT,cy,dy,JT,eE,tE,kw,Ow,nE,Xy=ut(()=>{Bt(),en(),kr(),rn(),Pw=(e,n,t,a,i,l,u)=>{let d=Math.ceil(n/4),f="";typeof i=="string"?f=`${i}(a)`:f=i("a");let h=qe("inputData",t,[d],4),_=kt("outputData",a,[d],4),m=[{name:"vec_size",type:"u32"}];return u&&m.push(...u),`
      ${e.registerUniforms(m).declareVariables(h,_)}

  ${l??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${h.getByOffset("global_idx")};
    ${_.setByOffset("global_idx",f)}
  }`},Tn=(e,n,t,a,i,l=e.dataType,u,d)=>{let f=[{type:12,data:Math.ceil(Be.size(e.dims)/4)}];return u&&f.push(...u),{name:n,shaderCache:{hint:i,inputDependencies:["type"]},getShaderSource:h=>Pw(h,Be.size(e.dims),e.dataType,l,t,a,d),getRunData:h=>({outputs:[{dims:e.dims,dataType:l}],dispatchGroup:{x:Math.ceil(Be.size(h[0].dims)/64/4)},programUniforms:f})}},MT=e=>{e.compute(Tn(e.inputs[0],"Abs","abs"))},xT=e=>{e.compute(Tn(e.inputs[0],"Acos","acos"))},TT=e=>{e.compute(Tn(e.inputs[0],"Acosh","acosh"))},ET=e=>{e.compute(Tn(e.inputs[0],"Asin","asin"))},ST=e=>{e.compute(Tn(e.inputs[0],"Asinh","asinh"))},CT=e=>{e.compute(Tn(e.inputs[0],"Atan","atan"))},PT=e=>{e.compute(Tn(e.inputs[0],"Atanh","atanh"))},AT=e=>kn(e),kT=(e,n)=>{let t;switch(n.to){case 10:t="vec4<f16>";break;case 1:t="vec4<f32>";break;case 12:t="vec4<u32>";break;case 6:t="vec4<i32>";break;case 9:t="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${n.to}`)}e.compute(Tn(e.inputs[0],"Cast",t,void 0,n.cacheKey,n.to))},Aw=e=>{let n,t,a=e.length>=2&&e[1].data!==0,i=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:n=a?e[1].getFloat32Array()[0]:-34028234663852886e22,t=i?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:n=a?e[1].getUint16Array()[0]:64511,t=i?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return kn({min:n,max:t})},OT=(e,n)=>{let t=n||Aw(e.inputs),a=xs(e.inputs[0].dataType);e.compute(Tn(e.inputs[0],"Clip",i=>`clamp(${i}, vec4<${a}>(uniforms.min), vec4<${a}>(uniforms.max))`,void 0,t.cacheKey,void 0,[{type:e.inputs[0].dataType,data:t.min},{type:e.inputs[0].dataType,data:t.max}],[{name:"min",type:a},{name:"max",type:a}]),{inputs:[0]})},$T=e=>{e.compute(Tn(e.inputs[0],"Ceil","ceil"))},DT=e=>{e.compute(Tn(e.inputs[0],"Cos","cos"))},IT=e=>{e.compute(Tn(e.inputs[0],"Cosh","cosh"))},kp=e=>kn(e),LT=(e,n)=>{let t=xs(e.inputs[0].dataType);e.compute(Tn(e.inputs[0],"Elu",a=>`elu_vf32(${a})`,`
  const elu_alpha_ = ${t}(${n.alpha});

  fn elu_f32(a: ${t}) -> ${t} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${t}>) -> vec4<${t}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,n.cacheKey))},__=(e="f32")=>`
const r0: ${e} = 0.3275911;
const r1: ${e} = 0.254829592;
const r2: ${e} = -0.284496736;
const r3: ${e} = 1.421413741;
const r4: ${e} = -1.453152027;
const r5: ${e} = 1.061405429;

fn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,zT=e=>{let n=xs(e.inputs[0].dataType);e.compute(Tn(e.inputs[0],"Erf",t=>`erf_vf32(${t})`,__(n)))},FT=e=>{e.compute(Tn(e.inputs[0],"Exp","exp"))},RT=e=>{e.compute(Tn(e.inputs[0],"Floor","floor"))},BT=e=>{let n=xs(e.inputs[0].dataType);e.compute(Tn(e.inputs[0],"Gelu",t=>`0.5 * ${t} * (1.0 + erf_vf32(${t} * 0.7071067811865475))`,__(n)))},jT=(e,n)=>{let t=xs(e.inputs[0].dataType);e.compute(Tn(e.inputs[0],"LeakyRelu",a=>`select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${t}>(0.0))`,`const leaky_relu_alpha_ = ${t}(${n.alpha});`,n.cacheKey))},NT=e=>{e.compute(Tn(e.inputs[0],"Not",n=>`!${n}`))},UT=e=>{e.compute(Tn(e.inputs[0],"Neg",n=>`-${n}`))},VT=e=>{e.compute(Tn(e.inputs[0],"Reciprocal",n=>`1.0/${n}`))},GT=e=>{let n=xs(e.inputs[0].dataType);e.compute(Tn(e.inputs[0],"Relu",t=>`select(vec4<${n}>(0.0), ${t}, ${t} > vec4<${n}>(0.0))`))},WT=e=>{e.compute(Tn(e.inputs[0],"Sigmoid",n=>`(1.0 / (1.0 + exp(-${n})))`))},HT=e=>kn(e),KT=(e,n)=>{let t=xs(e.inputs[0].dataType);e.compute(Tn(e.inputs[0],"HardSigmoid",a=>`max(vec4<${t}>(0.0), min(vec4<${t}>(1.0), ${n.alpha} * ${a} + vec4<${t}>(${n.beta})))`,void 0,n.cacheKey))},qT=e=>{e.compute(Tn(e.inputs[0],"Sin","sin"))},QT=e=>{e.compute(Tn(e.inputs[0],"Sinh","sinh"))},XT=e=>{e.compute(Tn(e.inputs[0],"Sqrt","sqrt"))},YT=e=>{e.compute(Tn(e.inputs[0],"Tan","tan"))},a0=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,ZT=e=>{e.compute(Tn(e.inputs[0],"Tanh",a0))},cy=(e="f32")=>`
const fast_gelu_a: ${e} = 0.5;
const fast_gelu_b: ${e} = 0.7978845608028654;
const fast_gelu_c: ${e} = 0.035677408136300125;

fn tanh_v(v: vec4<${e}>) -> vec4<${e}> {
  return ${a0("v")};
}
`,dy=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,JT=e=>{let n=xs(e.inputs[0].dataType);e.compute(Tn(e.inputs[0],"FastGelu",dy,cy(n),void 0,e.inputs[0].dataType))},eE=(e,n)=>{let t=xs(e.inputs[0].dataType);return e.compute(Tn(e.inputs[0],"ThresholdedRelu",a=>`select(vec4<${t}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${t}>(${n.alpha});`,n.cacheKey)),0},tE=e=>{e.compute(Tn(e.inputs[0],"Log","log"))},kw=(e,n)=>`
const alpha = vec4<${e}>(${n});
const one = ${e}(1.0);
const zero = ${e}(0.0);

fn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {
  let v = x *alpha;
  var x1 : vec4<${e}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,Ow=e=>`quick_gelu_impl(${e})`,nE=(e,n)=>{let t=xs(e.inputs[0].dataType);e.compute(Tn(e.inputs[0],"QuickGelu",Ow,kw(t,n.alpha),n.cacheKey,e.inputs[0].dataType))}}),$w,Dw,rE,HO=ut(()=>{en(),rn(),Xy(),$w=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Dw=e=>{let n=e[0].dims.slice();n[2]=n[2]/2;let t=qe("input",e[0].dataType,e[0].dims,4),a=qe("bias",e[0].dataType,[e[0].dims[2]],4),i=kt("output",e[0].dataType,n,4),l=Be.size(n)/4,u=ns(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:d=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${d.declareVariables(t,a,i)}

  ${__(u)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes(l)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${i.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},rE=e=>{$w(e.inputs),e.compute(Dw(e.inputs))}}),Iw,Lw,gi,sE,aE,iE,oE,lE,uE,cE,dE,fE,hE,KO=ut(()=>{Bt(),en(),rn(),Iw=(e,n,t,a,i,l,u,d,f,h,_,m)=>{let p,y;typeof d=="string"?p=y=(E,I)=>`${d}((${E}),(${I}))`:typeof d=="function"?p=y=d:(p=d.scalar,y=d.vector);let v=kt("outputData",_,a.length,4),x=qe("aData",f,n.length,4),L=qe("bData",h,t.length,4),T;if(i)if(l){let E=Be.size(n)===1,I=Be.size(t)===1,P=n.length>0&&n[n.length-1]%4===0,S=t.length>0&&t[t.length-1]%4===0;E||I?T=v.setByOffset("global_idx",y(E?`${x.type.value}(${x.getByOffset("0")}.x)`:x.getByOffset("global_idx"),I?`${L.type.value}(${L.getByOffset("0")}.x)`:L.getByOffset("global_idx"))):T=`
            let outputIndices = ${v.offsetToIndices("global_idx * 4u")};
            let offsetA = ${x.broadcastedIndicesToOffset("outputIndices",v)};
            let offsetB = ${L.broadcastedIndicesToOffset("outputIndices",v)};
            ${v.setByOffset("global_idx",y(u||P?x.getByOffset("offsetA / 4u"):`${x.type.value}(${x.getByOffset("offsetA / 4u")}[offsetA % 4u])`,u||S?L.getByOffset("offsetB / 4u"):`${L.type.value}(${L.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else T=v.setByOffset("global_idx",y(x.getByOffset("global_idx"),L.getByOffset("global_idx")));else{if(!l)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let E=(I,P,S="")=>{let k=`aData[indexA${P}][componentA${P}]`,C=`bData[indexB${P}][componentB${P}]`;return`
            let outputIndices${P} = ${v.offsetToIndices(`global_idx * 4u + ${P}u`)};
            let offsetA${P} = ${x.broadcastedIndicesToOffset(`outputIndices${P}`,v)};
            let offsetB${P} = ${L.broadcastedIndicesToOffset(`outputIndices${P}`,v)};
            let indexA${P} = offsetA${P} / 4u;
            let indexB${P} = offsetB${P} / 4u;
            let componentA${P} = offsetA${P} % 4u;
            let componentB${P} = offsetB${P} % 4u;
            ${I}[${P}] = ${S}(${p(k,C)});
          `};_===9?T=`
            var data = vec4<u32>(0);
            ${E("data",0,"u32")}
            ${E("data",1,"u32")}
            ${E("data",2,"u32")}
            ${E("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:T=`
            ${E("outputData[global_idx]",0)}
            ${E("outputData[global_idx]",1)}
            ${E("outputData[global_idx]",2)}
            ${E("outputData[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(x,L,v)}

        ${m??""}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${T}
      }`},Lw=(e,n,t,a,i,l,u=t.dataType)=>{let d=t.dims.map(x=>Number(x)??1),f=a.dims.map(x=>Number(x)??1),h=!Be.areEqual(d,f),_=d,m=Be.size(d),p=!1,y=!1,v=[h];if(h){let x=of.calcShape(d,f,!1);if(!x)throw new Error("Can't perform binary op on the given tensors");_=x.slice(),m=Be.size(_);let L=Be.size(d)===1,T=Be.size(f)===1,E=d.length>0&&d[d.length-1]%4===0,I=f.length>0&&f[f.length-1]%4===0;v.push(L),v.push(T),v.push(E),v.push(I);let P=1;for(let S=1;S<_.length;S++){let k=d[d.length-S],C=f[f.length-S];if(k===C)P*=k;else break}P%4===0?(y=!0,p=!0):(L||T||E||I)&&(p=!0)}else p=!0;return v.push(p),{name:e,shaderCache:{hint:n+v.map(x=>x.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:x=>Iw(x,d,f,_,p,h,y,i,t.dataType,a.dataType,u,l),getRunData:()=>({outputs:[{dims:_,dataType:u}],dispatchGroup:{x:Math.ceil(m/64/4)},programUniforms:[{type:12,data:Math.ceil(Be.size(_)/4)},...It(d,f,_)]})}},gi=(e,n,t,a,i,l)=>{e.compute(Lw(n,i??"",e.inputs[0],e.inputs[1],t,a,l))},sE=e=>{gi(e,"Add",(n,t)=>`${n}+${t}`)},aE=e=>{gi(e,"Div",(n,t)=>`${n}/${t}`)},iE=e=>{gi(e,"Equal",{scalar:(n,t)=>`u32(${n}==${t})`,vector:(n,t)=>`vec4<u32>(${n}==${t})`},void 0,void 0,9)},oE=e=>{gi(e,"Mul",(n,t)=>`${n}*${t}`)},lE=e=>{let n=qe("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;gi(e,"Pow",{scalar:(t,a)=>`pow_custom(${t},${a})`,vector:(t,a)=>`pow_vector_custom(${t},${a})`},`
    fn pow_custom(a : ${n}, b : ${n}) -> ${n} {
      if (b == ${n}(0.0)) {
        return ${n}(1.0);
      } else if (a < ${n}(0.0) && f32(b) != floor(f32(b))) {
        return ${n}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${n}(1.0), round(f32(abs(b) % ${n}(2.0))) != 1.0) * ${n}(${n==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${n}>, b : vec4<${n}>) -> vec4<${n}> {
      // TODO: implement vectorized pow
      return vec4<${n}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},uE=e=>{gi(e,"Sub",(n,t)=>`${n}-${t}`)},cE=e=>{gi(e,"Greater",{scalar:(n,t)=>`u32(${n}>${t})`,vector:(n,t)=>`vec4<u32>(${n}>${t})`},void 0,void 0,9)},dE=e=>{gi(e,"Less",{scalar:(n,t)=>`u32(${n}<${t})`,vector:(n,t)=>`vec4<u32>(${n}<${t})`},void 0,void 0,9)},fE=e=>{gi(e,"GreaterOrEqual",{scalar:(n,t)=>`u32(${n}>=${t})`,vector:(n,t)=>`vec4<u32>(${n}>=${t})`},void 0,void 0,9)},hE=e=>{gi(e,"LessOrEqual",{scalar:(n,t)=>`u32(${n}<=${t})`,vector:(n,t)=>`vec4<u32>(${n}<=${t})`},void 0,void 0,9)}}),zw,Fw,Rw,Bw,pE,mE,qO=ut(()=>{Bt(),en(),kr(),rn(),zw=(e,n)=>{if(!e||e.length<1)throw new Error("too few inputs");let t=0,a=e[t],i=a.dataType,l=a.dims.length;e.forEach((u,d)=>{if(d!==t){if(u.dataType!==i)throw new Error("input tensors should be one type");if(u.dims.length!==l)throw new Error("input tensors should have the same shape");u.dims.forEach((f,h)=>{if(h!==n&&f!==a.dims[h])throw new Error("non concat dimensions must match")})}})},Fw=(e,n)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${e}u>(${n});
    for (var i: u32 = 0u; i < ${e}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,Rw=(e,n)=>{let t=e.length,a=[];for(let i=0;i<t;++i){let l=n.setByOffset("global_idx",e[i].getByIndices("indices"));t===1?a.push(l):i===0?a.push(`if (inputIndex == ${i}u) { ${l} }`):i===t-1?a.push(`else { ${l} }`):a.push(`else if (inputIndex == ${i}) { ${l} }`)}return a.join(`
`)},Bw=(e,n,t,a)=>{let i=Be.size(t),l=new Array(e.length),u=new Array(e.length),d=0,f=[],h=[],_=[{type:12,data:i}];for(let x=0;x<e.length;++x)d+=e[x].dims[n],l[x]=d,h.push(e[x].dims.length),u[x]=qe(`input${x}`,a,h[x]),f.push("rank"),_.push({type:12,data:l[x]});for(let x=0;x<e.length;++x)_.push(...It(e[x].dims));_.push(...It(t));let m=kt("output",a,t.length),p=m.indicesGet("indices",n),y=Array.from(Array(l.length).keys()).map(x=>`uniforms.sizeInConcatAxis${x}`).join(","),v=x=>`

  ${(()=>{x.registerUniform("outputSize","u32");for(let L=0;L<e.length;L++)x.registerUniform(`sizeInConcatAxis${L}`,"u32");return x.declareVariables(...u,m)})()}

  ${Fw(l.length,y)}

  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${m.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${p});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${l.length}u>(${y});
      ${p} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${Rw(u,m)}
  }`;return{name:"Concat",shaderCache:{hint:`${n}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:t,dataType:a}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:_}),getShaderSource:v}},pE=(e,n)=>{let t=e.inputs,a=t[0].dims,i=Be.normalizeAxis(n.axis,a.length);zw(t,i);let l=a.slice();l[i]=t.reduce((d,f)=>d+(f.dims.length>i?f.dims[i]:0),0);let u=t.filter(d=>Be.size(d.dims)>0);e.compute(Bw(u,i,l,t[0].dataType),{inputs:u})},mE=e=>kn({axis:e.axis})}),wc,Mc,xc,Yy,Sc=ut(()=>{Bt(),en(),wc=(e,n,t="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${n}(0.0));`;case"Sigmoid":return`value = (${n}(1.0) / (${n}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${n}(${t}(uniforms.clip_min)), ${n}(${t}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${n}(0.0), min(${n}(1.0), ${t}(uniforms.alpha) * value + ${t}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${t}(uniforms.alpha) * value, value, value >= ${n}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},Mc=(e,n)=>{e.activation==="Clip"?n.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation==="HardSigmoid"?n.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation==="LeakyRelu"&&n.push({type:1,data:e.alpha})},xc=(e,n)=>{e.activation==="Clip"?n.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):e.activation==="HardSigmoid"?n.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):e.activation==="LeakyRelu"&&n.push({name:"alpha",type:"f32"})},Yy=e=>{let n=e?.activation||"";if(n==="HardSigmoid"){let[t,a]=e?.activation_params||[.2,.5];return{activation:n,alpha:t,beta:a}}else if(n==="Clip"){let[t,a]=e?.activation_params||[Nx,Ux];return{activation:n,clipMax:a,clipMin:t}}else if(n==="LeakyRelu"){let[t]=e?.activation_params||[.01];return{activation:n,alpha:t}}return{activation:n}}}),os,_E,Zy=ut(()=>{os=(e,n)=>{switch(e){case 1:return n;case 2:return`vec2<${n}>`;case 3:return`vec3<${n}>`;case 4:return`vec4<${n}>`;default:throw new Error(`${e}-component is not supported.`)}},_E=e=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      `}),gE,QO=ut(()=>{gE=e=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));
}
`}),Lp,Jy,ev=ut(()=>{Bt(),en(),rn(),Sc(),Lp=(e,n,t,a,i)=>{let l=a-t;return`
      ${Array.from({length:t}).map((u,d)=>`
      if (${Ot(n.shape,d,n.rank)} != 1) {
        ${n.indicesSet(e,d,Ot(i,d+l,a))}
      } else {
        ${n.indicesSet(e,d,0)}
      }`).join("")}
`},Jy=(e,n,t,a,i=!1,l)=>{let u=e[0].dims,d=e[1].dims,f=u[u.length-2],h=d[d.length-1],_=u[u.length-1],m=Tr(h),p=Tr(_),y=Tr(f),v=Be.size(t)/m/y,x=e.length>2,L=a?a.slice(0,-2):t.slice(0,-2),T=[Be.size(L),f,h],E=[{type:12,data:v},{type:12,data:f},{type:12,data:h},{type:12,data:_}];Mc(n,E),E.push(...It(L,u,d)),x&&E.push(...It(e[2].dims)),E.push(...It(T));let I=P=>{let S=Ky("batch_dims",e[0].dataType,L.length),k=qe("a",e[0].dataType,u.length,p),C=qe("b",e[1].dataType,d.length,m),D=kt("output",e[0].dataType,T.length,m),V=ns(D.type.tensor),U=wc(n,D.type.value,V),ne=[k,C],ee="";if(x){let ae=i?m:1;ne.push(qe("bias",e[2].dataType,e[2].dims.length,ae)),ee=`${i?`value += bias[col / ${ae}];`:`value += ${D.type.value}(bias[row + i]);`}`}let H=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];xc(n,H);let oe=()=>{let ae=`var a_data: ${k.type.value};`;for(let W=0;W<p;W++)ae+=`
              let b_data${W} = b[(b_offset + (k + ${W}) * uniforms.N + col) / ${m}];`;for(let W=0;W<y;W++){ae+=`a_data = a[(a_offset + (row + ${W}) * uniforms.K + k) / ${p}];`;for(let te=0;te<p;te++)ae+=`
            values[${W}] = fma(${C.type.value}(a_data${p===1?"":`[${te}]`}), b_data${te}, values[${W}]);
`}return ae};return`
  ${P.registerUniforms(H).registerInternalVariables(S).declareVariables(...ne,D)}
  ${P.mainStart()}
    ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${m})) * ${m};
    var index1 = global_idx / (uniforms.N / ${m});
    let stride1 = uniforms.M / ${y};
    let row = (index1 % stride1) * ${y};
    let batch = index1 / stride1;

    ${t.length===2?"":`let batch_indices = ${S.offsetToIndices("batch")};`}

    var a_indices: ${k.type.indices};
    ${Lp("a_indices",k,k.rank-2,S.rank,"batch_indices")}
    ${k.indicesSet("a_indices",k.rank-2,0)}
    ${k.indicesSet("a_indices",k.rank-1,0)}
    let a_offset = ${k.indicesToOffset("a_indices")};

    var b_indices: ${C.type.indices};
    ${Lp("b_indices",C,C.rank-2,S.rank,"batch_indices")}
    ${C.indicesSet("b_indices",C.rank-2,0)}
    ${C.indicesSet("b_indices",C.rank-1,0)}
    let b_offset = ${C.indicesToOffset("b_indices")};
    var values: array<${D.type.value}, ${y}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${p}) {
      ${oe()}
    }
    for (var i = 0u; i < ${y}u; i++) {
      var value = values[i];
      ${ee}
      ${U}
      let cur_indices = ${D.type.indices}(batch, row + i, col);
      let offset = ${D.indicesToOffset("cur_indices")};
      ${D.setByOffset(`offset / ${m}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${n.activation};${m};${p};${y};${i}`,inputDependencies:x?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:l?l(t):t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:E}),getShaderSource:I}}}),jw,Nw,fy,i0,Uw,hy,Vw,S_,tv=ut(()=>{Bt(),en(),rn(),Sc(),ev(),Zy(),jw=(e,n)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${n?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${n?", batchIndices":""});
        `,Nw=(e,n)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${n===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${n===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${n===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,fy=(e,n,t="f32",a,i=!1,l=32,u=!1,d=32)=>{let f=n[1]*e[1],h=n[0]*e[0],_=i?f:l,m=i?l:f,p=_/n[0],y=l/n[1];if(!((i&&p===4&&e[1]===4||!i&&(p===3||p===4))&&_%n[0]===0&&l%n[1]===0&&e[0]===4))throw new Error(`If transposeA ${i} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${p} must be 3 or 4.
  tileAWidth ${_} must be divisible by workgroupSize[0]${n[0]}. tileInner ${l} must be divisible by workgroupSize[1] ${n[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${p}<${t}>, ${_/p}>, ${m}>;
var<workgroup> mm_Bsub: array<array<vec4<${t}>, ${h/e[0]}>, ${l}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${p};
const tileInner = ${l};

@compute @workgroup_size(${n[0]}, ${n[1]}, ${n[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${u?"0":"i32(globalId.z)"};
  ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${f};

  let num_tiles = ${u?`${Math.ceil(d/l)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};

  var acc: array<vec4<${t}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${y};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${jw(i,a)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${a?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${p===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${Nw(i,p)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},i0=(e,n)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${n?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${n?", batchIndices":""});
            `,Uw=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",hy=(e,n,t="f32",a,i=!1,l=32,u=!1,d=32,f=!1)=>{let h=e[1]*n[1],_=e[0]*n[0],m=i?h:l,p=i?l:h;if(!(p%n[1]===0&&m%n[0]===0&&l%n[1]===0))throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${n[1]}, tileAWidth ${m} must be divisible by workgroupSize[0]${n[0]}, tileInner ${l} must be divisible by workgroupSize[1]${n[1]}`);let y=p/n[1],v=m/n[0],x=l/n[1],L=f?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${h};
    let globalColStart = i32(workgroupId.x) * ${_};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${n[1]}) {
        for (var inputCol = localCol; inputCol < ${m}; inputCol = inputCol + ${n[0]}) {
          ${i0(i,a)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${l}; inputRow = inputRow + ${n[1]}) {
            for (var inputCol = localCol; inputCol < ${_}; inputCol = inputCol + ${n[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${a?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${t}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${n[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${i?`mm_Asub[k][localRow + innerRow * ${n[1]}];`:`mm_Asub[localRow + innerRow * ${n[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${n[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${n[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${h};

let tileRowA = i32(localId.y) * ${y};
let tileColA = i32(localId.x) * ${v};
let tileRowB = i32(localId.y) * ${x};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${v}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${i0(i,a)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${x}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${a?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${t}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Uw(i)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${t}, ${m}>, ${p}>;
  var<workgroup> mm_Bsub : array<array<${t}, ${_}>, ${l}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${l};

@compute @workgroup_size(${n[0]}, ${n[1]}, ${n[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${u?"0":"i32(globalId.z)"};
    ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${u?`${Math.ceil(d/l)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};

    var acc : array<array<${t}, colPerThread>, rowPerThread>;
    ${L}
  }
`},Vw=(e,n,t,a,i=!1)=>{let[l,u,d,f]=a,h=ns(a[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${os(e,h)} {
      var value = ${os(e,h)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${u.type.indices};
        ${Lp("aIndices",u,u.rank-2,l.rank,"batchIndices")}
        ${u.indicesSet("aIndices",u.rank-2,"u32(row)")}
        ${u.indicesSet("aIndices",u.rank-1,"u32(colIn)")}
        value = ${u.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${os(e,h)} {
      var value = ${os(e,h)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${d.type.indices};
        ${Lp("bIndices",d,d.rank-2,l.rank,"batchIndices")}
        ${d.indicesSet("bIndices",d.rank-2,"u32(row)")}
        ${d.indicesSet("bIndices",d.rank-1,"u32(colIn)")}
        value = ${d.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${os(e,h)}) {
      let col = colIn * ${e};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${n?`value = value + ${i?"bias[colIn]":`${os(e,h)}(bias[row])`};`:""}
        ${t}
        ${f.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},S_=(e,n,t,a,i=!1,l)=>{let u=e[0].dims,d=e[1].dims,f=u.slice(0,-2),h=d.slice(0,-2),_=a?a.slice(0,-2):t.slice(0,-2),m=Be.size(_),p=u[u.length-2],y=u[u.length-1],v=d[d.length-1],x=y%4===0&&v%4===0,L=p<=8?[4,1,1]:[4,4,1],T=[8,8,1],E=[Math.ceil(v/T[0]/L[0]),Math.ceil(p/T[1]/L[1]),Math.ceil(m/T[2]/L[2])],I=x?4:1,P=[...f,p,y/I],S=P.length,k=[...h,y,v/I],C=k.length,D=[m,p,v/I],V=[{type:6,data:p},{type:6,data:v},{type:6,data:y}];Mc(n,V),V.push(...It(_,P,k));let U=["rank","rank"],ne=e.length>2;ne&&(V.push(...It(e[2].dims)),U.push("rank")),V.push(...It(D));let ee=H=>{let oe=_.length,ae=Ky("batchDims",e[0].dataType,oe,1),W=ns(e[0].dataType),te=qe("a",e[0].dataType,S,I),ie=qe("b",e[1].dataType,C,I),_e=kt("result",e[0].dataType,D.length,I),q=[te,ie];if(ne){let fe=i?I:1;q.push(qe("bias",e[2].dataType,e[2].dims.length,fe))}let B=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];xc(n,B);let R=ns(_e.type.tensor),Q=wc(n,_e.type.value,R),G=Vw(I,ne,Q,[ae,te,ie,_e],i);return`
  ${H.registerUniforms(B).registerInternalVariables(ae).declareVariables(...q,_e)}
  ${G}
  ${x?fy(L,T,W,ae):hy(L,T,W,ae)}
                   `};return{name:"MatMul",shaderCache:{hint:`${L};${n.activation};${x};${i}`,inputDependencies:U},getRunData:()=>({outputs:[{dims:l?l(t):t,dataType:e[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:V}),getShaderSource:ee}}}),Gw,yE,XO=ut(()=>{Bt(),qo(),rn(),Sc(),Zy(),QO(),tv(),Gw=(e,n,t,a,i=!1,l,u=4,d=4,f=4,h="f32")=>{let _=V=>{switch(V){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${h}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${V} is not supported.`)}},m=V=>{switch(V){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${V} is not supported.`)}},p=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,y=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,v=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",x=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",L=e?"row":"col",T=e?"col":"row",E=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${L} / outWidth;
    let outCol = ${L} % outWidth;

    let WRow = ${T} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${T} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${T} % inChannels;
    var resData = ${os(u,h)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${v} && xCol >= 0 && xCol < ${x}) {
      ${p}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${_(u)}
    }
    return resData;`,I=e?n&&a?`
    let col = colIn * ${u};
    ${E}`:`
    let col = colIn * ${u};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${E}
    }
    return ${os(u,h)}(0.0);`:a&&t?`
    let col = colIn * ${u};
    ${E}`:`
    let col = colIn * ${u};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${E}
    }
    return ${os(u,h)}(0.0);`,P=e?a&&t?m(d):`
    let col = colIn * ${d};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${m(d)}
    }
    return ${os(d,h)}(0.0);`:`
    let col = colIn * ${d};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${m(d)}
    }
    return ${os(d,h)}(0.0);`,S=os(f,h),k=os(e?u:d,h),C=os(e?d:u,h),D=wc(l,S,h);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${k} {
      ${e?I:P}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${C} {
      ${e?P:I}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${S}) {
      let col = colIn * ${f};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${y}
      ${_E(i)}
      ${D}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},yE=(e,n,t,a,i,l,u,d,f)=>{let h=n.format==="NHWC",_=h?e[0].dims[3]:e[0].dims[1],m=t[0],p=h?t[2]:t[3],y=h?t[1]:t[2],v=h?t[3]:t[1],x=h&&(_%4===0||_%3===0)&&v%4===0,L=h?v:p*y,T=h?p*y:v,E=[8,8,1],I=a<=8?[4,1,1]:[4,4,1],P=[Math.ceil(L/E[0]/I[0]),Math.ceil(T/E[1]/I[1]),Math.ceil(m/E[2]/I[2])];mn("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${P}`);let S=x?h&&_%4!==0?3:4:1,k=E[1]*I[1],C=E[0]*I[0],D=Math.max(E[0]*S,E[1]),V=a%k===0,U=i%C===0,ne=l%D===0,ee=x?[S,4,4]:[1,1,1],H=[{type:6,data:a},{type:6,data:i},{type:6,data:l},{type:6,data:[n.pads[0],n.pads[1]]},{type:6,data:n.strides},{type:6,data:n.dilations}];Mc(n,H),H.push(...It(e[0].dims,e[1].dims));let oe=["rank","rank"];u&&(H.push(...It(e[2].dims)),oe.push("rank")),H.push(...It(t));let ae=W=>{let te=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];xc(n,te);let ie=x?4:1,_e=ns(e[0].dataType),q=`
      fn setOutputAtIndex(flatIndex : i32, value : ${x?`vec4<${_e}>`:_e}) {
        result[flatIndex] = ${x?`vec4<${_e}>`:_e}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${x?`vec4<${_e}>`:_e}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${x?"/ 4":""}, value);
      }`,B=qe("x",e[0].dataType,e[0].dims.length,S===3?1:S),R=qe("w",e[1].dataType,e[1].dims.length,ie),Q=[B,R],G=kt("result",e[0].dataType,t.length,ie);if(u){let fe=qe("bias",e[2].dataType,e[2].dims.length,ie);Q.push(fe),q+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${x?`vec4<${_e}>`:_e} {
          return bias[coords.${h?"w":"y"}${x?"/ 4":""}];
        }`}return`
        ${gE("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${W.registerUniforms(te).declareVariables(...Q,G)}
        ${q}
        ${Gw(h,V,U,ne,u,n,ee[0],ee[1],ee[2],_e)}
        ${x?fy(I,E,_e,void 0,!h,D):hy(I,E,_e,void 0,!h,D,!1,void 0,d)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${n.cacheKey};${S};${x};${V};${U};${ne};${k};${C};${D}`,inputDependencies:oe},getRunData:()=>({outputs:[{dims:f?f(t):t,dataType:e[0].dataType}],dispatchGroup:{x:P[0],y:P[1],z:P[2]},programUniforms:H}),getShaderSource:ae}}}),Ww,o0,wp,Hw,l0,Kw,vE,bE,YO=ut(()=>{Bt(),qo(),en(),rn(),Sc(),Zy(),Ww=e=>{let n=1;for(let t=0;t<e.length;t++)n*=e[t];return n},o0=e=>typeof e=="number"?[e,e,e]:e,wp=(e,n)=>n<=1?e:e+(e-1)*(n-1),Hw=(e,n,t,a=1)=>{let i=wp(n,a);return Math.floor((e[0]*(t-1)-t+i)/2)},l0=(e,n,t,a,i)=>{i==null&&(i=Hw(e,n[0],a[0]));let l=[0,0,0,t];for(let u=0;u<3;u++)e[u]+2*i>=n[u]&&(l[u]=Math.trunc((e[u]-n[u]+2*i)/a[u]+1));return l},Kw=(e,n,t,a,i,l,u,d,f,h)=>{let _,m,p,y;if(e==="VALID"&&(e=0),typeof e=="number"){_={top:e,bottom:e,left:e,right:e,front:e,back:e};let v=l0([n,t,a,1],[d,f,h],1,[i,l,u],e);m=v[0],p=v[1],y=v[2]}else if(Array.isArray(e)){if(!e.every((x,L,T)=>x===T[0]))throw Error(`Unsupported padding parameter: ${e}`);_={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let v=l0([n,t,a,1],[d,f,h],1,[i,l,u],e[0]);m=v[0],p=v[1],y=v[2]}else if(e==="SAME_UPPER"){m=Math.ceil(n/i),p=Math.ceil(t/l),y=Math.ceil(a/u);let v=(m-1)*i+d-n,x=(p-1)*l+f-t,L=(y-1)*u+h-a,T=Math.floor(v/2),E=v-T,I=Math.floor(x/2),P=x-I,S=Math.floor(L/2),k=L-S;_={top:I,bottom:P,left:S,right:k,front:T,back:E}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:_,outDepth:m,outHeight:p,outWidth:y}},vE=(e,n,t,a,i,l=!1,u="channelsLast")=>{let d,f,h,_,m;if(u==="channelsLast")[d,f,h,_,m]=e;else if(u==="channelsFirst")[d,m,f,h,_]=e;else throw new Error(`Unknown dataFormat ${u}`);let[p,,y,v,x]=n,[L,T,E]=o0(t),[I,P,S]=o0(a),k=wp(y,I),C=wp(v,P),D=wp(x,S),{padInfo:V,outDepth:U,outHeight:ne,outWidth:ee}=Kw(i,f,h,_,L,T,E,k,C,D),H=l?p*m:p,oe=[0,0,0,0,0];return u==="channelsFirst"?oe=[d,H,U,ne,ee]:u==="channelsLast"&&(oe=[d,U,ne,ee,H]),{batchSize:d,dataFormat:u,inDepth:f,inHeight:h,inWidth:_,inChannels:m,outDepth:U,outHeight:ne,outWidth:ee,outChannels:H,padInfo:V,strideDepth:L,strideHeight:T,strideWidth:E,filterDepth:y,filterHeight:v,filterWidth:x,effectiveFilterDepth:k,effectiveFilterHeight:C,effectiveFilterWidth:D,dilationDepth:I,dilationHeight:P,dilationWidth:S,inShape:e,outShape:oe,filterShape:n}},bE=(e,n,t,a,i,l)=>{let u=l==="channelsLast";u?e[0].dims[3]:e[0].dims[1];let d=[64,1,1],f={x:t.map((L,T)=>T)},h=[Math.ceil(Ww(f.x.map(L=>t[L]))/d[0]),1,1];mn("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${h}`);let _=1,m=Be.size(t),p=[{type:12,data:m},{type:12,data:a},{type:12,data:i},{type:12,data:n.strides},{type:12,data:n.dilations}];Mc(n,p),p.push(...It(e[0].dims,e[1].dims));let y=["rank","rank"],v=e.length===3;v&&(p.push(...It(e[2].dims)),y.push("rank")),p.push(...It(t));let x=L=>{let T=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:a.length},{name:"pads",type:"u32",length:i.length},{name:"strides",type:"u32",length:n.strides.length},{name:"dilations",type:"u32",length:n.dilations.length}];xc(n,T);let E=1,I=ns(e[0].dataType),P=qe("x",e[0].dataType,e[0].dims.length,_),S=qe("W",e[1].dataType,e[1].dims.length,E),k=[P,S],C=kt("result",e[0].dataType,t.length,E),D="";if(v){let ne=qe("bias",e[2].dataType,e[2].dims.length,E);k.push(ne),D+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${I} {
          return bias[${u?Ot("coords",4,5):Ot("coords",1,5)}];
        }`}let V=os(_,I),U=wc(n,V,I);return`
            ${D}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${P.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${S.getByIndices("aIndices")};
            }
          ${L.registerUniforms(T).declareVariables(...k,C)}
          ${L.mainStart()}
          ${L.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${C.offsetToIndices("global_idx")};
              let batch = ${Ot("coords",0,P.rank)};
              let d2 = ${u?Ot("coords",P.rank-1,P.rank):Ot("coords",1,P.rank)};
              let xFRCCorner = vec3<u32>(${u?Ot("coords",1,P.rank):Ot("coords",2,P.rank)},
              ${u?Ot("coords",2,P.rank):Ot("coords",3,P.rank)},
              ${u?Ot("coords",3,P.rank):Ot("coords",4,P.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${u?Ot("uniforms.x_shape",1,P.rank):Ot("uniforms.x_shape",2,P.rank)};
              let xShapeZ = ${u?Ot("uniforms.x_shape",2,P.rank):Ot("uniforms.x_shape",3,P.rank)};
              let xShapeW = ${u?Ot("uniforms.x_shape",3,P.rank):Ot("uniforms.x_shape",4,P.rank)};
              let xShapeU = ${u?Ot("uniforms.x_shape",4,P.rank):Ot("uniforms.x_shape",1,P.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${u?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${u?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${u?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${u?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${v?"value = value + getBiasByOutputCoords(coords)":""};
              ${U}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${n.cacheKey};${u};${_};${v}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:h[0],y:h[1],z:h[2]},programUniforms:p}),getShaderSource:x}}}),wE,ME,ZO=ut(()=>{Bt(),en(),rn(),Sc(),wE=(e,n,t,a)=>{let i=e.length>2,l=i?"value += b[output_channel];":"",u=e[0].dims,d=e[1].dims,f=n.format==="NHWC",h=f?t[3]:t[1],_=h/n.group,m=f&&_>=4?Tr(h):1,p=Be.size(t)/m,y=[{type:12,data:p},{type:12,data:n.dilations},{type:12,data:[n.strides[0],n.strides[1]]},{type:12,data:[n.pads[0],n.pads[1]]},{type:12,data:_}];Mc(n,y),y.push(...It(u,[d[0],d[1],d[2],d[3]/m]));let v=i?["rank","rank","rank"]:["rank","rank"];y.push(...It([t[0],t[1],t[2],t[3]/m]));let x=L=>{let T=kt("output",e[0].dataType,t.length,m),E=ns(T.type.tensor),I=wc(n,T.type.value,E),P=qe("x",e[0].dataType,u.length),S=qe("w",e[1].dataType,d.length,m),k=[P,S];i&&k.push(qe("b",e[2].dataType,e[2].dims,m));let C=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:n.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];xc(n,C);let D=f?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${P.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${S.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${P.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${S.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${L.registerUniforms(C).declareVariables(...k,T)}

  ${L.mainStart()}
    ${L.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${T.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${f?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${f?1:2}], outputIndices[${f?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${m} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${f?2:1}];

    var value: ${T.type.value} = ${T.type.value}(0);
    ${D}
    ${l}
    ${I}
    ${T.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${n.cacheKey}_${m}`,inputDependencies:v},getRunData:()=>({outputs:[{dims:a?a(t):t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:y}),getShaderSource:x}},ME=(e,n,t,a)=>{let i=e.length>2,l=Tr(t[3]),u=Tr(t[2]),d=Be.size(t)/l/u,f=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/l],h=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/l],_=[t[0],t[1],t[2],t[3]/l],m=[{type:12,data:d},{type:6,data:[n.strides[0],n.strides[1]]},{type:6,data:[n.pads[0],n.pads[1]]}];Mc(n,m),m.push(...It(f,h,_));let p=(u-1)*n.strides[1]+h[1],y=v=>{let x=kt("output",e[0].dataType,_.length,l),L=ns(x.type.tensor),T=wc(n,x.type.value,L),E=qe("x",e[0].dataType,f.length,l),I=qe("w",e[1].dataType,h.length,l),P=[E,I];i&&P.push(qe("b",e[2].dataType,e[2].dims,l));let S=i?"value += b[output_channel];":"",k=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return xc(n,k),`
  ${v.registerUniforms(k).declareVariables(...P,x)}
  ${v.mainStart()}
    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${u}u;
    let col = (index1 % width1) * ${u}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${E.type.value}, ${p}>;
    var values: array<${x.type.value}, ${u}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${h[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${p}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${E.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${E.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${h[1]}; w_width++) {
          let w_val = ${I.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${u}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${u}u; i++) {
      var value = values[i];
      ${S}
      ${T}
      ${x.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${n.cacheKey};${l};${u};${p};${h[0]};${h[1]}`,inputDependencies:i?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:a?a(t):t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:m}),getShaderSource:y}}}),qw,n_,Qw,r_,py,u0,Xw,Yw,my,JO=ut(()=>{en(),XO(),YO(),tv(),ZO(),Sc(),ev(),ql(),qw=(e,n,t,a,i,l)=>{let u=e[0],d=e.slice(l?1:2,l?3:4),f=d.length,h=n[0],_=n.slice(2).map((p,y)=>p+(p-1)*(t[y]-1)),m=d.map((p,y)=>p+a[y]+a[y+f]).map((p,y)=>Math.floor((p-_[y]+i[y])/i[y]));return m.splice(0,0,u),m.splice(l?3:1,0,h),m},n_=[2,3,1,0],Qw=(e,n)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let t=e[0].dims[n.format==="NHWC"?e[0].dims.length-1:1],a=e[1].dims[1]*n.group;if(t!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let i=e[0].dims.length-2;if(n.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(n.strides.length!==i)throw new Error(`strides should be ${i}D`);if(n.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(n.kernelShape.length!==0&&n.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},r_=(e,n)=>{let t=e.kernelShape.slice();t.length<n[1].dims.length-2&&t.push(...Array(n[1].dims.length-2-t.length).fill(0));for(let l=2;l<n[1].dims.length;++l)t[l-2]===0&&(t[l-2]=n[1].dims[l]);let a=e.pads.slice();T_.adjustPadsBasedOnAutoPad(n[0].dims,e.strides,e.dilations,t,a,e.format==="NHWC",e.autoPad);let i=Object.assign({},e);return Object.assign(i,{kernelShape:t,pads:a}),i},py=e=>{let n=Yy(e),t=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],i=e.dilations,l=e.group,u=e.kernel_shape,d=e.pads,f=e.strides,h=e.w_is_const();return{autoPad:a,format:t,dilations:i,group:l,kernelShape:u,pads:d,strides:f,wIsConst:h,...n,cacheKey:`${e.format};${n.activation};`}},u0=(e,n,t,a)=>{let i=t.format==="NHWC",l=qw(n[0].dims,n[1].dims,t.dilations,t.pads,t.strides,i);if(t.group!==1){let k=[n[0]];if(i){let C=e.kernelCustomData.wT??e.compute(_a(n[1],n_),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=C),k.push(C)}else k.push(n[1]);n.length===3&&k.push(n[2]),!e.adapterInfo.isArchitecture("ampere")&&i&&n[1].dims[0]===t.group&&n[1].dims[1]===1&&t.dilations[0]===1&&t.dilations[1]===1?e.compute(ME(k,t,l,a),{inputs:k}):e.compute(wE(k,t,l,a),{inputs:k});return}let u=n.length===3,d=n[0].dims[i?1:2],f=n[0].dims[i?2:3],h=n[0].dims[i?3:1],_=n[1].dims[2],m=n[1].dims[3],p=l[i?1:2],y=l[i?2:3],v=l[i?3:1],x=i&&_===d&&m===f&&t.pads[0]===0&&t.pads[1]===0;if(x||_===1&&m===1&&t.dilations[0]===1&&t.dilations[1]===1&&t.strides[0]===1&&t.strides[1]===1&&t.pads[0]===0&&t.pads[1]===0){let k=l[0],C,D,V,U=[];if(i){let H=e.kernelCustomData.wT??e.compute(_a(n[1],n_),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];if(t.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=H),x){let oe=d*f*h;C=n[0].reshape([1,k,oe]),D=H.reshape([1,oe,v]),V=[1,k,v]}else C=n[0].reshape([k,d*f,h]),D=H.reshape([1,h,v]),V=[k,p*y,v];U.push(C),U.push(D)}else C=n[0].reshape([k,h,d*f]),D=n[1].reshape([1,v,h]),V=[k,v,p*y],U.push(D),U.push(C);u&&U.push(n[2]);let ne=V[2],ee=U[0].dims[U[0].dims.length-1];ne<8&&ee<8?e.compute(Jy(U,t,l,V,i,a),{inputs:U}):e.compute(S_(U,t,l,V,i,a),{inputs:U});return}let L=!0,T=e.kernelCustomData.wT??e.compute(_a(n[1],n_),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=T);let E=[n[0],T];u&&E.push(n[2]);let I=i?p*y:v,P=i?v:p*y,S=_*m*h;e.compute(yE(E,t,l,I,P,S,u,L,a),{inputs:E})},Xw=(e,n)=>{let t=n.format==="NHWC",a=[e.inputs[0].reshape(t?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&a.push(e.inputs[2]);let i=[0,n.pads[0],0,n.pads[1]],l=[1].concat(n.strides),u=[1].concat(n.dilations),d=[1].concat(n.kernelShape),f=r_({...n,pads:i,strides:l,dilations:u,kernelShape:d},a);u0(e,a,f,h=>t?[h[0],h[2],h[3]]:[h[0],h[1],h[3]])},Yw=(e,n,t)=>{let a=t.format==="NHWC"?"channelsLast":"channelsFirst",i=r_(t,n),l=t.autoPad==="NOTSET"?t.pads:t.autoPad,u=vE(n[0].dims,n[1].dims,t.strides,t.dilations,l,!1,a);e.compute(bE(n,i,u.outShape,[u.filterDepth,u.filterHeight,u.filterWidth],[u.padInfo.front,u.padInfo.top,u.padInfo.left],a))},my=(e,n)=>{if(Qw(e.inputs,n),e.inputs[0].dims.length===3)Xw(e,n);else if(e.inputs[0].dims.length===5)Yw(e,e.inputs,n);else{let t=r_(n,e.inputs);u0(e,e.inputs,t)}}}),xE,e$=ut(()=>{Bt(),qo(),en(),rn(),xE=(e,n,t)=>{let a=e.length>2,i=n.outputShape,l=n.format==="NHWC",u=n.group,d=e[1].dims,f=d[2]/u,h=d[3],_=l?Tr(f):1,m=l&&h===1&&f>=4,p=m?Math.floor(f/4)*4:Math.floor(f/_)*_,y=f-p,v=l?Tr(h):1,x=l?h===1?_:v:1,L=Be.size(i)/v,T=[Math.ceil(L/64),1,1];mn("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${T}`);let E=["rank","rank"],I=[n.strides[0],n.strides[1]],P=[n.kernelShape[l?1:2],n.kernelShape[l?2:3]],S=[n.dilations[0],n.dilations[1]],k=[P[0]+(n.dilations[0]<=1?0:(n.kernelShape[l?1:2]-1)*(n.dilations[0]-1)),P[1]+(n.dilations[1]<=1?0:(n.kernelShape[l?2:3]-1)*(n.dilations[1]-1))],C=[k[0]-1-Math.floor((n.pads[0]+n.pads[2])/2),k[1]-1-Math.floor((n.pads[1]+n.pads[3])/2)],D=[{type:12,data:L},{type:12,data:I},{type:12,data:P},{type:12,data:S},{type:12,data:k},{type:6,data:C},{type:12,data:p},{type:12,data:f},{type:12,data:h},...It(e[0].dims,e[1].dims)];a&&(D.push(...It(e[2].dims)),E.push("rank")),D.push(...It(i));let V=U=>{let ne=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:I.length},{name:"filter_dims",type:"u32",length:P.length},{name:"dilations",type:"u32",length:P.length},{name:"effective_filter_dims",type:"u32",length:k.length},{name:"pads",type:"i32",length:C.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],ee=ns(e[0].dataType),H=l?1:2,oe=l?2:3,ae=l?3:1,W=qe("W",e[1].dataType,e[1].dims.length,x),te=qe("Dy",e[0].dataType,e[0].dims.length,_),ie=[te,W];a&&ie.push(qe("bias",e[2].dataType,[i[ae]].length,v));let _e=kt("result",e[0].dataType,i.length,v),q=()=>{let Q="";if(m)_===4?Q+=`
        let xValue = ${te.getByOffset("x_offset")};
        let wValue = ${W.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`:_===2?Q+=`
          dotProd = dotProd + dot(vec4<${ee}>(${te.getByOffset("x_offset")}, ${te.getByOffset("x_offset + 1u")}), vec4<${ee}>(${W.getByOffset("w_offset")}, ${W.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`:_===1&&(Q+=`
          dotProd = dotProd + dot(vec4<${ee}>(${te.getByOffset("x_offset")}, ${te.getByOffset("x_offset + 1u")}, ${te.getByOffset("x_offset + 2u")}, ${te.getByOffset("x_offset + 3u")}), vec4<${ee}>(${W.getByOffset("w_offset")}, ${W.getByOffset("w_offset + 1u")}, ${W.getByOffset("w_offset + 2u")}, ${W.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);else if(Q+=`
                  let xValue = ${l?te.getByOffset(`${te.indicesToOffset(`${te.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${_}`):te.get("batch","inputChannel","idyR","idyC")};
        `,_===1)Q+=`
          let w_offset = ${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${W.getByOffset(`w_offset / ${x}`)};
          dotProd = dotProd + xValue * wValue;`;else for(let G=0;G<_;G++)Q+=`
            let wValue${G} = ${W.getByOffset(`${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${G}, wOutChannel)`)} / ${x}`)};
            dotProd = dotProd + xValue[${G}] * wValue${G};`;return Q},B=()=>{if(y===0)return"";if(!m)throw new Error(`packInputAs4 ${m} is not true.`);let Q="";if(_===1){Q+="dotProd = dotProd";for(let G=0;G<y;G++)Q+=`
            + ${te.getByOffset(`x_offset + ${G}`)} * ${W.getByOffset(`w_offset + ${G}`)}`;Q+=";"}else if(_===2){if(y!==2)throw new Error(`Invalid inputChannelsRemainder ${y}.`);Q+=`
          let xValue = ${te.getByOffset("x_offset")};
          let wValue = ${W.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`}return Q},R=`
            let outputIndices = ${_e.offsetToIndices(`global_idx * ${v}`)};
            let batch = ${_e.indicesGet("outputIndices",0)};
            let d1 = ${_e.indicesGet("outputIndices",ae)};
            let r = ${_e.indicesGet("outputIndices",H)};
            let c = ${_e.indicesGet("outputIndices",oe)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${_e.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${ee}(dyRCorner) + ${ee}(wR)) / ${ee}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${ee}(uniforms.Dy_shape[${H}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${ee}(dyCCorner) + ${ee}(wC)) / ${ee}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${ee}(uniforms.Dy_shape[${oe}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${m?`
                var x_offset = ${te.indicesToOffset(`${te.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${_};
                var w_offset = ${W.indicesToOffset(`${W.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${x};
                  `:""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${m?4:_}) {
                  ${q()}
                  inputChannel = inputChannel + ${m?4:_};
                }
                ${B()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${a?` + bias[d1 / ${v}]`:""};
            ${_e.setByOffset("global_idx","value")};
          `;return`
    ${U.registerUniforms(ne).declareVariables(...ie,_e)}
      ${U.mainStart()}
      ${U.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${R}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${n.cacheKey};${_}${x}${v}${m}${y}`,inputDependencies:E},getRunData:()=>({dispatchGroup:{x:T[0],y:T[1],z:T[2]},outputs:[{dims:t?t(i):i,dataType:e[0].dataType}],programUniforms:D}),getShaderSource:V}}}),Zw,Jw,eM,c0,TE,tM,d0,nM,EE,t$=ut(()=>{e$(),Sc(),ql(),Zw=(e,n,t,a,i,l)=>(e-1)*n+t+(a-1)*i+1-l,Jw=(e,n,t,a,i)=>{let l=Math.floor(e/2);n==="SAME_UPPER"?(t[a]=l,t[i]=e-l):n==="SAME_LOWER"&&(t[a]=e-l,t[i]=l)},eM=(e,n,t,a,i,l,u,d,f,h)=>{let _=e.length-2,m=h.length===0;f.length<_&&f.push(...Array(_-f.length).fill(0));let p=e[0],y=n[d?3:1]*i;for(let v=0,x=e.length-_-(d?1:0);v<_;++v,++x){let L=e[x],T=m?L*u[v]:h[v],E=Zw(L,u[v],l[v],n[x],t[v],T);Jw(E,a,l,v,v+_),m&&h.push(u[v]*(L-1)+f[v]+(n[x]-1)*t[v]+1-l[v]-l[v+_])}h.splice(0,0,p),h.splice(d?3:1,0,y)},c0=(e,n)=>{let t=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((m,p)=>m*p,1)===0){t.length=0;for(let m=2;m<n[1].dims.length;++m)t.push(n[1].dims[m])}let a=e.format==="NHWC";t.splice(0,0,n[1].dims[0]),t.splice(a?3:1,0,n[1].dims[1]);let i=e.pads.slice(),l=e.outputShape.slice(),u=e.outputPadding.slice(),d=n[0].dims,f=e.dilations.slice();if(f.reduce((m,p)=>m+p,0)===0){let m=n[0].dims.length-2;f=new Array(m).fill(1)}let h=e.strides.slice();if(h.reduce((m,p)=>m+p,0)===0){let m=n[0].dims.length-2;h=new Array(m).fill(1)}eM(d,t,f,e.autoPad,e.group,i,h,a,u,l);let _=Object.assign({},e);return Object.assign(_,{kernelShape:t,pads:i,outputPadding:u,outputShape:l,dilations:f,strides:h}),_},TE=e=>{let n=Yy(e),t=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],i=e.dilations,l=e.group,u=e.kernelShape,d=e.pads,f=e.strides,h=e.wIsConst(),_=e.outputPadding,m=e.outputShape;return{autoPad:a,format:t,dilations:i,group:l,kernelShape:u,outputPadding:_,outputShape:m,pads:d,strides:f,wIsConst:h,...n,cacheKey:`${e.format};${n.activation};`}},tM=(e,n)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let t=e[0].dims[n.format==="NHWC"?e[0].dims.length-1:1],a=e[1].dims[0];if(t!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=e[1].dims[1]*n.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==i))throw new Error("invalid bias");let l=e[0].dims.length-2;if(n.dilations.reduce((u,d)=>u+d,0)>0&&n.dilations.length!==l)throw new Error(`dilations should be ${l}D`);if(n.strides.reduce((u,d)=>u+d,0)>0&&n.strides.length!==l)throw new Error(`strides should be ${l}D`);if(n.pads.reduce((u,d)=>u+d,0)>0&&n.pads.length!==l*2)throw new Error(`pads should be ${l*2}D`);if(n.outputPadding.length!==l&&n.outputPadding.length!==0)throw new Error(`output_padding should be ${l}D`);if(n.kernelShape.reduce((u,d)=>u+d,0)>0&&n.kernelShape.length!==0&&n.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(n.outputShape.length!==0&&n.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},d0=(e,n,t,a)=>{let i=e.kernelCustomData.wT??e.compute(_a(n[1],[2,3,0,1]),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=i);let l=[n[0],i];n.length===3&&l.push(n[2]),e.compute(xE(l,t,a),{inputs:l})},nM=(e,n)=>{let t=n.format==="NHWC",a=[e.inputs[0].reshape(t?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&a.push(e.inputs[2]);let i=n.kernelShape;(i.length===0||i[0]===0)&&(i=[e.inputs[1].dims[2]]);let l=n.dilations;(l.length===0||l[0]===0)&&(l=[1]);let u=n.strides;(u.length===0||u[0]===0)&&(u=[1]);let d=n.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],u=[1].concat(u),l=[1].concat(l),i=[1].concat(i);let f=n.outputPadding;f=[0].concat(f);let h=c0({...n,pads:d,strides:u,dilations:l,kernelShape:i,outputPadding:f},a);d0(e,a,h,_=>t?[_[0],_[2],_[3]]:[_[0],_[1],_[3]])},EE=(e,n)=>{if(tM(e.inputs,n),e.inputs[0].dims.length===3)nM(e,n);else{let t=c0(n,e.inputs);d0(e,e.inputs,t)}}}),rM,SE,CE,n$=ut(()=>{Bt(),en(),kr(),rn(),rM=(e,n,t,a)=>{let i=Be.size(n),l=n.length,u=qe("input",e,l),d=kt("output",e,l),f=t.dataType===6?t.getInt32Array()[0]:Number(t.getBigInt64Array()[0]),h=Be.normalizeAxis(f,l),_=m=>{let p=` i32(${u.indicesGet("inputIndices","uniforms.axis")}) `,y=Ot("uniforms.input_shape","uniforms.axis",l),v=a.reverse?p+(a.exclusive?" + 1":""):"0",x=a.reverse?y:p+(a.exclusive?"":" + 1");return`
                ${m.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(u,d)}
                ${m.mainStart()}
                  ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${d.offsetToIndices("global_idx")};
                  var sum = ${d.type.value}(0);
                  let first : i32 = ${v};
                  let last : i32 = ${x};
                  for (var i : i32 = first; i < last; i++) {
                    ${u.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${u.getByIndices("inputIndices")};
                  }
                  ${d.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:a.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:n,dataType:e}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},{type:12,data:h},...It(n,n)]}),getShaderSource:_}},SE=(e,n)=>{let t=e.inputs[0].dims,a=e.inputs[0].dataType,i=e.inputs[1];e.compute(rM(a,t,i,n),{inputs:[0]})},CE=e=>{let n=e.exclusive===1,t=e.reverse===1;return kn({exclusive:n,reverse:t})}}),sM,aM,iM,PE,AE,r$=ut(()=>{Bt(),en(),kr(),rn(),sM=e=>{if(!e||e.length!==1)throw new Error("DepthToSpace requires 1 input.");if(e[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},aM=(e,n,t,a)=>{let i=[];i.push(`fn perm(i: ${a.type.indices}) -> ${t.type.indices} {
    var a: ${t.type.indices};`);for(let l=0;l<n;++l)i.push(t.indicesSet("a",e[l],`i[${l}]`));return i.push("return a;}"),i.join(`
`)},iM=(e,n)=>{let t,a,i,l,u,d,f=n.format==="NHWC",h=n.blocksize,_=n.mode==="DCR";f?([t,a,i,l]=e.dims,u=_?[t,a,i,h,h,l/h**2]:[t,a,i,l/h**2,h,h],d=_?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([t,a,i,l]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],u=_?[t,h,h,l/h**2,a,i]:[t,l/h**2,h,h,a,i],d=_?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let m=e.reshape(u),p=m.dims.length,y=e.dataType,v=qe("a",y,p),x=kt("output",y,p),L=T=>`
  ${T.registerUniform("output_size","u32").declareVariables(v,x)}

  ${aM(d,p,v,x)}

  ${T.mainStart()}
    ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${x.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${x.setByOffset("global_idx",v.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${n.blocksize};${n.mode}`,inputDependencies:["rank"]},getRunData:T=>{let E=f?[t,a*h,i*h,l/h**2]:[t,l/h**2,a*h,i*h],I=Be.size(E),P=m.dims,S=Be.sortBasedOnPerm(P,d);return{outputs:[{dims:E,dataType:T[0].dataType}],dispatchGroup:{x:Math.ceil(I/64)},programUniforms:[{type:12,data:I},...It(P,S)]}},getShaderSource:L}},PE=(e,n)=>{sM(e.inputs),e.compute(iM(e.inputs[0],n))},AE=e=>kn({blocksize:e.blocksize,mode:e.mode,format:e.format})}),s_,Mp,f0,oM,lM,uM,cM,h0,dM,kE,OE,s$=ut(()=>{Bt(),en(),kr(),rn(),s_="[a-zA-Z]|\\.\\.\\.",Mp="("+s_+")+",f0="^"+Mp+"$",oM="("+Mp+",)*"+Mp,lM="^"+oM+"$",uM=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,n){let t=this.symbolToIndices.get(e);t===void 0?t=[n]:t.push(n),this.symbolToIndices.set(e,t)}},cM=class{constructor(e,n){this.equation=n,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[t,a]=n.includes("->")?n.split("->",2):[n,""];if(!t.match(RegExp(lM)))throw new Error("Invalid LHS term");if(t.split(",").forEach((i,l)=>{let u=e[l].dims.slice();if(!i.match(RegExp(f0)))throw new Error("Invalid LHS term");let d=this.processTerm(i,!0,u,l);this.lhs.push(d)}),a==="")a+=[...this.symbolToInfo.entries()].filter(([i,l])=>l.count===1||i==="...").map(([i])=>i).join("");else if(!a.match(RegExp(Mp)))throw new Error("Invalid RHS");a.match(RegExp(s_,"g"))?.forEach(i=>{if(i==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let l=this.symbolToInfo.get(i);if(l===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(l.dimValue)}}),this.rhs=this.processTerm(a,!1,this.outputDims)}addSymbol(e,n,t){let a=this.symbolToInfo.get(e);if(a!==void 0){if(a.dimValue!==n&&a.count!==1)throw new Error("Dimension mismatch");a.count++,a.inputIndices.push(t)}else a={count:1,dimValue:n,inputIndices:[t]};this.symbolToInfo.set(e,a)}processTerm(e,n,t,a=-1){let i=t.length,l=!1,u=[],d=0;if(!e.match(RegExp(f0))&&!n&&e!=="")throw new Error("Invalid LHS term");let f=e.match(RegExp(s_,"g")),h=new uM(a);return f?.forEach((_,m)=>{if(_==="..."){if(l)throw new Error("Only one ellipsis is allowed per input term");l=!0;let p=i-f.length+1;if(p<0)throw new Error("Ellipsis out of bounds");if(u=t.slice(d,d+p),this.hasEllipsis){if(this.ellipsisDims.length!==u.length||this.ellipsisDims.toString()!==u.toString())throw new Error("Ellipsis dimensions mismatch")}else if(n)this.hasEllipsis=!0,this.ellipsisDims=u;else throw new Error("Ellipsis must be specified in the LHS");for(let y=0;y<u.length;y++){let v=String.fromCharCode(48+y);h.addSymbol(v,m+y),this.addSymbol(v,t[d++],a)}}else h.addSymbol(_,m+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(_,t[d++],a)}),h}},h0=e=>e+"_max",dM=(e,n,t,a)=>{let i=e.map(h=>h.length).map((h,_)=>qe(`input${_}`,n,h)),l=Be.size(a),u=kt("output",n,a.length),d=[...t.symbolToInfo.keys()].filter(h=>!t.rhs.symbolToIndices.has(h)),f=h=>{let _=[],m="var prod = 1.0;",p="var sum = 0.0;",y="sum += prod;",v=[],x=[],L=[],T=[],E=t.symbolToInfo.size===t.rhs.symbolToIndices.size;t.symbolToInfo.forEach((P,S)=>{if(t.rhs.symbolToIndices.has(S)){let k=t.rhs.symbolToIndices.get(S)?.[0];k!==void 0&&t.lhs.forEach((C,D)=>{if(P.inputIndices.includes(D)){let V=C.symbolToIndices.get(S);if(V===void 0)throw new Error("Invalid symbol error");V.forEach(U=>{_.push(`${i[D].indicesSet(`input${D}Indices`,U,u.indicesGet("outputIndices",k))}`)})}})}else t.lhs.forEach((k,C)=>{if(P.inputIndices.includes(C)){let D=k.symbolToIndices.get(S);if(D===void 0)throw new Error("Invalid symbol error");D.forEach(V=>{v.push(`${i[C].indicesSet(`input${C}Indices`,V,`${S}`)}`)}),T.push(`prod *= ${i[C].getByIndices(`input${C}Indices`)};`)}}),x.push(`for(var ${S}: u32 = 0; ${S} < uniforms.${h0(S)}; ${S}++) {`),L.push("}")});let I=E?[..._,`let sum = ${i.map((P,S)=>P.getByIndices(`input${S}Indices`)).join(" * ")};`]:[..._,p,...x,...v,m,...T,y,...L];return`
            ${h.registerUniforms(d.map(P=>({name:`${h0(P)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...i,u)}

            ${h.mainStart()}
            ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${u.offsetToIndices("global_idx")};
            ${i.map((P,S)=>`var input${S}Indices: ${i[S].type.indices};`).join(`
`)}
            ${I.join(`
`)};
            ${u.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:t.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let h=d.filter(m=>t.symbolToInfo.has(m)).map(m=>({type:12,data:t.symbolToInfo.get(m)?.dimValue||0}));h.push({type:12,data:l});let _=e.map((m,p)=>[...It(m)]).reduce((m,p)=>m.concat(p),h);return _.push(...It(a)),{outputs:[{dims:a,dataType:n}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:_}},getShaderSource:f}},kE=(e,n)=>{let t=new cM(e.inputs,n.equation),a=t.outputDims,i=e.inputs.map((l,u)=>l.dims);e.compute(dM(i,e.inputs[0].dataType,t,a))},OE=e=>{let n=e.equation.replace(/\s+/g,"");return kn({equation:n})}}),fM,p0,hM,pM,$E,a$=ut(()=>{Bt(),en(),rn(),fM=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let n=e[0].dims,t=Array.from(e[1].getBigInt64Array(),Number),a=t.length<n.length?0:t.length-n.length,i=n.length<t.length?0:n.length-t.length;for(;a<t.length&&i<n.length;++a,++i)if(t[a]!==n[i]&&t[a]!==1&&n[i]!==1)throw new Error("Expand requires shape to be broadcastable to input")},p0=(e,n)=>{let t=e.length-n.length,a=[];for(let i=0;i<t;++i)a.push(e[i]);for(let i=0;i<n.length;++i)a.push(n[i]===1?e[i+t]:n[i]);return a},hM=(e,n)=>e.length>n.length?p0(e,n):p0(n,e),pM=e=>{let n=e[0].dims,t=Array.from(e[1].getBigInt64Array(),Number),a=hM(n,t),i=e[0].dataType,l=i===9||Be.size(n)===1,u=i===9||n.length>0&&n[n.length-1]%4===0?4:1,d=l||a.length>0&&a[a.length-1]%4===0?4:1,f=Math.ceil(Be.size(a)/d),h=m=>{let p=qe("input",i,n.length,u),y=kt("output",i,a.length,d),v;if(i===9){let x=(L,T,E="")=>`
          let outputIndices${T} = ${y.offsetToIndices(`outputOffset + ${T}u`)};
          let offset${T} = ${p.broadcastedIndicesToOffset(`outputIndices${T}`,y)};
          let index${T} = offset${T} / 4u;
          let component${T} = offset${T} % 4u;
          ${L}[${T}] = ${E}(${p.getByOffset(`index${T}`)}[component${T}]);
        `;v=`
        let outputOffset = global_idx * ${d};
        var data = vec4<u32>(0);
        ${x("data",0,"u32")}
        ${x("data",1,"u32")}
        ${x("data",2,"u32")}
        ${x("data",3,"u32")}
        ${y.setByOffset("global_idx","data")}
      }`}else v=`
        let outputIndices = ${y.offsetToIndices(`global_idx * ${d}`)};
        let inputOffset = ${p.broadcastedIndicesToOffset("outputIndices",y)};
        let data = ${y.type.value}(${p.getByOffset(`inputOffset / ${u}`)});
        ${y.setByOffset("global_idx","data")}
      }`;return`
    ${m.registerUniform("vec_size","u32").declareVariables(p,y)}
    ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${v}`},_=[{type:12,data:f},...It(n,a)];return{name:"Expand",shaderCache:{hint:`${a.length};${u}${d}`,inputDependencies:["rank"]},getShaderSource:h,getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:_})}},$E=e=>{fM(e.inputs),e.compute(pM(e.inputs),{inputs:[0]})}}),mM,DE,i$=ut(()=>{Bt(),en(),rn(),Xy(),mM=e=>{let n=e[0].dataType,t=Be.size(e[0].dims),a=Be.size(e[1].dims),i=a%4===0,l=u=>{let d=qe("x",n,[1],4),f=qe("bias",n,[1],4),h=kt("y",n,[1],4),_=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],m=y=>`
      let bias${y}_offset: u32 = (global_idx * 4 + ${y}) % uniforms.bias_size;
      let bias${y} = ${f.getByOffset(`bias${y}_offset / 4`)}[bias${y}_offset % 4];`,p=i?`
      let bias = ${f.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${m(0)}${m(1)}${m(2)}${m(3)}
      let bias = ${d.type.value}(bias0, bias1, bias2, bias3);`;return`${u.registerUniforms(_).declareVariables(d,f,h)}

    ${cy(xs(n))}

    ${u.mainStart(lf)}
      ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${d.getByOffset("global_idx")};
      ${p}
      let x_in = x + bias;
      ${h.setByOffset("global_idx",dy("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${i}`,inputDependencies:["type","type"]},getShaderSource:l,getRunData:u=>({outputs:[{dims:u[0].dims,dataType:u[0].dataType}],programUniforms:[{type:12,data:Math.ceil(t/4)},{type:12,data:a}],dispatchGroup:{x:Math.ceil(t/lf/4)}})}},DE=e=>{e.inputs.length<2||Be.size(e.inputs[1].dims)===0?JT(e):e.compute(mM(e.inputs))}}),_M,gM,IE,LE,o$=ut(()=>{Bt(),en(),kr(),rn(),_M=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},gM=(e,n)=>{let t=e[0].dims,a=e[1].dims,i=t.length,l=Be.normalizeAxis(n.axis,i),u=t.slice(0);u.splice(l,1,...a);let d=t[l],f=e[0].dataType===9?4:1,h=Math.ceil(Be.size(u)/f),_=[{type:12,data:h},{type:6,data:d},{type:12,data:l},...It(e[0].dims,e[1].dims,u)],m=p=>{let y=qe("data",e[0].dataType,e[0].dims.length,f),v=qe("inputIndices",e[1].dataType,e[1].dims.length),x=kt("output",e[0].dataType,u.length,f),L=E=>{let I=a.length,P=`var indicesIndices${E}  = ${v.type.indices}(0);`;for(let S=0;S<I;S++)P+=`${I>1?`indicesIndices${E}[${S}]`:`indicesIndices${E}`} = ${u.length>1?`outputIndices${E}[uniforms.axis + ${S}]`:`outputIndices${E}`};`;P+=`
          var idx${E} = ${v.getByIndices(`indicesIndices${E}`)};
          if (idx${E} < 0) {
            idx${E} = idx${E} + uniforms.axisDimLimit;
          }
          var dataIndices${E} : ${y.type.indices};
        `;for(let S=0,k=0;S<i;S++)S===l?(P+=`${i>1?`dataIndices${E}[${S}]`:`dataIndices${E}`} = u32(idx${E});`,k+=I):(P+=`${i>1?`dataIndices${E}[${S}]`:`dataIndices${E}`} = ${u.length>1?`outputIndices${E}[${k}]`:`outputIndices${E}`};`,k++);return P},T;if(e[0].dataType===9){let E=(I,P,S="")=>`
          let outputIndices${P} = ${x.offsetToIndices(`outputOffset + ${P}u`)};
          ${L(P)};
          let offset${P} = ${y.indicesToOffset(`dataIndices${P}`)};
          let index${P} = offset${P} / 4u;
          let component${P} = offset${P} % 4u;
          ${I}[${P}] = ${S}(${y.getByOffset(`index${P}`)}[component${P}]);
        `;T=`
        let outputOffset = global_idx * ${f};
        var value = vec4<u32>(0);
        ${E("value",0,"u32")}
        ${E("value",1,"u32")}
        ${E("value",2,"u32")}
        ${E("value",3,"u32")}
        ${x.setByOffset("global_idx","value")}
      `}else T=`
      let outputIndices = ${x.offsetToIndices("global_idx")};
      ${L("")};
      let value = ${y.getByIndices("dataIndices")};
      ${x.setByOffset("global_idx","value")};
      `;return`
      ${p.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(y,v,x)}
      ${p.mainStart()}
        ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${T}
      }`};return{name:"Gather",shaderCache:{hint:n.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:_}),getShaderSource:m}},IE=e=>kn({axis:e.axis}),LE=(e,n)=>{let t=e.inputs;_M(t),e.compute(gM(e.inputs,n))}}),yM,zE,FE,l$=ut(()=>{Bt(),en(),rn(),yM=(e,n,t,a,i,l,u,d,f)=>{let h=[{type:12,data:l},{type:12,data:a},{type:12,data:i},{type:12,data:t},{type:12,data:u},{type:12,data:d},{type:12,data:f}],_=[l];h.push(...It(n.dims,_));let m=p=>{let y=qe("indices_data",n.dataType,n.dims.length),v=kt("input_slice_offsets_data",12,1,1),x=[y,v],L=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:i.length},{name:"sizes_from_slice_dims_data",type:"u32",length:t.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${p.registerUniforms(L).declareVariables(...x)}
  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${i.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${t.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${i.length}_${t.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:_,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:h}),getShaderSource:m},{inputs:[n],outputs:[-1]})[0]},zE=(e,n)=>{let t=e.inputs,a=t[0].dims,i=t[0].dataType,l=t[1].dims,u=l[l.length-1],d=Be.sizeToDimension(l,l.length-1),f=Be.sizeFromDimension(a,n.batchDims+u),h=Be.sizeToDimension(a,n.batchDims),_=Be.sizeFromDimension(a,n.batchDims),m=d/h,p=new Array(u),y=f;for(let P=0;P<u;++P)p[u-1-P]=y,y*=a[n.batchDims+u-1-P];let v=yM(e,t[1],p,n.batchDims,a,d,m,_,u),x=n.batchDims+u;if(x>a.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let L=l.slice(0,-1).concat(a.slice(x)),T=Be.size(L),E=[{type:12,data:T},{type:12,data:f},...It(t[0].dims,v.dims,L)],I=P=>{let S=qe("data",t[0].dataType,t[0].dims.length),k=qe("slice_offsets",12,v.dims.length),C=kt("output",t[0].dataType,L.length);return`
          ${P.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(S,k,C)}
            ${P.mainStart()}
            ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};e.compute({name:"GatherND",shaderCache:{hint:n.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:L,dataType:i}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:E}),getShaderSource:I},{inputs:[t[0],v]})},FE=e=>({batchDims:e.batch_dims,cacheKey:""})}),vM,bM,RE,BE,u$=ut(()=>{Bt(),en(),kr(),rn(),vM=(e,n)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let t=Be.normalizeAxis(n.quantizeAxis,e[0].dims.length),a=n.blockSize,i=e[0],l=e[2],u=e.length===4?e[3]:void 0;if(l.dims.length!==i.dims.length||!i.dims.map((d,f)=>f===t?Math.ceil(d/a)===l.dims[f]:d===l.dims[f]).reduce((d,f)=>d&&f,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(u){if(u.dataType!==i.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(u.dims.length!==l.dims.length||!u.dims.map((d,f)=>d===l.dims[f]).reduce((d,f)=>d&&f,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},bM=(e,n)=>{let t=e[0].dims,a=e[1].dims,i=t.length,l=Be.normalizeAxis(n.gatherAxis,i),u=Be.normalizeAxis(n.quantizeAxis,i),d=t.slice(0);d.splice(l,1,...a);let f=Be.size(d),h=e[2].dataType,_=e[0].dataType===22,m=[{type:12,data:f},{type:12,data:u},{type:12,data:l},{type:12,data:n.blockSize},...It(...e.map((y,v)=>y.dims),d)],p=y=>{let v=qe("data",e[0].dataType,e[0].dims.length),x=qe("inputIndices",e[1].dataType,e[1].dims.length),L=qe("scales",e[2].dataType,e[2].dims.length),T=e.length>3?qe("zeroPoint",e[3].dataType,e[3].dims.length):void 0,E=kt("output",h,d.length),I=[v,x,L];T&&I.push(T);let P=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${y.registerUniforms(P).declareVariables(...I,E)}
        ${y.mainStart()}
        let output_indices = ${E.offsetToIndices("global_idx")};
        var indices_indices = ${x.type.indices}(0);
        ${a.length>1?`
          for (var i: u32 = 0; i < ${a.length}; i++) {
            let index = ${E.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${x.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${E.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${v.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${E.indicesGet("output_indices","i")};
          ${v.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${x.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${t[l]};
        }
        ${v.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${d.length}; i++) {
          let index = ${E.indicesGet("output_indices",`i + ${a.length} - 1`)};
          ${v.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${v.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${v.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${_?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${L.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${L.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${L.getByIndices("scale_indices")};
        ${T?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${T.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${T.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${_?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${xs(h)}(quantized_data - zero_point) * scale;
        ${E.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${n.cacheKey};${e.filter((y,v)=>v!==1).map(y=>y.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:e.length},(y,v)=>"rank")},getRunData:()=>({outputs:[{dims:d,dataType:h}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:m}),getShaderSource:p}},RE=(e,n)=>{let t=e.inputs;vM(t,n),e.compute(bM(e.inputs,n))},BE=e=>kn({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})}),wM,MM,jE,NE,c$=ut(()=>{Bt(),en(),kr(),rn(),wM=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},MM=(e,n)=>{let t=e[0].dims,a=e[0].dataType,i=t.length,l=e[1].dims,u=e[1].dataType,d=Be.normalizeAxis(n.axis,i),f=t[d],h=l.slice(0),_=Be.size(h),m=qe("input",a,i),p=qe("indicesInput",u,l.length),y=kt("output",a,h.length),v=[{type:12,data:_},{type:6,data:f},{type:12,data:d}];return v.push(...It(t,l,h)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:v}),getShaderSource:x=>`
      ${x.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(m,p,y)}
      ${x.mainStart()}
      ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${y.offsetToIndices("global_idx")};

      var idx = ${p.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${m.type.indices}(outputIndices);
      ${m.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${m.getByIndices("inputIndices")};

      ${y.setByOffset("global_idx","value")};
  }`}},jE=e=>kn({axis:e.axis}),NE=(e,n)=>{let t=e.inputs;wM(t),e.compute(MM(e.inputs,n))}}),xM,TM,UE,VE,d$=ut(()=>{Bt(),en(),rn(),xM=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},TM=(e,n)=>{let t=e[0].dims.slice(),a=e[1].dims.slice(),[i,l,u]=jx.getShapeOfGemmResult(t,n.transA,a,n.transB,e.length===3?e[2].dims:void 0),d=[i,l];if(!d)throw new Error("Can't use gemm on the given tensors");let f=16,h=Math.ceil(l/f),_=Math.ceil(i/f),m=!0,p=Be.size(d),y=[{type:12,data:m?h:p},{type:12,data:i},{type:12,data:l},{type:12,data:u},{type:1,data:n.alpha},{type:1,data:n.beta}],v=["type","type"];e.length===3&&(y.push(...It(e[2].dims)),v.push("rank")),y.push(...It(d));let x=T=>{let E="";n.transA&&n.transB?E="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":n.transA&&!n.transB?E="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!n.transA&&n.transB?E="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!n.transA&&!n.transB&&(E="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let I=n.alpha===1?"":"value *= uniforms.alpha;",P=qe("a",e[0].dataType,e[0].dims),S=qe("b",e[1].dataType,e[1].dims),k=P.type.value,C=null,D=[P,S];e.length===3&&(C=qe("c",e[2].dataType,e[2].dims.length),D.push(C));let V=kt("output",e[0].dataType,d.length);D.push(V);let U=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${T.registerUniforms(U).declareVariables(...D)}

  ${T.mainStart()}
    ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${k}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${E}
    }

    ${I}
    ${C!=null?`let cOffset = ${C.broadcastedIndicesToOffset("vec2(m, n)",V)}; value += ${k}(uniforms.beta) * ${C.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},L=T=>{let E=qe("a",e[0].dataType,e[0].dims),I=qe("b",e[1].dataType,e[1].dims),P=null,S=[E,I];e.length===3&&(P=qe("c",e[2].dataType,e[2].dims.length),S.push(P));let k=kt("output",e[0].dataType,d.length);S.push(k);let C=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],D="",V="";n.transA&&n.transB?(V=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${E.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${I.type.value}(0);
      }
      `,D="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):n.transA&&!n.transB?(V=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${E.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${I.type.value}(0);
      }
      `,D="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!n.transA&&n.transB?(V=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${E.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${I.type.value}(0);
      }
      `,D="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!n.transA&&!n.transB&&(V=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${E.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${I.type.value}(0);
      }
      `,D="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let U=n.alpha===1?"":"value *= uniforms.alpha;";return`
  ${T.registerUniforms(C).declareVariables(...S)}
  var<workgroup> tile_a: array<array<${E.type.storage}, ${f}>, ${f}>;
  var<workgroup> tile_b: array<array<${I.type.storage}, ${f}>, ${f}>;
  ${T.mainStart([f,f,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${f};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${f};
    let num_tiles = (uniforms.K - 1) / ${f} + 1;
    var k_start = 0u;
    var value = ${k.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${V}
      k_start = k_start + ${f};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${f}; k++) {
        ${D}
      }
      workgroupBarrier();
    }

    ${U}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${P!=null?`let cOffset = ${P.broadcastedIndicesToOffset("vec2(m, n)",k)}; value += ${k.type.value}(uniforms.beta) * ${P.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return m?{name:"GemmShared",shaderCache:{hint:`${n.cacheKey}`,inputDependencies:v},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:h*_},programUniforms:y}),getShaderSource:L}:{name:"Gemm",shaderCache:{hint:`${n.cacheKey}`,inputDependencies:v},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:y}),getShaderSource:x}},UE=e=>{let n=e.transA,t=e.transB,a=e.alpha,i=e.beta;return{transA:n,transB:t,alpha:a,beta:i,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},VE=(e,n)=>{xM(e.inputs),e.compute(TM(e.inputs,n))}}),Ji,No,hc,pc,EM,SM,CM,PM,AM,kM,OM,$M,GE,WE,f$=ut(()=>{Bt(),en(),kr(),rn(),[Ji,No,hc,pc]=[0,1,2,3],EM=e=>{if(e[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${e[0].dims.length-2}`);if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},SM=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,CM=e=>`
  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,PM=e=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${e.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,AM=e=>`
  ${e.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,kM=(e,n,t)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${n} {
     var pixel = ${n}(0);
     var indices = vec4<u32>(0);
     indices[${Ji}] = batch;
     indices[${No}] = channel;`+(()=>{switch(t.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${hc}] = u32(r);
            indices[${pc}] = u32(c);
          } else {
            return ${n}(0);
          }
        `;case"border":return`
          indices[${hc}] = u32(clamp(r, 0, H - 1));
          indices[${pc}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${hc}] = gs_reflect(r, border[1], border[3]);
          indices[${pc}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${t.paddingMode} is not supported`)}})()+`
    return ${e.getByIndices("indices")};
  }
`,OM=(e,n,t)=>(()=>{switch(t.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${Ji}], indices[${No}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${Ji}], indices[${No}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${Ji}], indices[${No}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${Ji}], indices[${No}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${Ji}], indices[${No}], border);

          let dx2 = ${n}(f32(x2) - x);
          let dx1 = ${n}(x - f32(x1));
          let dy2 = ${n}(f32(y2) - y);
          let dy1 = ${n}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${n}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${Ji}], indices[${No}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${t.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,$M=(e,n)=>{let t=qe("x",e[0].dataType,e[0].dims.length),a=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],i=qe("grid",e[1].dataType,a.length,2),l=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];n.format==="NHWC"&&(l=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[Ji,No,hc,pc]=[0,3,1,2]);let u=kt("output",e[0].dataType,l.length),d=t.type.value,f=Be.size(l),h=[{type:12,data:f},...It(e[0].dims,a,l)],_=m=>`
  ${m.registerUniform("output_size","u32").declareVariables(t,i,u)}
  ${SM}
  ${CM(d)}
  ${PM(n)}
  ${AM(n)}
  ${kM(t,d,n)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${hc}]);
      let W_in = i32(uniforms.x_shape[${pc}]);

      ${n.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${u.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${Ji}], indices[${hc}], indices[${pc}]);
      let nxy = ${i.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${OM(u,d,n)}
  }`;return{name:"GridSample",shaderCache:{hint:`${n.cacheKey}`,inputDependencies:["type","type"]},getRunData:m=>{let p=Be.size(l);return{outputs:[{dims:l,dataType:m[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h}},getShaderSource:_}},GE=(e,n)=>{EM(e.inputs),e.compute($M(e.inputs,n))},WE=e=>kn({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})}),Bs,DM,HE,m0,IM,Op,KE,qE=ut(()=>{Bt(),en(),kr(),Hy(),Qy(),rn(),ql(),Bs=(e,n)=>e.length>n&&e[n].dims.length>0?e[n]:void 0,DM=(e,n)=>{let t=e[0],a=Bs(e,1),i=Bs(e,2),l=Bs(e,3),u=Bs(e,4),d=Bs(e,5),f=Bs(e,6),h=Bs(e,7);if(t.dims.length!==3&&t.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let _=t.dims[0],m=t.dims[1],p=t.dims.length===3?t.dims[2]:n.numHeads*t.dims[4],y=m,v=0,x=0,L=Math.floor(p/n.numHeads);if(f&&h&&Be.size(f.dims)&&Be.size(h.dims)){if(f.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(f.dims[0]!==_||f.dims[1]!==n.numHeads||f.dims[3]!==L)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(h.dims[0]!==_||h.dims[1]!==n.numHeads||h.dims[3]!==L)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(f.dims[2]!==h.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(h.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');v=f.dims[2],x=f.dims[2]}else if(f&&Be.size(f.dims)||h&&Be.size(h.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let T;if(a&&Be.size(a.dims)>0){if(t.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(a.dims.length<3||a.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(t.dims[0]!==a.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(a.dims.length===3){if(a.dims[2]!==t.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');T=2,y=a.dims[1]}else if(a.dims.length===5){if(a.dims[2]!==n.numHeads||a.dims[3]!==2||a.dims[4]!==L)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(i)throw new Error('Expect "value" be none when "key" has packed kv format.');T=5,y=a.dims[1]}else{if(a.dims[1]!==n.numHeads||a.dims[3]!==L)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');T=0,y=a.dims[2]}}else{if(t.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(t.dims[2]!==n.numHeads||t.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');T=3}if(l&&Be.size(l.dims)>0){if(l.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(a&&a.dims.length===5&&a.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let E=v+y,I=0;if(u&&Be.size(u.dims)>0){I=8;let C=u.dims;throw C.length===1?C[0]===_?I=1:C[0]===3*_+2&&(I=3):C.length===2&&C[0]===_&&C[1]===E&&(I=5),I===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let P=!1,S=p;if(i&&Be.size(i.dims)>0){if(i.dims.length!==3&&i.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(t.dims[0]!==i.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(i.dims.length===3){if(y!==i.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');S=i.dims[2]}else{if(y!==i.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');S=i.dims[1]*i.dims[3],P=!0}}let k=!1;if(u&&Be.size(u.dims)>0)throw new Error("Key padding mask is not supported");if(d&&Be.size(d.dims)>0){if(d.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(d.dims[0]!==_||d.dims[1]!==n.numHeads||d.dims[2]!==m||d.dims[3]!==E)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:_,sequenceLength:m,pastSequenceLength:v,kvSequenceLength:y,totalSequenceLength:E,maxSequenceLength:x,inputHiddenSize:0,hiddenSize:p,vHiddenSize:S,headSize:L,vHeadSize:Math.floor(S/n.numHeads),numHeads:n.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:n.maskFilterValue,maskType:I,scale:n.scale,broadcastResPosBias:k,passPastInKv:P,qkvFormat:T}},HE=e=>kn({...e}),m0=kn({perm:[0,2,1,3]}),IM=(e,n,t,a,i,l,u)=>{let d=[a,i,l],f=Be.size(d),h=[{type:12,data:f},{type:12,data:u},{type:12,data:l}],_=m=>{let p=kt("qkv_with_bias",n.dataType,d),y=qe("qkv",n.dataType,d),v=qe("bias",t.dataType,d),x=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${m.registerUniforms(x).declareVariables(y,v,p)}
  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:d,dataType:n.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:h}),getShaderSource:_},{inputs:[n,t],outputs:[-1]})[0]},Op=(e,n,t,a,i,l,u,d)=>{let f=l;if(u&&Be.size(u.dims)>0){if(a===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return f=IM(e,l,u,n,a,t*i,d),f=f.reshape([n,a,t,i]),t===1||a===1?f:e.compute(_a(f,m0.perm),{inputs:[f],outputs:[-1]})[0]}else return l.dims.length===3&&(f=l.reshape([n,a,t,i])),t===1||a===1?f:e.compute(_a(f,m0.perm),{inputs:[f],outputs:[-1]})[0]},KE=(e,n)=>{let t=DM(e.inputs,n),a=e.inputs[0],i=Bs(e.inputs,1),l=Bs(e.inputs,2),u=Bs(e.inputs,3),d=Bs(e.inputs,4),f=Bs(e.inputs,5),h=Bs(e.inputs,6),_=Bs(e.inputs,7);if(a.dims.length===5)throw new Error("Packed QKV is not implemented");if(i?.dims.length===5)throw new Error("Packed KV is not implemented");let m=i&&l&&i.dims.length===4&&l.dims.length===4,p=Op(e,t.batchSize,t.numHeads,t.sequenceLength,t.headSize,a,u,0);if(m)return jp(e,p,i,l,d,void 0,h,_,f,t);if(!i||!l)throw new Error("key and value must be provided");let y=Op(e,t.batchSize,t.numHeads,t.kvSequenceLength,t.headSize,i,u,t.hiddenSize),v=Op(e,t.batchSize,t.numHeads,t.kvSequenceLength,t.vHeadSize,l,u,2*t.hiddenSize);jp(e,p,y,v,d,void 0,h,_,f,t)}}),LM,zM,FM,RM,_y,QE,XE,YE=ut(()=>{Bt(),en(),kr(),rn(),LM=e=>{if(!e||e.length<1)throw new Error("too few inputs")},zM=(e,n)=>{let t=[],a=n.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(i=>t.push(Number(i))),a=t.length),kn({numOutputs:a,axis:n.axis,splitSizes:t})},FM=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < ${Ot("uniforms.size_in_split_axis","i",e)}) {
        return i;
    }
    }
    return ${e}u;
}`,RM=e=>{let n=e.length,t=[];for(let a=0;a<n;++a){let i=e[a].setByIndices("indices","input[global_idx]");n===1?t.push(i):a===0?t.push(`if (output_number == ${a}u) { ${i} }`):a===n-1?t.push(`else { ${i} }`):t.push(`else if (output_number == ${a}) { ${i} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${t.join(`
`)}
      }`},_y=(e,n)=>{let t=e[0].dims,a=Be.size(t),i=e[0].dataType,l=Be.normalizeAxis(n.axis,t.length),u=new Array(n.numOutputs),d=qe("input",i,t.length),f=new Array(n.numOutputs),h=[],_=[],m=0,p=[{type:12,data:a}];for(let v=0;v<n.numOutputs;v++){m+=n.splitSizes[v],f[v]=m;let x=t.slice();x[l]=n.splitSizes[v],_.push(x),u[v]=kt(`output${v}`,i,x.length),h.push({dims:_[v],dataType:e[0].dataType})}p.push({type:12,data:f},...It(t,..._));let y=v=>`
  ${v.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",f.length).declareVariables(d,...u)}
  ${FM(f.length)}
  ${RM(u)}

  ${v.mainStart()}
    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${d.offsetToIndices("global_idx")};
    var index = ${d.indicesGet("indices",l)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${Ot("uniforms.size_in_split_axis","output_number - 1u",f.length)};
      ${d.indicesSet("indices",l,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:n.cacheKey,inputDependencies:["rank"]},getShaderSource:y,getRunData:()=>({outputs:h,dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p})}},QE=(e,n)=>{LM(e.inputs);let t=e.inputs.length===1?n:zM(e.inputs,n);e.compute(_y(e.inputs,t),{inputs:[0]})},XE=e=>{let n=e.axis,t=e.splitSizes,a=e.numOutputs<0?t.length:e.numOutputs;if(a!==t.length)throw new Error("numOutputs and splitSizes lengh must be equal");return kn({axis:n,numOutputs:a,splitSizes:t})}}),BM,C_,ZE,JE=ut(()=>{Bt(),en(),kr(),rn(),BM=(e,n)=>{let[t,a,i,l]=e,{numHeads:u,rotaryEmbeddingDim:d}=n;if(t.dims.length!==3&&t.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${t.dims.length}`);if(!Be.areEqual(a.dims,[])&&!Be.areEqual(a.dims,[1])&&a.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${a.dims.length}`);if(i.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${i.dims.length}`);if(l.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${l.dims.length}`);if(!Be.areEqual(i.dims,l.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(d>0&&u===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let f=t.dims[0],h=t.dims[t.dims.length-2],_=i.dims[0],m=Be.sizeFromDimension(t.dims,1)/h,p=d===0?i.dims[1]*2:m/u;if(d>p)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(a.dims.length===2){if(f!==a.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${a.dims[0]}`);if(h!==a.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${a.dims[1]}`)}if(p/2!==i.dims[1]&&d/2!==i.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${i.dims[1]}`);if(h>_)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},C_=(e,n)=>{let{interleaved:t,numHeads:a,rotaryEmbeddingDim:i,scale:l}=n,u=e[0].dims[0],d=Be.sizeFromDimension(e[0].dims,1),f=e[0].dims[e[0].dims.length-2],h=d/f,_=e[2].dims[1],m=i===0?_*2:h/a,p=new Array(u,f,h/m,m-_),y=Be.computeStrides(p),v=[{type:1,data:l},{type:12,data:p},{type:12,data:y},...e[0].dims.length===3?new Array({type:12,data:[d,h,m,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[d,m,f*m,1]}):[],...It(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],x=L=>{let T=qe("input",e[0].dataType,e[0].dims.length),E=qe("position_ids",e[1].dataType,e[1].dims.length),I=qe("cos_cache",e[2].dataType,e[2].dims.length),P=qe("sin_cache",e[3].dataType,e[3].dims.length),S=kt("output",e[0].dataType,e[0].dims.length);return L.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:p.length},{name:"global_strides",type:"u32",length:y.length},{name:"input_output_strides",type:"u32",length:y.length}]),`
        ${L.declareVariables(T,E,I,P,S)}

        ${L.mainStart(lf)}
          let half_rotary_emb_dim = uniforms.${I.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${L.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${E.broadcastedIndicesToOffset("bsnh.xy",kt("",E.type.tensor,2))};
            let position_id =
                u32(${E.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${t});
            let j = i + select(half_rotary_emb_dim, 1, ${t});
            let re = ${T.getByOffset("i")} * ${I.get("position_id","bsnh[3]")} -
                ${T.getByOffset("j")} * ${P.get("position_id","bsnh[3]")};
            ${S.setByOffset("i","re")}
            let im = ${T.getByOffset("i")} * ${P.get("position_id","bsnh[3]")} +
                ${T.getByOffset("j")} * ${I.get("position_id","bsnh[3]")};
            ${S.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${S.setByOffset("k",T.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:kn({interleaved:t}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:x,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Be.size(p)/lf)},programUniforms:v})}},ZE=(e,n)=>{BM(e.inputs,n),e.compute(C_(e.inputs,n))}}),jM,NM,_0,UM,eS,h$=ut(()=>{kr(),Bt(),Qy(),qE(),YE(),ql(),JE(),rn(),jM=(e,n)=>{if(n.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let t=e[0],a=e[1],i=e[2],l=e[3],u=e[4];if(n.doRotary!==0&&e.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(n.localWindowSize!==-1)throw new Error("Local attention is not supported");if(n.softcap!==0)throw new Error("Softcap is not supported");if(n.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(n.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(t.dims.length!==3&&t.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let d=!1,f=t.dims[0],h=t.dims[1],_=t.dims.length===3?d?t.dims[2]/3:t.dims[2]:n.numHeads*t.dims[4],m=h,p=0,y=!a||a.dims.length===0,v=Math.floor(y?_/(n.numHeads+2*n.kvNumHeads):_/n.numHeads);y&&(_=v*n.numHeads);let x=l&&l.dims.length!==0,L=u&&u.dims.length!==0;if(x&&l.dims.length===4&&l.dims[0]===f&&l.dims[1]!==n.kvNumHeads&&l.dims[2]===n.kvNumHeads&&l.dims[3]===v)throw new Error("BSNH pastKey/pastValue is not supported");if(x&&L){if(l.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(u.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');p=l.dims[2]}else if(x||L)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let T=1;if(a&&a.dims.length>0){if(t.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(a.dims.length<3||a.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(t.dims[0]!==a.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(a.dims.length===3){if(t.dims[2]%a.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');m=a.dims[1]}else if(a.dims.length===5){if(a.dims[2]!==n.numHeads||a.dims[3]!==2||a.dims[4]!==v)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(i)throw new Error('Expect "value" be none when "key" has packed kv format.');m=a.dims[1]}else{if(a.dims[1]!==n.numHeads||a.dims[3]!==v)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');m=a.dims[2]}}else{if(t.dims.length!==3&&t.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(t.dims.length===5&&(t.dims[2]!==n.numHeads||t.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');T=3}let E=0,I=!1,P=n.kvNumHeads?v*n.kvNumHeads:_;if(i&&i.dims.length>0){if(i.dims.length!==3&&i.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(t.dims[0]!==i.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(i.dims.length===3){if(m!==i.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');P=i.dims[2]}else{if(m!==i.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');P=i.dims[1]*i.dims[3],I=!0}}let S=e.length>4?e[5]:void 0;if(S&&S.dims.length!==1&&S.dims[0]!==f)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:f,sequenceLength:h,pastSequenceLength:p,kvSequenceLength:m,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:_,vHiddenSize:P,headSize:v,vHeadSize:Math.floor(P/n.kvNumHeads),numHeads:n.numHeads,kvNumHeads:n.kvNumHeads,nReps:n.numHeads/n.kvNumHeads,pastPresentShareBuffer:!1,maskType:E,scale:n.scale,broadcastResPosBias:!1,passPastInKv:I,qkvFormat:T}},NM=kn({perm:[0,2,1,3]}),_0=(e,n,t)=>{let a=n,i=t.kvNumHeads;return n.dims.length===3&&t.kvSequenceLength!==0&&(a=n.reshape([t.batchSize,t.kvSequenceLength,i,t.headSize]),a=e.compute(_a(a,NM.perm),{inputs:[a],outputs:[-1]})[0]),a},UM=(e,n,t,a)=>{let i=7,l=["type","type"],u=[e*n],d=e*n,f=[{type:12,data:d},{type:12,data:n},{type:12,data:e}],h=_=>{let m=qe("seq_lens",t.dataType,t.dims),p=qe("total_seq_lens",a.dataType,a.dims),y=kt("pos_ids",i,u),v=[{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}];return`
  ${_.registerUniforms(v).declareVariables(m,p,y)}
  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${p.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${m.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${y.setByOffset("global_idx","pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${y.setByOffset("global_idx","pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${y.setByOffset("global_idx","seqlen")}
    };
  }
  `};return{name:"GeneratePositionIds",shaderCache:{hint:`${e};${n}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:f}),getShaderSource:h}},eS=(e,n)=>{let t=jM(e.inputs,n);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let a=e.inputs[0],i=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,l=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,u=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,d=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,f=e.inputs.length>4?e.inputs[5]:void 0,h=e.inputs.length>5?e.inputs[6]:void 0,_=t.kvNumHeads?t.kvNumHeads:t.numHeads,m=kn({axis:2,numOutputs:3,splitSizes:[t.numHeads*t.headSize,_*t.headSize,_*t.headSize]}),[p,y,v]=!i&&!l?e.compute(_y([a],m),{inputs:[a],outputs:[-1,-1,-1]}):[a,i,l],x,L;if(n.doRotary){let P=e.compute(UM(t.batchSize,t.sequenceLength,f,h),{inputs:[f,h],outputs:[-1]})[0],S=e.inputs[7],k=e.inputs[8],C=kn({interleaved:n.rotaryInterleaved!==0,numHeads:t.numHeads,rotaryEmbeddingDim:0,scale:n.scale}),D=[p,P,S,k],V=[-1];x=e.compute(C_(D,C),{inputs:D,outputs:V})[0],D.splice(0,1,y);let U=kn({interleaved:n.rotaryInterleaved!==0,numHeads:t.kvNumHeads,rotaryEmbeddingDim:0,scale:n.scale});L=e.compute(C_(D,U),{inputs:D,outputs:V})[0]}let T=Op(e,t.batchSize,t.numHeads,t.sequenceLength,t.headSize,n.doRotary?x:p,void 0,0),E=_0(e,n.doRotary?L:y,t),I=_0(e,v,t);jp(e,T,E,I,void 0,void 0,u,d,void 0,t,f,h)}}),g0,VM,GM,tS,p$=ut(()=>{Bt(),en(),ql(),rn(),g0=(e,n,t,a,i,l,u,d)=>{let f=Tr(l),h=f===1?"f32":`vec${f}f`,_=f===1?"vec2f":`mat2x${f}f`,m=i*u,p=64;m===1&&(p=256);let y=[i,u,l/f],v=[i,u,2],x=["rank","type","type"],L=[];L.push(...It(y,v));let T=E=>{let I=qe("x",n.dataType,3,f),P=qe("scale",t.dataType,t.dims),S=qe("bias",a.dataType,a.dims),k=kt("output",1,3,2),C=[I,P,S,k];return`
  var<workgroup> workgroup_shared : array<${_}, ${p}>;
  const workgroup_size = ${p}u;
  ${E.declareVariables(...C)}
  ${E.mainStart(p)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${h}(0);
    var squared_sum = ${h}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${h}(${I.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${_}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${Kl("workgroup_shared[0][0]",f)} / f32(hight * ${f});
      let squared_sum_final = ${Kl("workgroup_shared[0][1]",f)} / f32(hight * ${f});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${d}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${f};${d};${p}`,inputDependencies:x},getRunData:()=>({outputs:[{dims:v,dataType:1}],dispatchGroup:{x:m},programUniforms:L}),getShaderSource:T},{inputs:[n,t,a],outputs:[-1]})[0]},VM=(e,n,t)=>{let a=n[0].dims,i=a,l=2,u=a[0],d=a[1],f=Be.sizeFromDimension(a,l),h=Tr(f),_=Be.size(i)/h,m=g0(e,n[0],n[1],n[2],u,f,d,t.epsilon),p=[u,d,f/h],y=[u,d],v=["type","none"],x=L=>{let T=qe("x",n[0].dataType,p.length,h),E=qe("scale_shift",1,y.length,2),I=kt("output",n[0].dataType,p.length,h),P=[T,E,I];return`
  ${L.registerUniform("output_size","u32").declareVariables(...P)}
  ${L.mainStart()}
  ${L.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${I.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${E.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${T.getByOffset("global_idx")} * ${I.type.value}(scale_shift.x) + ${I.type.value}(scale_shift.y);
      ${I.setByOffset("global_idx","value")};
  }`};e.compute({name:"InstanceNormalization",shaderCache:{hint:`${h}`,inputDependencies:v},getRunData:()=>({outputs:[{dims:i,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:[{type:12,data:_},...It(p,y,p)]}),getShaderSource:x},{inputs:[n[0],m]})},GM=(e,n,t)=>{let a=n[0].dims,i=a,l=a[0],u=a[a.length-1],d=Be.sizeFromDimension(a,1)/u,f=Tr(u),h=Be.size(i)/f,_=[{type:12,data:d},{type:12,data:Math.floor(u/f)}],m=["type","type"],p=!1,y=[0,a.length-1];for(let T=0;T<a.length-2;T++)p=p||a[T+1]!==1,y.push(T+1);p=p&&a[a.length-1]!==1;let v=p?e.compute(_a(e.inputs[0],y),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:a.length},(T,E)=>a[y[E]])),x=g0(e,v,n[1],n[2],l,d,u,t.epsilon),L=T=>{let E=ns(n[0].dataType),I=f===1?"vec2f":`mat${f}x2f`,P=C=>{let D=C===0?"x":"y",V=f===1?"f32":`vec${f}f`;switch(f){case 1:return`${E}(${V}(scale.${D}))`;case 2:return`vec2<${E}>(${V}(scale[0].${D}, scale[1].${D}))`;case 4:return`vec4<${E}>(${V}(scale[0].${D}, scale[1].${D}, scale[2].${D}, scale[3].${D}))`;default:throw new Error(`Not supported compoents ${f}`)}},S=qe("input",n[0].dataType,n[0].dims,f),k=kt("output",n[0].dataType,i,f);return`
  @group(0) @binding(0) var<storage, read> input : array<${S.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${I}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${k.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${T.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${P(0)}, ${P(1)});
  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${f}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:i,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:_}),getShaderSource:L},{inputs:[n[0],x]})},tS=(e,n)=>{n.format==="NHWC"?GM(e,e.inputs,n):VM(e,e.inputs,n)}}),WM,HM,nS,m$=ut(()=>{Bt(),en(),rn(),WM=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},HM=(e,n,t)=>{let a=n.simplified,i=e[0].dims,l=e[1],u=!a&&e[2],d=i,f=Be.normalizeAxis(n.axis,i.length),h=Be.sizeToDimension(i,f),_=Be.sizeFromDimension(i,f),m=Be.size(l.dims),p=u?Be.size(u.dims):0;if(m!==_||u&&p!==_)throw new Error(`Size of X.shape()[axis:] == ${_}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${m} and bias size of ${p}`);let y=[];for(let S=0;S<i.length;++S)S<f?y.push(i[S]):y.push(1);let v=Tr(_),x=["type","type"],L=[{type:12,data:h},{type:1,data:_},{type:12,data:Math.floor(_/v)},{type:1,data:n.epsilon}];u&&x.push("type");let T=t>1,E=t>2,I=S=>{let k=ns(e[0].dataType),C=[qe("x",e[0].dataType,e[0].dims,v),qe("scale",l.dataType,l.dims,v)];u&&C.push(qe("bias",u.dataType,u.dims,v)),C.push(kt("output",e[0].dataType,d,v)),T&&C.push(kt("mean_data_output",1,y)),E&&C.push(kt("inv_std_output",1,y));let D=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${S.registerUniforms(D).declareVariables(...C)}
  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${oy("f32",v)};
    var mean_square_vector = ${oy("f32",v)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${sf(k,v,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Kl("mean_vector",v)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Kl("mean_square_vector",v)} / uniforms.norm_size ${a?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${sf(k,v,"x[j + offset]")};
      let f32scale = ${sf(k,v,"scale[j]")};
      output[j + offset] = ${C[0].type.value}((f32input ${a?"":"- mean"}) * inv_std_dev * f32scale
        ${u?`+ ${sf(k,v,"bias[j]")}`:""}
      );
    }

    ${T?"mean_data_output[global_idx] = mean":""};
    ${E?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},P=[{dims:d,dataType:e[0].dataType}];return T&&P.push({dims:y,dataType:1}),E&&P.push({dims:y,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${v};${t};${a}`,inputDependencies:x},getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(h/64)},programUniforms:L}),getShaderSource:I}},nS=(e,n)=>{WM(e.inputs),e.compute(HM(e.inputs,n,e.outputCount))}}),KM,rS,_$=ut(()=>{en(),ev(),tv(),KM=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},rS=e=>{KM(e.inputs);let n=of.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!n)throw new Error("Can't use matmul on the given tensors");let t=n[n.length-1],a=e.inputs[0].dims[e.inputs[0].dims.length-1];if(t<8&&a<8)e.compute(Jy(e.inputs,{activation:""},n));else{let i=n[n.length-2],l=Be.size(e.inputs[0].dims.slice(0,-2)),u=Be.size(e.inputs[1].dims.slice(0,-2));if(l!==1&&i===1&&u===1){let d=e.inputs[0].reshape([1,l,a]),f=e.inputs[1].reshape([1,a,t]),h=[1,l,t],_=[d,f];e.compute(S_(_,{activation:""},n,h),{inputs:_})}else e.compute(S_(e.inputs,{activation:""},n))}}}),qM,QM,XM,sS,aS,g$=ut(()=>{Bt(),en(),kr(),rn(),qM=(e,n)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let t=e[0],a=t.dims.length;if(t.dims[a-1]!==n.k)throw new Error("The last dim of input shape does not match the k value");let i=Math.floor((n.k+n.blockSize-1)/n.blockSize),l=n.blockSize/8*n.bits,u=e[1];if(!Be.areEqual(u.dims,[n.n,i,l]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let d=e[2].dims;if(Be.size(d)!==n.n*i)throw new Error("scales input size error.");if(e.length===4){let f=e[3].dims,h=n.bits>4?n.n*i:n.n*Math.floor((i+1)/2);if(Be.size(f)!==h)throw new Error("zeroPoints input size error.")}},QM=(e,n)=>{let t=e[0].dims,a=t.length,i=t[a-2],l=n.k,u=n.n,d=t.slice(0,a-2),f=Be.size(d),h=e[1].dims[2]/4,_=e[0].dataType,m=Tr(n.k),p=Tr(h),y=Tr(u),v=d.concat([i,u]),x=i>1&&u/y%2===0?2:1,L=Be.size(v)/y/x,T=64,E=[],I=[f,i,l/m],P=Be.convertShape(e[1].dims).slice();P.splice(-1,1,h/p),E.push(...It(I)),E.push(...It(P)),E.push(...It(e[2].dims)),e.length===4&&E.push(...It(Be.convertShape(e[3].dims)));let S=[f,i,u/y];E.push(...It(S));let k=C=>{let D=I.length,V=qe("a",e[0].dataType,D,m),U=qe("b",12,P.length,p),ne=qe("scales",e[2].dataType,e[2].dims.length),ee=[V,U,ne],H=e.length===4?qe("zero_points",12,e[3].dims.length):void 0;H&&ee.push(H);let oe=S.length,ae=kt("output",e[0].dataType,oe,y),W=ns(e[0].dataType),te=(()=>{switch(m){case 1:return`array<${W}, 8>`;case 2:return`mat4x2<${W}>`;case 4:return`mat2x4<${W}>`;default:throw new Error(`${m}-component is not supported.`)}})(),ie=()=>{let B=`
          // reuse a data
            var input_offset = ${V.indicesToOffset(`${V.type.indices}(batch, row, word_offset)`)};
            var a_data: ${te};
            for (var j: u32 = 0; j < ${8/m}; j++) {
              a_data[j] = ${V.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let R=0;R<y*x;R++)B+=`
            b_value = ${p===1?`b${R}_data`:`b${R}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${te}(${Array.from({length:4},(Q,G)=>`${W}(b_value_lower[${G}]), ${W}(b_value_upper[${G}])`).join(", ")});
            b_dequantized_values = ${m===1?`${te}(${Array.from({length:8},(Q,G)=>`(b_quantized_values[${G}] - ${H?`zero_point${R}`:"zero_point"}) * scale${R}`).join(", ")});`:`(b_quantized_values - ${te}(${Array(8).fill(`${H?`zero_point${R}`:"zero_point"}`).join(",")})) * scale${R};`};
            workgroup_shared[local_id.x * ${x} + ${Math.floor(R/y)}]${y>1?`[${R%y}]`:""} += ${Array.from({length:8/m},(Q,G)=>`${m===1?`a_data[${G}] * b_dequantized_values[${G}]`:`dot(a_data[${G}], b_dequantized_values[${G}])`}`).join(" + ")};
          `;return B},_e=()=>{let B=`
            var col_index = col * ${y};
            ${H?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${W}(8);`}
            `;for(let R=0;R<y*x;R++)B+=`
            let scale${R} = ${ne.getByOffset("col_index * nBlocksPerCol + block")};
            ${H?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${H.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${R} = ${W}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return B},q=()=>{let B=`col_index = col * ${y};`;for(let R=0;R<y*x;R++)B+=`
            let b${R}_data = ${U.getByIndices(`${U.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return B+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${te};
            var b_dequantized_values: ${te};`,B};return`
        var<workgroup> workgroup_shared: array<${ae.type.value}, ${x*T}>;
        ${C.declareVariables(...ee,ae)}
        ${C.mainStart([T,1,1])}
          let output_indices = ${ae.offsetToIndices(`(global_idx / ${T}) * ${x}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${T}) {
            //process one block
            var word_offset: u32 = block * ${n.blockSize/m};
            ${_e()}
            for (var word: u32 = 0; word < ${h}; word += ${p}) {
              ${q()}
              for (var i: u32 = 0; i < ${p}; i++) {
                ${ie()}
                word_offset += ${8/m};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${x}) {
            var output_value: ${ae.type.value} = ${ae.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${T}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${x};
            }
            ${ae.setByIndices(`${ae.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${n.blockSize};${n.bits};${m};${p};${y};${x};${T}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:v,dataType:_}],dispatchGroup:{x:L},programUniforms:E}),getShaderSource:k}},XM=(e,n)=>{let t=e[0].dims,a=t.length,i=t[a-2],l=n.k,u=n.n,d=t.slice(0,a-2),f=Be.size(d),h=e[1].dims[2]/4,_=e[0].dataType,m=Tr(n.k),p=Tr(h),y=d.concat([i,u]),v=128,x=u%8===0?8:u%4===0?4:1,L=v/x,T=L*p*8,E=T/m,I=T/n.blockSize,P=Be.size(y)/x,S=[],k=[f,i,l/m],C=Be.convertShape(e[1].dims).slice();C.splice(-1,1,h/p),S.push(...It(k)),S.push(...It(C)),S.push(...It(e[2].dims)),e.length===4&&S.push(...It(Be.convertShape(e[3].dims)));let D=[f,i,u];S.push(...It(D));let V=U=>{let ne=k.length,ee=qe("a",e[0].dataType,ne,m),H=qe("b",12,C.length,p),oe=qe("scales",e[2].dataType,e[2].dims.length),ae=[ee,H,oe],W=e.length===4?qe("zero_points",12,e[3].dims.length):void 0;W&&ae.push(W);let te=D.length,ie=kt("output",e[0].dataType,te),_e=ns(e[0].dataType),q=()=>{switch(m){case 1:return`
          let a_data0 = vec4<${_e}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${_e}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${_e}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${_e}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${m}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${ee.type.value}, ${E}>;
        var<workgroup> inter_results: array<array<${ie.type.value}, ${L}>, ${x}>;
        ${U.declareVariables(...ae,ie)}
        ${U.mainStart([L,x,1])}
          let output_indices = ${ie.offsetToIndices(`workgroup_index * ${x}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${I} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${E};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${E}; a_offset += ${v})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${ee.getByIndices(`${ee.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${ee.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${I} + local_id.x;
            ${W?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${W.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${_e}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${_e}(8);`}
            let scale = ${oe.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${H.getByIndices(`${H.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${n.blockSize/m};
            for (var i: u32 = 0; i < ${p}; i++) {
              ${q()}
              let b_value = ${p===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${_e}>(${Array.from({length:4},(B,R)=>`${_e}(b_value_lower[${R}]), ${_e}(b_value_upper[${R}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${_e}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(B,R)=>`${`dot(a_data${R}, b_dequantized_values[${R}])`}`).join(" + ")};
              word_offset += ${8/m};
            }
            workgroupBarrier();
          }

          if (local_idx < ${x}) {
            var output_value: ${ie.type.value} = ${ie.type.value}(0);
            for (var b = 0u; b < ${L}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${ie.setByIndices(`${ie.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${n.blockSize};${m};${p};${L};${x}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:y,dataType:_}],dispatchGroup:{x:P},programUniforms:S}),getShaderSource:V}},sS=(e,n)=>{qM(e.inputs,n),n.blockSize===32&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(XM(e.inputs,n)):e.compute(QM(e.inputs,n))},aS=e=>kn(e)}),YM,ZM,JM,e2,t2,n2,r2,s2,iS,y$=ut(()=>{Bt(),en(),rn(),YM=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error("Input type must be float or float16.");if(e.length>=2){let n=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(n=e[3].dims[0]*2===e[1].dims[0]),!n)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},ZM=(e,n,t)=>{let a="";for(let i=n-1;i>=0;--i)a+=`
            k = i32(${e.indicesGet("indices",i)}) - ${Ot("uniforms.pads",i,t)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${Ot("uniforms.x_shape",i,n)})) {
              break;
            }
            offset += k * i32(${Ot("uniforms.x_strides",i,n)});
        `;return`
          value = ${e.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${a}
            value = x[offset];
          }
      `},JM=(e,n,t)=>{let a="";for(let i=n-1;i>=0;--i)a+=`
                k = i32(${e.indicesGet("indices",i)}) - ${Ot("uniforms.pads",i,t)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${Ot("uniforms.x_shape",i,n)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${Ot("uniforms.x_shape",i,n)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${Ot("uniforms.x_strides",i,n)});
            `;return`
              var offset = 0;
              var k = 0;
              ${a}
              value = x[offset];
          `},e2=(e,n,t)=>{let a="";for(let i=n-1;i>=0;--i)a+=`
                k = i32(${e.indicesGet("indices",i)}) - ${Ot("uniforms.pads",i,t)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${Ot("uniforms.x_shape",i,n)})) {
                  k = i32(${Ot("uniforms.x_shape",i,n)}) - 1;
                }
                offset += k * i32(${Ot("uniforms.x_strides",i,n)});
            `;return`
              var offset = 0;
              var k = 0;
              ${a}
              value = x[offset];
          `},t2=(e,n,t)=>{let a="";for(let i=n-1;i>=0;--i)a+=`
                k = i32(${e.indicesGet("indices",i)}) - ${Ot("uniforms.pads",i,t)};
                if (k < 0)  {
                  k += i32(${Ot("uniforms.x_shape",i,n)}]);
                }
                if (k >= i32(${Ot("uniforms.x_shape",i,n)})) {
                  k -= i32(${Ot("uniforms.x_shape",i,n)});
                }
                offset += k * i32(${Ot("uniforms.x_strides",i,n)});
            `;return`
              var offset = 0;
              var k = 0;
              ${a}
              value = x[offset];
          `},n2=(e,n,t)=>{switch(t.mode){case 0:return ZM(e,n,t.pads.length);case 1:return JM(e,n,t.pads.length);case 2:return e2(e,n,t.pads.length);case 3:return t2(e,n,t.pads.length);default:throw new Error("Invalid mode")}},r2=(e,n)=>{let t=Be.padShape(e[0].dims.slice(),n.pads),a=e[0].dims,i=Be.size(t),l=[{type:12,data:i},{type:6,data:n.pads}],u=e.length>=3&&e[2].data;n.mode===0&&l.push({type:u?e[2].dataType:1,data:n.value}),l.push(...It(e[0].dims,t));let d=["rank"],f=h=>{let _=kt("output",e[0].dataType,t.length),m=qe("x",e[0].dataType,a.length),p=m.type.value,y=n2(_,a.length,n),v=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:n.pads.length}];return n.mode===0&&v.push({name:"constant_value",type:u?p:"f32"}),`
            ${h.registerUniforms(v).declareVariables(m,_)}
            ${h.mainStart()}
            ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${_.offsetToIndices("global_idx")};

            var value = ${p}(0);
            ${y}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${n.mode}${u}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Be.size(t)/64)},programUniforms:l}),getShaderSource:f}},s2=(e,n)=>{if(e.length>1){let t=e[1].getBigInt64Array(),a=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,i=e[0].dims.length,l=new Int32Array(2*i).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let f=0;f<d.length;f++)l[Number(d[f])]=Number(t[f]),l[Number(d[f])+i]=Number(t[f+d.length])}else t.forEach((d,f)=>l[Number(f)]=Number(d));let u=[];return l.forEach(d=>u.push(d)),{mode:n.mode,value:a,pads:u}}else return n},iS=(e,n)=>{YM(e.inputs);let t=s2(e.inputs,n);e.compute(r2(e.inputs,t),{inputs:[0]})}}),xp,y0,v0,b0,w0,a2,i2,M0,x0,oS,lS,T0,uS,cS,E0,dS,fS,hS,pS,v$=ut(()=>{Ti(),Bt(),en(),rn(),xp=e=>{if(Jn.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},y0=(e,n,t)=>{let a=n.format==="NHWC",i=e.dims.slice();a&&i.splice(1,0,i.pop());let l=Object.hasOwnProperty.call(n,"dilations"),u=n.kernelShape.slice(),d=n.strides.slice(),f=l?n.dilations.slice():[],h=n.pads.slice();T_.adjustPoolAttributes(t,i,u,d,f,h);let _=T_.computePoolOutputShape(t,i,d,f,u,h,n.autoPad),m=Object.assign({},n);l?Object.assign(m,{kernelShape:u,strides:d,pads:h,dilations:f,cacheKey:n.cacheKey}):Object.assign(m,{kernelShape:u,strides:d,pads:h,cacheKey:n.cacheKey});let p=_.slice();return p.push(p.splice(1,1)[0]),[m,a?p:_]},v0=(e,n)=>{let t=n.format==="NHWC",a=Be.size(e),i=Be.size(n.kernelShape),l=[{type:12,data:a},{type:12,data:i}],u=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(n.kernelShape.length<=2){let d=n.kernelShape[n.kernelShape.length-1],f=n.strides[n.strides.length-1],h=n.pads[n.pads.length/2-1],_=n.pads[n.pads.length-1],m=!!(h+_);l.push({type:12,data:d},{type:12,data:f},{type:12,data:h},{type:12,data:_}),u.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let p=!1;if(n.kernelShape.length===2){let y=n.kernelShape[n.kernelShape.length-2],v=n.strides[n.strides.length-2],x=n.pads[n.pads.length/2-2],L=n.pads[n.pads.length-2];p=!!(x+L),l.push({type:12,data:y},{type:12,data:v},{type:12,data:x},{type:12,data:L}),u.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[l,u,!0,m,p]}else{if(t)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let d=Be.computeStrides(n.kernelShape);l.push({type:12,data:d},{type:12,data:n.pads},{type:12,data:n.strides}),u.push({name:"kernelStrides",type:"u32",length:d.length},{name:"pads",type:"u32",length:n.pads.length},{name:"strides",type:"u32",length:n.strides.length});let f=n.pads.reduce((h,_)=>h+_);return[l,u,!!f,!1,!1]}},b0=(e,n,t,a,i,l,u,d,f,h,_,m)=>{let p=i.format==="NHWC",y=n.type.value,v=kt("output",n.type.tensor,a);if(i.kernelShape.length<=2){let x="",L="",T="",E=t-(p?2:1);if(_?x=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${E}] = indices[${E}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${E}] < 0 || xIndices[${E}]
                      >= uniforms.x_shape[${E}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${n.indicesToOffset("xIndices")}];
                  ${l}
                }`:x=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${E}] = indices[${E}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${n.indicesToOffset("xIndices")}];
                  ${l}
                }`,i.kernelShape.length===2){let I=t-(p?3:2);m?L=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${I}] = indices[${I}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${I}] < 0 || xIndices[${I}] >= uniforms.x_shape[${I}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:L=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${I}] = indices[${I}] * uniforms.sh - uniforms.phStart + j;
                `,T=`
              }
            `}return`
            ${e.registerUniforms(f).declareVariables(n,v)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${v.offsetToIndices("global_idx")};
              var xIndices = ${v.offsetToIndices("global_idx")};

              var value = ${y}(${d});
              var pad = 0;
              ${L}
              ${x}
              ${T}
              ${u}

              output[global_idx] = value;
            }`}else{if(p)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let x=i.kernelShape.length,L=i.pads.length,T="";return h?T=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${n.indicesToOffset("xIndices")}];
                ${l}
              }`:T=`
              }
              let x_val = x[${n.indicesToOffset("xIndices")}];
              ${l}
            `,`
            ${e.registerUniforms(f).declareVariables(n,v)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${v.offsetToIndices("global_idx")};
              var xIndices = ${v.offsetToIndices("global_idx")};

              var offsets: array<u32, ${x}>;

              var value = ${y}(${d});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${x-1}u; j++) {
                  offsets[j] = offset / ${Ot("uniforms.kernelStrides","j",x)};
                  offset -= offsets[j] * ${Ot("uniforms.kernelStrides","j",x)};
                }
                offsets[${x-1}] = offset;

                isPad = false;
                for (var j = ${t-x}u; j < ${t}u; j++) {
                  xIndices[j] = indices[j] * ${Ot("uniforms.strides",`j - ${t-x}u`,x)}
                    + offsets[j - ${t-x}u] - ${Ot("uniforms.pads","j - 2u",L)};
                  ${T}
              }
              ${u}

              output[global_idx] = value;
            }`}},w0=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,a2=e=>`${w0(e)};${e.countIncludePad}`,i2=e=>`${w0(e)};${e.storageOrder};${e.dilations}`,M0=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),x0=(e,n,t,a)=>{let[i,l]=y0(n,a,t),u=qe("x",n.dataType,n.dims.length),d=u.type.value,f="value += x_val;",h="";i.countIncludePad?h+=`value /= ${d}(uniforms.kernelSize);`:h+=`value /= ${d}(i32(uniforms.kernelSize) - pad);`;let[_,m,p,y,v]=v0(l,i);_.push(...It(n.dims,l));let x=["rank"];return{name:e,shaderCache:{hint:`${a.cacheKey};${p};${y};${v}`,inputDependencies:x},getRunData:()=>({outputs:[{dims:l,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(Be.size(l)/64)},programUniforms:_}),getShaderSource:L=>b0(L,u,n.dims.length,l.length,i,f,h,0,m,p,y,v)}},oS=e=>{let n=e.count_include_pad!==0,t=M0(e);if(t.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let a={countIncludePad:n,...t,cacheKey:""};return{...a,cacheKey:a2(a)}},lS=(e,n)=>{xp(e.inputs),e.compute(x0("AveragePool",e.inputs[0],!1,n))},T0={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},uS=e=>{let n=e.format;return{format:n,...T0,cacheKey:n}},cS=(e,n)=>{xp(e.inputs),e.compute(x0("GlobalAveragePool",e.inputs[0],!0,n))},E0=(e,n,t,a)=>{let[i,l]=y0(n,a,t),u=`
      value = max(x_val, value);
    `,d="",f=qe("x",n.dataType,n.dims.length),h=["rank"],[_,m,p,y,v]=v0(l,i);return _.push(...It(n.dims,l)),{name:e,shaderCache:{hint:`${a.cacheKey};${p};${y};${v}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:l,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(Be.size(l)/64)},programUniforms:_}),getShaderSource:x=>b0(x,f,n.dims.length,l.length,i,u,d,n.dataType===10?-65504:-1e5,m,p,y,v)}},dS=(e,n)=>{xp(e.inputs),e.compute(E0("MaxPool",e.inputs[0],!1,n))},fS=e=>{let n=e.storage_order,t=e.dilations,a=M0(e);if(n!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(a.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let i={storageOrder:n,dilations:t,...a,cacheKey:""};return{...i,cacheKey:i2(i)}},hS=e=>{let n=e.format;return{format:n,...T0,cacheKey:n}},pS=(e,n)=>{xp(e.inputs),e.compute(E0("GlobalMaxPool",e.inputs[0],!0,n))}}),o2,l2,mS,_S,b$=ut(()=>{Bt(),en(),kr(),rn(),o2=(e,n)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(e.length===3&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[0].dataType===6&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map((t,a)=>t===e[2].dims[a]).reduce((t,a)=>t&&a,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(n.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map((i,l)=>l===n.axis||i===e[0].dims[l]).reduce((i,l)=>i&&l,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let t=e[0].dims[n.axis],a=e[1].dims[n.axis];if(n.blockSize<Math.ceil(t/a)||n.blockSize>Math.ceil(t/(a-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},l2=(e,n)=>{let t=Be.normalizeAxis(n.axis,e[0].dims.length),a=e[0].dataType,i=a===3,l=e[0].dims,u=e[1].dataType,d=Be.size(l),f=a===3||a===2,h=f?[Math.ceil(Be.size(e[0].dims)/4)]:e[0].dims,_=e[1].dims,m=e.length>2?e[2]:void 0,p=m?f?[Math.ceil(Be.size(m.dims)/4)]:m.dims:void 0,y=_.length===0||_.length===1&&_[0]===1,v=y===!1&&_.length===1,x=Tr(d),L=y&&(!f||x===4),T=L?x:1,E=L&&!f?x:1,I=qe("input",f?12:a,h.length,E),P=qe("scale",u,_.length),S=m?qe("zero_point",f?12:a,p.length):void 0,k=kt("output",u,l.length,T),C=[I,P];S&&C.push(S);let D=[h,_];m&&D.push(p);let V=[{type:12,data:d/T},{type:12,data:t},{type:12,data:n.blockSize},...It(...D,l)],U=ne=>{let ee=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${ne.registerUniforms(ee).declareVariables(...C,k)}
      ${ne.mainStart()}
          ${ne.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${k.offsetToIndices("global_idx")};

          // Set input x
          ${f?`
            let input = ${I.getByOffset("global_idx / 4")};
            let x_vec = ${i?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${T===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${I.getByOffset("global_idx")};`};

          // Set scale input
          ${y?`let scale_value= ${P.getByOffset("0")}`:v?`
            let scale_index = ${k.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${P.getByOffset("scale_index")};`:`
            var scale_indices: ${P.type.indices} = output_indices;
            let index = ${P.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${P.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${P.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${S?y?f?`
                let zero_point_input = ${S.getByOffset("0")};
                let zero_point_vec =  ${i?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${S.getByOffset("0")}`:v?f?`
                let zero_point_index = ${k.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${S.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${i?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${k.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${S.getByOffset("zero_point_index")};`:f?`
                let zero_point_offset = ${P.indicesToOffset("scale_indices")};
                let zero_point_input = ${S.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${i?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${S.getByIndices("scale_indices")};`:`let zero_point_value = ${f?i?"i32":"u32":I.type.value}(0);`};
      // Compute and write output
      ${k.setByOffset("global_idx",`${k.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:n.cacheKey,inputDependencies:S?["rank","rank","rank"]:["rank","rank"]},getShaderSource:U,getRunData:()=>({outputs:[{dims:l,dataType:u}],dispatchGroup:{x:Math.ceil(d/T/64),y:1,z:1},programUniforms:V})}},mS=(e,n)=>{o2(e.inputs,n),e.compute(l2(e.inputs,n))},_S=e=>kn({axis:e.axis,blockSize:e.blockSize})}),u2,c2,gS,w$=ut(()=>{Ti(),Bt(),rn(),u2=(e,n,t)=>{let a=e===n,i=e<n&&t<0,l=e>n&&t>0;if(a||i||l)throw new Error("Range these inputs' contents are invalid.")},c2=(e,n,t,a)=>{let i=Math.abs(Math.ceil((n-e)/t)),l=[i],u=i,d=[{type:12,data:u},{type:a,data:e},{type:a,data:t},...It(l)],f=h=>{let _=kt("output",a,l.length),m=_.type.value,p=[{name:"outputSize",type:"u32"},{name:"start",type:m},{name:"delta",type:m}];return`
        ${h.registerUniforms(p).declareVariables(_)}
        ${h.mainStart()}
        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${m}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${a}`},getShaderSource:f,getRunData:()=>({outputs:[{dims:l,dataType:a}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d})}},gS=e=>{let n=0,t=0,a=0;e.inputs[0].dataType===6?(n=e.inputs[0].getInt32Array()[0],t=e.inputs[1].getInt32Array()[0],a=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(n=e.inputs[0].getFloat32Array()[0],t=e.inputs[1].getFloat32Array()[0],a=e.inputs[2].getFloat32Array()[0]),Jn.webgpu.validateInputContent&&u2(n,t,a),e.compute(c2(n,t,a,e.inputs[0].dataType),{inputs:[]})}}),d2,S0,C0,f2,yS,vS,M$=ut(()=>{Bt(),en(),kr(),rn(),d2=(e,n,t,a)=>{if(e!=="none"&&a!=="i32"&&a!=="u32"&&a!=="f32")throw new Error(`Input ${a} is not supported with reduction ${e}.`);let i=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,l=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${n}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(e){case"none":return`${n}=${t};`;case"add":return a==="i32"||a==="u32"?`atomicAdd(&${n}, bitcast<${a}>(${t}));`:`
              ${i}bitcast<${a}>(oldValue) + (${t})${l}`;case"max":return a==="i32"||a==="u32"?`atomicMax(&${n}, bitcast<${a}>(${t}));`:`
                ${i}max(bitcast<f32>(oldValue), (${t}))${l}`;case"min":return a==="i32"||a==="u32"?`atomicMin(&${n}, bitcast<${a}>(${t}));`:`${i}min(bitcast<${a}>(oldValue), (${t}))${l}`;case"mul":return`${i}(bitcast<${a}>(oldValue) * (${t}))${l}`;default:throw new Error(`Reduction ${e} is not supported.`)}},S0=(e,n)=>`${e===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[${n?"i - indices_start":"i"}];
    let dim_value = uniforms.output_shape[${n?"i - indices_start":"i"} + uniforms.last_index_dimension];`}
    
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));`,C0=(e,n,t)=>`for (var i = 0u; i < uniforms.num_updates_elements; i++) {
        let value = updates[uniforms.num_updates_elements * ${t?"global_idx":"idx"} + i];
        ${d2(e.reduction,"output[data_offset + i]","value",n)}
      }`,f2=(e,n)=>{let t=e[0].dims,a=e[1].dims,i=t,l=1,u=Math.ceil(Be.size(a)/l),d=a[a.length-1],f=Be.sizeFromDimension(t,d),h=Be.sizeFromDimension(a,0)/d,_=[{type:12,data:u},{type:12,data:d},{type:12,data:f},...It(e[1].dims,e[2].dims,i)],m=p=>{let y=qe("indices",e[1].dataType,e[1].dims.length),v=qe("updates",e[2].dataType,e[2].dims.length,l),x=n.reduction!=="none"&&n.reduction!==""?Kx("output",e[0].dataType,i.length):kt("output",e[0].dataType,i.length,l);return`
      ${p.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(y,v,x)}
      ${p.mainStart()}
        ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var hasDuplicates = false;
  if (${n.reduction==="none"}) {
    for (var i = 0; i < ${h}; i = i + 1) {
      for (var j = i + 1; j < ${h}; j = j + 1) {
        var index_i = i32(indices[i].x);
        var index_j = i32(indices[j].x);
        if (index_i == index_j) {
          hasDuplicates = true;
          break;
        }
      }
      if (hasDuplicates) {
        break;
      }
    }
  }

  if (${n.reduction==="none"} && hasDuplicates) {
    if (global_idx != 0u) {
      return;
    }
    // Process each index-update pair individually when duplicates exist
    for (var idx = 0u; idx < ${h}u; idx++) {
      var data_offset = 0u;
      for (var i = 0u; i < uniforms.last_index_dimension; i++) {
        var index = i32(indices[idx * uniforms.last_index_dimension + i].x);
        ${S0(t.length,!1)}
      }
      ${C0(n,x.type.value,!1)}
    }
    return;
  }

  var data_offset = 0u;
  var indices_start = uniforms.last_index_dimension * global_idx;
  var indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${S0(t.length,!0)}
  }
  ${C0(n,x.type.value,!0)}
  }`};return{name:"ScatterND",shaderCache:{hint:`${n.cacheKey}_${n.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:_}),getShaderSource:m}},yS=e=>kn({reduction:e.reduction}),vS=(e,n)=>{e.compute(f2(e.inputs,n),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}}),h2,p2,m2,P0,_2,g2,y2,v2,b2,w2,M2,x2,A0,T2,E2,S2,C2,P2,bS,wS,x$=ut(()=>{Bt(),en(),kr(),rn(),h2=(e,n)=>{if(e.every(t=>t>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(n.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(n.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},p2=(e,n,t)=>{n.every(i=>i>=0&&i<t||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let a=new Array(t).fill(1);return n.forEach((i,l)=>a[i]=e[l]),a},m2=(e,n,t,a,i,l)=>{let[u,d,f]=t>10?[1,2,3]:[-1,e.length>1?1:-1,-1],h=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(_=>l.push(_));else if(n.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(d>0&&e.length>d&&e[d].dims.length===1&&e[d].dims[0]>0){if(e[d].getFloat32Array().forEach(_=>a.push(_)),a.length!==0&&a.length!==h&&t>=18&&a.length!==n.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");h2(a,n),n.axes.length>0&&p2(a,n.axes,h).forEach((_,m)=>a[m]=_)}if(f>0&&e.length>f&&e[f].dims.length===1&&e[f].dims[0]>0&&(e[f].getBigInt64Array().forEach(_=>i.push(Number(_))),i.length!==0&&i.length!==h&&t>=18&&i.length!==n.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(n.axes.length>0){if(a.length!==0&&a.length!==n.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(i.length!==0&&i.length!==n.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof a<"u"&&typeof i<"u"&&a.length>0&&i.length>h)throw new Error("Resize requires only of scales or sizes to be specified")},P0=(e,n,t,a)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${e}) * (${n});
  let whole = ${a}(big / (${t}));
  let fract = ${a}(big % (${t})) / ${a}(${t});
  return whole + fract;
`,_2=(e,n)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${n} { `+(()=>{switch(e){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${n}(xResized) / ${n}(xScale);
          } else {
            ${P0("xResized","lengthOriginal","lengthResized",n)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${n}(xResized) + 0.5) / ${n}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${n}(xResized) + 0.5) / ${n}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${P0("xResized","lengthOriginal - 1","lengthResized - 1",n)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${n}(roiStart) * ${n}(lengthOriginal - 1) +
                        (${n}(xResized) * ${n}(roiEnd - roiStart) * ${n}(lengthOriginal - 1)) /
                        ${n}(lengthResized - 1);
                  } else {
                    return 0.5 * ${n}(roiStart + roiEnd) * ${n}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${n}xScale * ${n}(lengthResized);
                  const adjustment = ${n}(lengthResized) / outputWidth;
                  const center = ${n}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${n}(xResized) + 0.5) / ${n}(xScale)) - 0.5;`;case"half_pixel":return`return ((${n}(xResized) + 0.5) / ${n}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",g2=(e,n,t)=>`fn getNearestPixelFromOriginal(xOriginal: ${t}, isDownSample: bool) -> ${t} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(n<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",y2=(e,n,t)=>{let a=new Array(t).fill(0).concat(new Array(t).fill(1)),i=e.length===0?a:e.slice();return n.length>0?(n.forEach((l,u)=>{a[l]=i[u],a[u+t]=i[n.length+u]}),a):i},v2=(e,n,t,a)=>{let i=[];if(t.length>0)if(a.length>0){if(e.forEach(l=>i.push(l)),Math.max(...a)>e.length)throw new Error("axes is out of bound");a.forEach((l,u)=>i[l]=t[u])}else t.forEach(l=>i.push(l));else{if(n.length===0)throw new Error("Resize requires either scales or sizes.");i=e.map((l,u)=>Math.round(l*n[u]))}return i},b2=(e,n,t)=>{let a=(()=>{switch(t.keepAspectRatioPolicy){case"not_larger":return t.axes.length>0?Math.min(...t.axes.map(l=>n[l]),Number.MAX_VALUE):Math.min(...n,Number.MAX_VALUE);case"not_smaller":return t.axes.length>0?Math.max(...t.axes.map(l=>n[l]),Number.MIN_VALUE):Math.max(...n,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${t.keepAspectRatioPolicy} is not supported`)}})();n.fill(1,0,n.length);let i=e.slice();return t.axes.length>0?(t.axes.forEach(l=>n[l]=a),t.axes.forEach(l=>i[l]=Math.round(e[l]*n[l]))):(n.fill(a,0,n.length),i.forEach((l,u)=>i[u]=Math.round(l*n[u]))),i},w2=(e,n,t,a,i)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${t.length}> {
      var original_indices: array<${e.type.value}, ${t.length}>;
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var scale = ${Ot("uniforms.scales","i",a)};
        var roi_low = ${Ot("uniforms.roi","i",i)};
        var roi_hi = ${Ot("uniforms.roi",`i + ${n.length}`,i)};
        if (scale == 1.0) {
          original_indices[i] = ${e.type.value}(output_index);
        } else {
          var input_shape_i = ${Ot("uniforms.input_shape","i",n.length)};
          var output_shape_i = ${Ot("uniforms.output_shape","i",t.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,M2=(e,n,t,a,i,l,u)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${n.type.indices}) -> ${e.type.indices} {
      var input_indices: ${e.type.indices};
      for (var i:u32 = 0; i < ${a.length}; i++) {
        var output_index = ${n.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${Ot("uniforms.scales","i",i)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${Ot("uniforms.roi","i",l)};
          var roi_hi = ${Ot("uniforms.roi",`i + ${t.length}`,l)};
          var input_shape_i = ${Ot("uniforms.input_shape","i",t.length)};
          var output_shape_i = ${Ot("uniforms.output_shape","i",a.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${u} || (original_idx >= 0 && original_idx < ${n.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${n.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${e.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,x2=(e,n)=>`
    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var input_index = ${e.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${Ot("uniforms.input_shape","i",n.length)}) {
          return false;
        }
      }
      return true;
    }`,A0=(e,n,t,a)=>e.rank>a?`
    ${e.indicesSet("input_indices",n,"channel")};
    ${e.indicesSet("input_indices",t,"batch")};
`:"",T2=(e,n,t,a,i)=>{let[l,u,d,f]=t.length===2?[-1,0,1,-1]:[0,2,3,1],h=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${h} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",u,`max(0, min(row, ${t[u]} - 1))`)};
      ${e.indicesSet("input_indices",d,`max(0, min(col, ${t[d]} - 1))`)};
      ${A0(e,f,l,2)}
      return ${e.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${n.type.indices}) -> ${h} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${h} = originalIndices[${u}];
      var col:${h} = originalIndices[${d}];
      ${a?`if (row < 0 || row > (${t[u]} - 1) || col < 0 || col > (${t[d]} - 1)) {
        return ${i};
      }`:""};
      row = max(0, min(row, ${t[u]} - 1));
      col = max(0, min(col, ${t[d]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${t.length>2?`u32(originalIndices[${f}])`:"0"};
      var batch: u32 =  ${t.length>2?`u32(originalIndices[${l}])`:"0"};
      var x11: ${h} = getInputValue(batch, channel, row1, col1);
      var x12: ${h} = getInputValue(batch, channel, row1, col2);
      var x21: ${h} = getInputValue(batch, channel, row2, col1);
      var x22: ${h} = getInputValue(batch, channel, row2, col2);
      var dx1: ${h} = abs(row - ${h}(row1));
      var dx2: ${h} = abs(${h}(row2) - row);
      var dy1: ${h} = abs(col - ${h}(col1));
      var dy2: ${h} = abs(${h}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},E2=(e,n,t,a,i,l,u,d,f,h)=>{let _=t.length===2,[m,p]=_?[0,1]:[2,3],y=e.type.value,v=x=>{let L=x===m?"row":"col";return`
      fn ${L}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${n.type.indices}) -> ${y} {
        var output_index = ${n.indicesGet("output_indices",x)};
        var originalIdx: ${y} = getOriginalCoordinateFromResizedCoordinate(output_index, ${i[x]},
        ${a[x]}, ${t[x]}, ${l[x]}, ${l[x]} + ${t.length});
        var fractOriginalIdx: ${y} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${d} && (originalIdx < 0 || originalIdx > (${t[x]} - 1))) {
          return ${f};
        }
        var data: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${L}: ${y} = originalIdx + ${y}(i);
          if (${L} < 0 || ${L} >= ${t[x]}) {
            ${h?`coefs[i + 1] = 0.0;
                        continue;`:d?`return ${f};`:`${L} = max(0, min(${L}, ${t[x]} - 1));`};
          }
        var input_indices_copy: ${e.type.indices} = input_indices;
          ${e.indicesSet("input_indices_copy",x,`u32(${L})`)};
          data[i + 1] = ${x===m?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${v(m)};
    ${v(p)};
  fn getCubicInterpolationCoefs(s: ${y}) -> array<${y}, 4> {
    var absS = abs(s);
    var coeffs: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${y} = 1.0 - absS;
    var twoMinusAbsS: ${y} = 2.0 - absS;
    var onePlusAbsS: ${y} = 1.0 + absS;
    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};
    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;
    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${y}, 4>, coefs: array<${y}, 4>) -> ${y} {
    var coefsSum: ${y} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${n.type.indices}) -> ${y} {
    var input_indices: ${e.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},S2=(e,n,t,a,i)=>{let[l,u,d,f,h]=t.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],_=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${_} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",u,`max(0, min(depth, ${t[u]} - 1))`)};
      ${e.indicesSet("input_indices",d,`max(0, min(height, ${t[d]} - 1))`)};
      ${e.indicesSet("input_indices",f,`max(0, min(width, ${t[f]} - 1))`)};
      ${A0(e,h,l,3)}
      return ${e.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${n.type.indices}) -> ${_} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${_} = originalIndices[${u}];
      var height:${_} = originalIndices[${d}];
      var width:${_} = originalIndices[${f}];
      ${a?`if (depth < 0 || depth > (${t[u]} - 1) || height < 0 || height > (${t[d]} - 1) || width < 0 || (width > ${t[f]} - 1)) {
      return ${i};
        }`:""};

    depth = max(0, min(depth, ${t[u]} - 1));
      height = max(0, min(height, ${t[d]} - 1));
      width = max(0, min(width, ${t[f]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${t.length>3?`u32(originalIndices[${h}])`:"0"};
      var batch: u32 =  ${t.length>3?`u32(originalIndices[${l}])`:"0"};

      var x111: ${_} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${_} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${_} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${_} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${_} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${_} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${_} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${_} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${_} = abs(depth - ${_}(depth1));
      var dx2: ${_} = abs(${_}(depth2) - depth);
      var dy1: ${_} = abs(height - ${_}(height1));
      var dy2: ${_} = abs(${_}(height2) - height);
      var dz1: ${_} = abs(width - ${_}(width1));
      var dz2: ${_} = abs(${_}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},C2=(e,n,t,a,i,l)=>{let u=e.dims,d=y2(l,n.axes,u.length),f=v2(u,a,i,n.axes),h=a.slice();a.length===0&&(h=u.map((E,I)=>E===0?1:f[I]/E),n.keepAspectRatioPolicy!=="stretch"&&(f=b2(u,h,n)));let _=kt("output",e.dataType,f.length),m=qe("input",e.dataType,u.length),p=Be.size(f),y=u.length===f.length&&u.every((E,I)=>E===f[I]),v=n.coordinateTransformMode==="tf_crop_and_resize",x=n.extrapolationValue,L=m.type.value,T=E=>`
      ${y?"":`
      ${_2(n.coordinateTransformMode,L)};
      ${(()=>{switch(n.mode){case"nearest":return`
              ${x2(m,u)};
              ${g2(n.nearestMode,t,L)};
              ${M2(m,_,u,f,h.length,d.length,v)};
              `;case"linear":return`
              ${w2(_,u,f,h.length,d.length)};
              ${(()=>{if(u.length===2||u.length===4)return`${T2(m,_,u,v,x)}`;if(u.length===3||u.length===5)return`${S2(m,_,u,v,x)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(u.length===2||u.length===4)return`${E2(m,_,u,f,h,d,n.cubicCoeffA,v,n.extrapolationValue,n.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${E.registerUniform("output_size","u32").registerUniform("scales","f32",h.length).registerUniform("roi","f32",d.length).declareVariables(m,_)}
      ${E.mainStart()}
        ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${y?"output[global_idx] = input[global_idx];":`
        let output_indices = ${_.offsetToIndices("global_idx")};
        var input_indices: ${m.type.indices};
        ${(()=>{switch(n.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${m.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${n.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${u.length===2||u.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${n.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${n.cacheKey}|${t}|${h.length>0?n.mode==="cubic"?h:h.length:""}|${i.length>0?i:""}|${d.length>0?d:""}|${y}|${n.mode==="nearest"?u.length:u}`,inputDependencies:["rank"]},getShaderSource:T,getRunData:()=>({outputs:[{dims:f,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:[{type:12,data:p},{type:1,data:h},{type:1,data:d},...It(u,f)]})}},P2=e=>{let n=e.customDataBuffer;return new Uint32Array(n,n.byteOffset,1)[0]},bS=(e,n)=>{let t=[],a=[],i=[],l=P2(e);if(n.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");m2(e.inputs,n,l,t,a,i),e.compute(C2(e.inputs[0],n,l,t,a,i),{inputs:[0]})},wS=e=>{let n=e.antialias,t=e.axes,a=e.coordinateTransformMode,i=e.cubicCoeffA,l=e.excludeOutside!==0,u=e.extrapolationValue,d=e.keepAspectRatioPolicy,f=e.mode,h=e.nearestMode===""?"simple":e.nearestMode;return kn({antialias:n,axes:t,coordinateTransformMode:a,cubicCoeffA:i,excludeOutside:l,extrapolationValue:u,keepAspectRatioPolicy:d,mode:f,nearestMode:h})}}),A2,k2,MS,T$=ut(()=>{Bt(),en(),rn(),A2=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let n=e[0],t=e[1],a=e[2];if(n.dataType!==t.dataType||n.dataType!==a.dataType)throw new Error("All inputs must have the same data type");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Input must be 2D or 3D");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Skip must be 2D or 3D");let i=n.dims[n.dims.length-1],l=n.dims[n.dims.length-2];if(t.dims[t.dims.length-1]!==i)throw new Error("Skip must have the same hidden size as input");if(t.dims[t.dims.length-2]!==l)throw new Error("Skip must have the same sequence length as input");if(a.dims.length!==1)throw new Error("Gamma must be 1D");if(a.dims[a.dims.length-1]!==i)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==i)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==i)throw new Error("Bias must have the same hidden size as input")}},k2=(e,n,t,a)=>{let i=n.simplified,l=e[0].dims,u=Be.size(l),d=l,f=u,h=l.slice(-1)[0],_=a?l.slice(0,-1).concat(1):[],m=!i&&e.length>3,p=e.length>4,y=a&&t>1,v=a&&t>2,x=t>3,L=64,T=Tr(h),E=[{type:12,data:f},{type:12,data:T},{type:12,data:h},{type:1,data:n.epsilon}],I=S=>{let k=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],C=[qe("x",e[0].dataType,e[0].dims,T),qe("skip",e[1].dataType,e[1].dims,T),qe("gamma",e[2].dataType,e[2].dims,T)];m&&C.push(qe("beta",e[3].dataType,e[3].dims,T)),p&&C.push(qe("bias",e[4].dataType,e[4].dims,T)),C.push(kt("output",e[0].dataType,d,T)),y&&C.push(kt("mean_output",1,_)),v&&C.push(kt("inv_std_output",1,_)),x&&C.push(kt("input_skip_bias_sum",e[0].dataType,d,T));let D=ns(e[0].dataType),V=ns(1,T);return`

      ${S.registerUniforms(k).declareVariables(...C)}
      var<workgroup> sum_shared : array<${V}, ${L}>;
      var<workgroup> sum_squared_shared : array<${V}, ${L}>;

      ${S.mainStart([L,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${L};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${L};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${L-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${p?"bias[offset1d + i]":D+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${x?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${sf(D,T,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${L};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Kl("sum",T)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Kl("square_sum",T)} / f32(uniforms.hidden_size) ${i?"":"- mean * mean"} + uniforms.epsilon);
        ${y?"mean_output[global_idx] = mean;":""}
        ${v?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${i?"":`- ${D}(mean)`}) *
            ${D}(inv_std_dev) * gamma[offset1d + i]
            ${m?"+ beta[offset1d + i]":""};
        }
      }`},P=[{dims:d,dataType:e[0].dataType}];return t>1&&P.push({dims:_,dataType:1}),t>2&&P.push({dims:_,dataType:1}),t>3&&P.push({dims:l,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${T};${y};${v};${x}`,inputDependencies:e.map((S,k)=>"type")},getShaderSource:I,getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(f/h)},programUniforms:E})}},MS=(e,n)=>{A2(e.inputs);let t=[0];e.outputCount>1&&t.push(-3),e.outputCount>2&&t.push(-3),e.outputCount>3&&t.push(3),e.compute(k2(e.inputs,n,e.outputCount,!1),{outputs:t})}}),O2,Tp,$2,k0,D2,I2,xS,TS,E$=ut(()=>{Bt(),en(),kr(),rn(),O2=(e,n)=>{if(!e||e.length<1)throw new Error("too few inputs");if(n.axes.length!==0){if(n.axes.length!==n.starts.length||n.axes.length!==n.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(n.starts.length!==n.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((t,a)=>{if(e[a+1].dataType!==6&&e[a+1].dataType!==7)throw new Error(`Input ${a} must be an array of int32 or int64`)})},Tp=(e,n)=>{let t=[];if(e.length>n)if(e[n].dataType===7)e[n].getBigInt64Array().forEach(a=>t.push(Number(a)));else if(e[n].dataType===6)e[n].getInt32Array().forEach(a=>t.push(Number(a)));else throw new Error(`Input ${n} must be an array of int32 or int64`);return t},$2=(e,n)=>{if(e.length>1){let t=Tp(e,1),a=Tp(e,2),i=Tp(e,3);return i.length===0&&(i=[...Array(e[0].dims.length).keys()]),kn({starts:t,ends:a,axes:i})}else return n},k0=(e,n,t,a,i)=>{let l=e;return e<0&&(l+=t[a[n]]),i[n]<0?Math.max(0,Math.min(l,t[a[n]]-1)):Math.max(0,Math.min(l,t[a[n]]))},D2=(e,n,t)=>`fn calculateInputIndices(output_indices: ${n.type.indices}) -> ${e.type.indices} {
          var input_indices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${t.length}; i >= 0; i--) {
            let input_shape_i = ${Ot("uniforms.input_shape","i",t.length)};
            let steps_i = ${Ot("uniforms.steps","i",t.length)};
            let signs_i = ${Ot("uniforms.signs","i",t.length)};
            let starts_i = ${Ot("uniforms.starts","i",t.length)};
            var output_index = ${n.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${e.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,I2=(e,n)=>{let t=e[0].dims,a=Be.size(t),i=n.axes.length>0?Be.normalizeAxes(n.axes,t.length):[...Array(t.length).keys()],l=Tp(e,4);l.forEach(T=>T!==0||(()=>{throw new Error("step cannot be 0")})),l.length===0&&(l=Array(i.length).fill(1));let u=n.starts.map((T,E)=>k0(T,E,t,i,l)),d=n.ends.map((T,E)=>k0(T,E,t,i,l));if(i.length!==u.length||i.length!==d.length)throw new Error("start, ends and axes should have the same number of elements");if(i.length!==t.length)for(let T=0;T<t.length;++T)i.includes(T)||(u.splice(T,0,0),d.splice(T,0,t[T]),l.splice(T,0,1));let f=l.map(T=>Math.sign(T));l.forEach((T,E,I)=>{if(T<0){let P=(d[E]-u[E])/T,S=u[E],k=S+P*l[E];u[E]=k,d[E]=S,I[E]=-T}});let h=t.slice(0);i.forEach((T,E)=>{h[T]=Math.ceil((d[T]-u[T])/l[T])});let _={dims:h,dataType:e[0].dataType},m=kt("output",e[0].dataType,h.length),p=qe("input",e[0].dataType,e[0].dims.length),y=Be.size(h),v=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:u.length},{name:"signs",type:"i32",length:f.length},{name:"steps",type:"u32",length:l.length}],x=[{type:12,data:y},{type:12,data:u},{type:6,data:f},{type:12,data:l},...It(e[0].dims,h)],L=T=>`
      ${T.registerUniforms(v).declareVariables(p,m)}
        ${D2(p,m,t)}
        ${T.mainStart()}
          ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${m.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${m.setByOffset("global_idx",p.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${f.length}_${u.length}_${l.length}`,inputDependencies:["rank"]},getShaderSource:L,getRunData:()=>({outputs:[_],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:x})}},xS=(e,n)=>{O2(e.inputs,n);let t=$2(e.inputs,n);e.compute(I2(e.inputs,t),{inputs:[0]})},TS=e=>{let n=e.starts,t=e.ends,a=e.axes;return kn({starts:n,ends:t,axes:a})}}),L2,z2,ES,SS,S$=ut(()=>{Bt(),en(),kr(),ql(),rn(),L2=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},z2=(e,n)=>{let t=e.inputs[0],a=t.dims,i=Be.size(a),l=a.length,u=Be.normalizeAxis(n.axis,l),d=u<a.length-1,f,h=[];d?(h=Array.from({length:l},(C,D)=>D),h[u]=l-1,h[l-1]=u,f=e.compute(_a(t,h),{inputs:[t],outputs:[-1]})[0]):f=t;let _=f.dims,m=_[l-1],p=i/m,y=Tr(m),v=m/y,x=64;p===1&&(x=256);let L=(C,D)=>D===4?`max(max(${C}.x, ${C}.y), max(${C}.z, ${C}.w))`:D===2?`max(${C}.x, ${C}.y)`:D===3?`max(max(${C}.x, ${C}.y), ${C}.z)`:C,T=qe("x",f.dataType,f.dims,y),E=kt("result",f.dataType,f.dims,y),I=T.type.value,P=ns(f.dataType)==="f32"?`var threadMax = ${I}(-3.402823e+38f);`:`var threadMax = ${I}(-65504.0h);`,S=C=>`
      var<workgroup> rowMaxShared : ${I};
      var<workgroup> rowSumShared : ${I};
      var<workgroup> threadShared : array<${I}, ${x}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${I} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${I}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${C.registerUniform("packedCols","i32").declareVariables(T,E)}
      ${C.mainStart(x)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${x};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${P}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${I}(${L("threadShared[0]",y)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${I}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${I}(${Kl("threadShared[0]",y)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,k=e.compute({name:"Softmax",shaderCache:{hint:`${y};${x}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:_,dataType:f.dataType}],dispatchGroup:{x:p},programUniforms:[{type:6,data:v}]}),getShaderSource:S},{inputs:[f],outputs:[d?-1:0]})[0];d&&e.compute(_a(k,h),{inputs:[k]})},ES=(e,n)=>{L2(e.inputs),z2(e,n)},SS=e=>kn({axis:e.axis})}),O0,F2,R2,B2,CS,C$=ut(()=>{Bt(),en(),rn(),O0=e=>Array.from(e.getBigInt64Array(),Number),F2=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(O0(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},R2=(e,n)=>{let t=[];for(let a=0;a<e.length;++a)t.push(e[a]*n[a]);return t},B2=(e,n)=>{let t=e[0].dims,a=n??O0(e[1]),i=R2(t,a),l=Be.size(i),u=e[0].dataType,d=qe("input",u,t.length),f=kt("output",u,i.length),h=_=>`
      const inputShape = ${d.indices(...t)};
      ${_.registerUniform("output_size","u32").declareVariables(d,f)}
      ${_.mainStart()}
      ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${f.offsetToIndices("global_idx")};
      var input_indices: ${d.type.indices};
      for (var i = 0; i < ${t.length}; i++) {
        let input_dim_i = ${d.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${f.indicesGet("output_indices","i")}  % input_dim_i;

        ${d.indicesSet("input_indices","i","input_dim_value")}
      }
      ${f.setByOffset("global_idx",d.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${a}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:[{type:12,data:l},...It(e[0].dims,i)]}),getShaderSource:h}},CS=e=>{F2(e.inputs),e.compute(B2(e.inputs),{inputs:[0]})}}),j2,N2,PS,P$=ut(()=>{Bt(),en(),rn(),j2=(e,n,t,a,i)=>{let l=kt("output_data",i,t.length,4),u=qe("a_data",n[1].dataType,n[1].dims.length,4),d=qe("b_data",n[2].dataType,n[2].dims.length,4),f=qe("c_data",n[0].dataType,n[0].dims.length,4),h,_=(m,p,y)=>`select(${p}, ${m}, ${y})`;if(!a)h=l.setByOffset("global_idx",_(u.getByOffset("global_idx"),d.getByOffset("global_idx"),f.getByOffset("global_idx")));else{let m=(p,y,v="")=>{let x=`a_data[index_a${y}][component_a${y}]`,L=`b_data[index_b${y}][component_b${y}]`,T=`bool(c_data[index_c${y}] & (0xffu << (component_c${y} * 8)))`;return`
            let output_indices${y} = ${l.offsetToIndices(`global_idx * 4u + ${y}u`)};
            let offset_a${y} = ${u.broadcastedIndicesToOffset(`output_indices${y}`,l)};
            let offset_b${y} = ${d.broadcastedIndicesToOffset(`output_indices${y}`,l)};
            let offset_c${y} = ${f.broadcastedIndicesToOffset(`output_indices${y}`,l)};
            let index_a${y} = offset_a${y} / 4u;
            let index_b${y} = offset_b${y} / 4u;
            let index_c${y} = offset_c${y} / 4u;
            let component_a${y} = offset_a${y} % 4u;
            let component_b${y} = offset_b${y} % 4u;
            let component_c${y} = offset_c${y} % 4u;
            ${p}[${y}] = ${v}(${_(x,L,T)});
          `};i===9?h=`
            var data = vec4<u32>(0);
            ${m("data",0,"u32")}
            ${m("data",1,"u32")}
            ${m("data",2,"u32")}
            ${m("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:h=`
            ${m("output_data[global_idx]",0)}
            ${m("output_data[global_idx]",1)}
            ${m("output_data[global_idx]",2)}
            ${m("output_data[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(f,u,d,l)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${h}
      }`},N2=e=>{let n=e[1].dims,t=e[2].dims,a=e[0].dims,i=e[1].dataType,l=!(Be.areEqual(n,t)&&Be.areEqual(t,a)),u=n,d=Be.size(n);if(l){let h=of.calcShape(of.calcShape(n,t,!1),a,!1);if(!h)throw new Error("Can't perform where op on the given tensors");u=h,d=Be.size(u)}let f=Math.ceil(d/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:h=>j2(h,e,u,l,i),getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:12,data:f},...It(a,n,t,u)]})}},PS=e=>{e.compute(N2(e.inputs))}}),AS,A$=ut(()=>{VO(),Qy(),GO(),WO(),HO(),KO(),qO(),JO(),t$(),n$(),r$(),s$(),a$(),i$(),o$(),l$(),u$(),c$(),d$(),f$(),h$(),p$(),m$(),_$(),g$(),qE(),y$(),v$(),b$(),w$(),M$(),qy(),x$(),JE(),T$(),E$(),S$(),YE(),C$(),ql(),Xy(),P$(),AS=new Map([["Abs",[MT]],["Acos",[xT]],["Acosh",[TT]],["Add",[sE]],["ArgMax",[yT,uy]],["ArgMin",[gT,uy]],["Asin",[ET]],["Asinh",[ST]],["Atan",[CT]],["Atanh",[PT]],["Attention",[vT]],["AveragePool",[lS,oS]],["BatchNormalization",[bT]],["BiasAdd",[wT]],["BiasSplitGelu",[rE]],["Cast",[kT,AT]],["Ceil",[$T]],["Clip",[OT]],["Concat",[pE,mE]],["Conv",[my,py]],["ConvTranspose",[EE,TE]],["Cos",[DT]],["Cosh",[IT]],["CumSum",[SE,CE]],["DepthToSpace",[PE,AE]],["DequantizeLinear",[mS,_S]],["Div",[aE]],["Einsum",[kE,OE]],["Elu",[LT,kp]],["Equal",[iE]],["Erf",[zT]],["Exp",[FT]],["Expand",[$E]],["FastGelu",[DE]],["Floor",[RT]],["FusedConv",[my,py]],["Gather",[LE,IE]],["GatherElements",[NE,jE]],["GatherBlockQuantized",[RE,BE]],["GatherND",[zE,FE]],["Gelu",[BT]],["Gemm",[VE,UE]],["GlobalAveragePool",[cS,uS]],["GlobalMaxPool",[pS,hS]],["Greater",[cE]],["GreaterOrEqual",[fE]],["GridSample",[GE,WE]],["GroupQueryAttention",[eS]],["HardSigmoid",[KT,HT]],["InstanceNormalization",[tS]],["LayerNormalization",[nS]],["LeakyRelu",[jT,kp]],["Less",[dE]],["LessOrEqual",[hE]],["Log",[tE]],["MatMul",[rS]],["MatMulNBits",[sS,aS]],["MaxPool",[dS,fS]],["Mul",[oE]],["MultiHeadAttention",[KE,HE]],["Neg",[UT]],["Not",[NT]],["Pad",[iS]],["Pow",[lE]],["QuickGelu",[nE,kp]],["Range",[gS]],["Reciprocal",[VT]],["ReduceMin",[fT]],["ReduceMean",[oT]],["ReduceMax",[dT]],["ReduceSum",[pT]],["ReduceProd",[hT]],["ReduceL1",[lT]],["ReduceL2",[uT]],["ReduceLogSum",[_T]],["ReduceLogSumExp",[cT]],["ReduceSumSquare",[mT]],["Relu",[GT]],["Resize",[bS,wS]],["RotaryEmbedding",[ZE]],["ScatterND",[vS,yS]],["Sigmoid",[WT]],["Sin",[qT]],["Sinh",[QT]],["Slice",[xS,TS]],["SkipLayerNormalization",[MS]],["Split",[QE,XE]],["Sqrt",[XT]],["Softmax",[ES,SS]],["Sub",[uE]],["Tan",[YT]],["Tanh",[ZT]],["ThresholdedRelu",[eE,kp]],["Tile",[CS]],["Transpose",[Qx,Xx]],["Where",[PS]]])}),kS,k$=ut(()=>{Ti(),qo(),rn(),kS=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,n){this.repo.set(e,n)}run(e,n,t,a,i){xi(e.programInfo.name);let l=this.backend.device,u=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let d=[];for(let h of n)d.push({binding:d.length,resource:{buffer:h.buffer}});for(let h of t)d.push({binding:d.length,resource:{buffer:h.buffer}});i&&d.push({binding:d.length,resource:i});let f=l.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:d,label:e.programInfo.name});if(this.backend.sessionStatus==="capturing"){let h={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:f,dispatchGroup:a};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(h)}u.setPipeline(e.computePipeline),u.setBindGroup(0,f),u.dispatchWorkgroups(...a),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Ba(e.programInfo.name)}dispose(){}build(e,n){xi(e.name);let t=this.backend.device,a=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(h=>{t.features.has(h.feature)&&a.push(`enable ${h.extension};`)});let i=qx(n,this.backend.device.limits),l=e.getShaderSource(i),u=`${a.join(`
`)}
${i.additionalImplementations}
${l}`,d=t.createShaderModule({code:u,label:e.name});mn("verbose",()=>`[WebGPU] ${e.name} shader code: ${u}`);let f=t.createComputePipeline({compute:{module:d,entryPoint:"main"},layout:"auto",label:e.name});return Ba(e.name),{programInfo:e,computePipeline:f,uniformVariablesInfo:i.variablesInfo}}normalizeDispatchGroupSize(e){let n=typeof e=="number"?e:e.x,t=typeof e=="number"?1:e.y||1,a=typeof e=="number"?1:e.z||1,i=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(n<=i&&t<=i&&a<=i)return[n,t,a];let l=n*t*a,u=Math.ceil(Math.sqrt(l));if(u>i){if(u=Math.ceil(Math.cbrt(l)),u>i)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[u,u,u]}else return[u,u,1]}}}),OS={};df(OS,{WebGpuBackend:()=>$S});var U2,V2,G2,$S,O$=ut(()=>{Ti(),Bt(),qo(),Vx(),NO(),A$(),k$(),U2=(e,n)=>{if(n.length!==e.length)throw new Error(`inputDependencies length ${n.length} is not equal to inputTensors length ${e.length}.`);let t=[];for(let a=0;a<e.length;++a){let i=e[a].dataType;switch(n[a]){case"none":{t.push("");break}case"type":{t.push(`${i}`);break}case"rank":{let l=e[a].dims.length;t.push(`${i};${l}`);break}case"dims":{let l=e[a].dims.join(",");t.push(`${i};${l}`);break}default:throw new Error(`unsupported input dependency: ${n[a]}`)}}return t.join("|")},V2=(e,n,t)=>{let a=e.name;return e.shaderCache?.hint&&(a+="["+e.shaderCache.hint+"]"),a+=":"+t+`:${U2(n,e.shaderCache?.inputDependencies??new Array(n.length).fill("dims"))}`,a},G2=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},$S=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,n){this.env=e;let t=[],a={requiredLimits:{maxComputeWorkgroupStorageSize:n.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:n.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:n.limits.maxStorageBufferBindingSize,maxBufferSize:n.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:n.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:n.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:n.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:n.limits.maxComputeWorkgroupSizeZ},requiredFeatures:t},i=l=>n.features.has(l)&&t.push(l)&&!0;i("chromium-experimental-timestamp-query-inside-passes")||i("timestamp-query"),i("shader-f16"),i("subgroups"),this.device=await n.requestDevice(a),this.adapterInfo=new G2(n.info||await n.requestAdapterInfo()),this.gpuDataManager=Hx(this),this.programManager=new kS(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Gy(e.logLevel,!!e.debug),this.device.onuncapturederror=l=>{l.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${l.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:n,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),n={};this.queryType==="at-passes"&&(n.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=e.beginComputePass(n)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;xi(),this.endComputePass();let e;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),e=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&e.mapAsync(GPUMapMode.READ).then(()=>{let n=new BigUint64Array(e.getMappedRange()),t=this.pendingQueries.get(e);for(let a=0;a<n.length/2;a++){let i=t[a],l=i.kernelId,u=this.kernels.get(l),d=u.kernelType,f=u.kernelName,h=i.programName,_=i.inputTensorViews,m=i.outputTensorViews,p=n[a*2],y=n[a*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=p);let v=Number(p-this.queryTimeBase),x=Number(y-this.queryTimeBase);if(!Number.isSafeInteger(v)||!Number.isSafeInteger(x))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:_.map(L=>({dims:L.dims,dataType:Vo(L.dataType)})),outputsMetadata:m.map(L=>({dims:L.dims,dataType:Vo(L.dataType)})),kernelId:l,kernelType:d,kernelName:f,programName:h,startTime:v,endTime:x});else{let L="";_.forEach((E,I)=>{L+=`input[${I}]: [${E.dims}] | ${Vo(E.dataType)}, `});let T="";m.forEach((E,I)=>{T+=`output[${I}]: [${E.dims}] | ${Vo(E.dataType)}, `}),console.log(`[profiling] kernel "${l}|${d}|${f}|${h}" ${L}${T}execution time: ${x-v} ns`)}Bp("GPU",`${h}::${p}::${y}`)}e.unmap(),this.pendingQueries.delete(e)}),Ba()}run(e,n,t,a,i,l){xi(e.name);let u=[];for(let E=0;E<n.length;++E){let I=n[E].data;if(I===0)continue;let P=this.gpuDataManager.get(I);if(!P)throw new Error(`no GPU data for input: ${I}`);u.push(P)}let{outputs:d,dispatchGroup:f,programUniforms:h}=e.getRunData(n),_=t.length===0?d.map((E,I)=>I):t;if(_.length!==d.length)throw new Error(`Output size ${_.length} must be equal to ${d.length}.`);let m=[],p=[];for(let E=0;E<d.length;++E){if(!Number.isInteger(_[E])||_[E]<-3||_[E]>=l)throw new Error(`Invalid output index: ${_[E]}`);if(_[E]===-3)continue;let I=_[E]===-1,P=_[E]===-2,S=I||P?i(d[E].dataType,d[E].dims):a(_[E],d[E].dataType,d[E].dims);if(m.push(S),S.data===0)continue;let k=this.gpuDataManager.get(S.data);if(!k)throw new Error(`no GPU data for output: ${S.data}`);if(I&&this.temporaryData.push(k),P){let C=this.kernelPersistentData.get(this.currentKernelId);C||(C=[],this.kernelPersistentData.set(this.currentKernelId,C)),C.push(k)}p.push(k)}if(u.length!==n.length||p.length!==m.length){if(p.length===0)return Ba(e.name),m;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let y;if(h){let E=0,I=[];h.forEach(C=>{let D=typeof C.data=="number"?[C.data]:C.data;if(D.length===0)return;let V=C.type===10?2:4,U,ne;C.type===10?(ne=D.length>4?16:D.length>2?8:D.length*V,U=D.length>4?16:V*D.length):(ne=D.length<=2?D.length*V:16,U=16),E=Math.ceil(E/ne)*ne,I.push(E);let ee=C.type===10?8:4;E+=D.length>4?Math.ceil(D.length/ee)*U:D.length*V});let P=16;E=Math.ceil(E/P)*P;let S=new ArrayBuffer(E);h.forEach((C,D)=>{let V=I[D],U=typeof C.data=="number"?[C.data]:C.data;if(C.type===6)new Int32Array(S,V,U.length).set(U);else if(C.type===12)new Uint32Array(S,V,U.length).set(U);else if(C.type===10)new Uint16Array(S,V,U.length).set(U);else if(C.type===1)new Float32Array(S,V,U.length).set(U);else throw new Error(`Unsupported uniform type: ${Vo(C.type)}`)});let k=this.gpuDataManager.create(E,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(k.buffer,0,S,0,E),this.gpuDataManager.release(k.id),y={offset:0,size:E,buffer:k.buffer}}let v=this.programManager.normalizeDispatchGroupSize(f),x=v[1]===1&&v[2]===1,L=V2(e,n,x),T=this.programManager.getArtifact(L);if(T||(T=this.programManager.build(e,v),this.programManager.setArtifact(L,T),mn("info",()=>`[artifact] key: ${L}, programName: ${e.name}`)),h&&T.uniformVariablesInfo){if(h.length!==T.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${T.uniformVariablesInfo.length}, got ${h.length} in program "${T.programInfo.name}".`);for(let E=0;E<h.length;E++){let I=h[E],P=I.type,S=typeof I.data=="number"?1:I.data.length,[k,C]=T.uniformVariablesInfo[E];if(P!==k||S!==C)throw new Error(`Uniform variable ${E} mismatch: expect type ${k} with size ${C}, got type ${P} with size ${S} in program "${T.programInfo.name}".`)}}if(mn("info",()=>`[ProgramManager] run "${e.name}" (key=${L}) with ${v[0]}x${v[1]}x${v[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let E={kernelId:this.currentKernelId,programName:T.programInfo.name,inputTensorViews:n,outputTensorViews:m};this.pendingKernels.push(E),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(E)}return this.programManager.run(T,u,p,v,y),Ba(e.name),m}upload(e,n){this.gpuDataManager.upload(e,n)}memcpy(e,n){this.gpuDataManager.memcpy(e,n)}async download(e,n){await this.gpuDataManager.download(e,n)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,n,t,a){let i=AS.get(e);if(!i)throw new Error(`kernel not implemented: ${e}`);let l={kernelType:e,kernelName:a,kernelEntry:i[0],attributes:[i[1],t]};this.kernels.set(n,l)}releaseKernel(e){let n=this.kernelPersistentData.get(e);if(n){for(let t of n)this.gpuDataManager.release(t.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,n,t){let a=this.kernels.get(e);if(!a)throw new Error(`kernel not created: ${e}`);let i=a.kernelType,l=a.kernelName,u=a.kernelEntry,d=a.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${i}] ${l}" is not allowed to be called recursively`);this.currentKernelId=e,d[0]&&(d[1]=d[0](d[1]),d[0]=void 0),mn("info",()=>`[WebGPU] Start to run kernel "[${i}] ${l}"...`);let f=this.env.debug;this.temporaryData=[];try{return f&&this.device.pushErrorScope("validation"),u(n,d[1]),0}catch(h){return t.push(Promise.resolve(`[WebGPU] Kernel "[${i}] ${l}" failed. ${h}`)),1}finally{f&&t.push(this.device.popErrorScope().then(h=>h?`GPU validation error for kernel "[${i}] ${l}": ${h.message}`:null));for(let h of this.temporaryData)this.gpuDataManager.release(h.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,n,t,a){let i=this.sessionExternalDataMapping.get(e);i||(i=new Map,this.sessionExternalDataMapping.set(e,i));let l=i.get(n),u=this.gpuDataManager.registerExternalBuffer(t,a,l);return i.set(n,[u,t]),u}unregisterBuffers(e){let n=this.sessionExternalDataMapping.get(e);n&&(n.forEach(t=>this.gpuDataManager.unregisterExternalBuffer(t[0])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let n=this.gpuDataManager.get(e);if(!n)throw new Error(`no GPU data for buffer: ${e}`);return n.buffer}createDownloader(e,n,t){return async()=>{let a=await iy(this,e,n);return Wy(a.buffer,t)}}writeTimestamp(e){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){mn("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){mn("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){mn("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),n=this.capturedPendingKernels.get(this.currentSessionId),t=e.length;this.pendingKernels=[];for(let a=0;a<t;a++){let i=this.getComputePassEncoder(),l=e[a];this.writeTimestamp(this.pendingDispatchNumber*2),i.setPipeline(l.computePipeline),i.setBindGroup(0,l.bindGroup),i.dispatchWorkgroups(...l.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(n[a]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}}),DS={};df(DS,{init:()=>IS});var a_,W2,IS,$$=ut(()=>{Bt(),qo(),en(),jO(),a_=class LS{constructor(n,t,a,i){this.module=n,this.dataType=t,this.data=a,this.dims=i}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let n=Be.size(this.dims);return n===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,n)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let n=Be.size(this.dims);return n===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,n)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let n=Be.size(this.dims);return n===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,n)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let n=Be.size(this.dims);return n===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,n)}reshape(n){if(Be.size(n)!==Be.size(this.dims))throw new Error("Invalid new shape");return new LS(this.module,this.dataType,this.data,n)}},W2=class{constructor(e,n,t){this.module=e,this.backend=n,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=n.adapterInfo;let a=e.PTR_SIZE,i=t/e.PTR_SIZE,l=a===4?"i32":"i64";this.opKernelContext=Number(e.getValue(a*i++,l));let u=Number(e.getValue(a*i++,l));this.outputCount=Number(e.getValue(a*i++,l)),this.customDataOffset=Number(e.getValue(a*i++,"*")),this.customDataSize=Number(e.getValue(a*i++,l));let d=[];for(let f=0;f<u;f++){let h=Number(e.getValue(a*i++,l)),_=Number(e.getValue(a*i++,"*")),m=Number(e.getValue(a*i++,l)),p=[];for(let y=0;y<m;y++)p.push(Number(e.getValue(a*i++,l)));d.push(new a_(e,h,_,p))}this.inputs=d}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,n){let t=n?.inputs?.map(u=>typeof u=="number"?this.inputs[u]:u)??this.inputs,a=n?.outputs??[],i=(u,d,f)=>new a_(this.module,d,this.output(u,f),f),l=(u,d)=>{let f=vc(u,d);if(!f)throw new Error(`Unsupported data type: ${u}`);let h=f>0?this.backend.gpuDataManager.create(f).id:0;return new a_(this.module,u,h,d)};return this.backend.run(e,t,a,i,l,this.outputCount)}output(e,n){let t=this.module.stackSave();try{let a=this.module.PTR_SIZE,i=a===4?"i32":"i64",l=this.module.stackAlloc((1+n.length)*a);this.module.setValue(l,n.length,i);for(let u=0;u<n.length;u++)this.module.setValue(l+a*(u+1),n[u],i);return this.module._JsepOutput(this.opKernelContext,e,l)}catch(a){throw new Error(`Failed to generate kernel's output[${e}] with dims [${n}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${a}`)}finally{this.module.stackRestore(t)}}},IS=async(e,n,t,a)=>{let i=n.jsepInit;if(!i)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(e==="webgpu"){let l=(O$(),Rp(OS)).WebGpuBackend,u=new l;await u.initialize(t,a),i("webgpu",[u,d=>u.alloc(Number(d)),d=>u.free(d),(d,f,h,_=!1)=>{if(_)mn("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(d)}, dst=${Number(f)}, size=${Number(h)}`),u.memcpy(Number(d),Number(f));else{mn("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(d)}, gpuDataId=${Number(f)}, size=${Number(h)}`);let m=n.HEAPU8.subarray(Number(d>>>0),Number(d>>>0)+Number(h));u.upload(Number(f),m)}},async(d,f,h)=>{mn("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${d}, dataOffset=${f}, size=${h}`),await u.download(Number(d),()=>n.HEAPU8.subarray(Number(f)>>>0,Number(f+h)>>>0))},(d,f,h)=>u.createKernel(d,Number(f),h,n.UTF8ToString(n._JsepGetNodeName(Number(f)))),d=>u.releaseKernel(d),(d,f,h,_)=>{mn("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${h}, kernel=${d}, contextDataOffset=${f}`);let m=new W2(n,u,Number(f));return u.computeKernel(Number(d),m,_)},()=>u.captureBegin(),()=>u.captureEnd(),()=>u.replay()])}else{let l=new Wx(t);i("webnn",[l,()=>l.reserveTensorId(),u=>l.releaseTensorId(u),async(u,d,f,h,_)=>l.ensureTensor(u,d,f,h,_),(u,d)=>{l.uploadTensor(u,d)},async(u,d)=>l.downloadTensor(u,d)])}}}),H2,nv,rv,jl,K2,$0,P_,sv,av,D0,iv,ov,lv,zS=ut(()=>{FO(),RO(),Bt(),Ec(),By(),Bx(),H2=(e,n)=>{Xn()._OrtInit(e,n)!==0&&Rn("Can't initialize onnxruntime.")},nv=async e=>{H2(e.wasm.numThreads,x_(e.logLevel))},rv=async(e,n)=>{Xn().asyncInit?.();{let t=($$(),Rp(DS)).init;if(n==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let a=e.webgpu.adapter;if(a){if(typeof a.limits!="object"||typeof a.features!="object"||typeof a.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let i=e.webgpu.powerPreference;if(i!==void 0&&i!=="low-power"&&i!=="high-performance")throw new Error(`Invalid powerPreference setting: "${i}"`);let l=e.webgpu.forceFallbackAdapter;if(l!==void 0&&typeof l!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${l}"`);if(a=await navigator.gpu.requestAdapter({powerPreference:i,forceFallbackAdapter:l}),!a)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await t("webgpu",Xn(),e,a)}if(n==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await t("webnn",Xn(),e)}}},jl=new Map,K2=e=>{let n=Xn(),t=n.stackSave();try{let a=n.PTR_SIZE,i=n.stackAlloc(2*a);n._OrtGetInputOutputCount(e,i,i+a)!==0&&Rn("Can't get session input/output count.");let l=a===4?"i32":"i64";return[Number(n.getValue(i,l)),Number(n.getValue(i+a,l))]}finally{n.stackRestore(t)}},$0=(e,n)=>{let t=Xn(),a=t.stackSave(),i=0;try{let l=t.PTR_SIZE,u=t.stackAlloc(2*l);t._OrtGetInputOutputMetadata(e,n,u,u+l)!==0&&Rn("Can't get session input/output metadata.");let d=Number(t.getValue(u,"*"));i=Number(t.getValue(u+l,"*"));let f=t.HEAP32[i/4];if(f===0)return[d,0];let h=t.HEAPU32[i/4+1],_=[];for(let m=0;m<h;m++){let p=Number(t.getValue(i+8+m*l,"*"));_.push(p!==0?t.UTF8ToString(p):Number(t.getValue(i+8+(m+h)*l,"*")))}return[d,f,_]}finally{t.stackRestore(a),i!==0&&t._OrtFree(i)}},P_=e=>{let n=Xn(),t=n._malloc(e.byteLength);if(t===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return n.HEAPU8.set(e,t),[t,e.byteLength]},sv=async(e,n)=>{let t,a,i=Xn();Array.isArray(e)?[t,a]=e:e.buffer===i.HEAPU8.buffer?[t,a]=[e.byteOffset,e.byteLength]:[t,a]=P_(e);let l=0,u=0,d=0,f=[],h=[],_=[];try{if([u,f]=await Rx(n),n?.externalData&&i.mountExternalData){let P=[];for(let S of n.externalData){let k=typeof S=="string"?S:S.path;P.push(Vy(typeof S=="string"?S:S.data).then(C=>{i.mountExternalData(k,C)}))}await Promise.all(P)}for(let P of n?.executionProviders??[])if((typeof P=="string"?P:P.name)==="webnn"){if(i.shouldTransferToMLTensor=!1,typeof P!="string"){let S=P,k=S?.context,C=S?.gpuDevice,D=S?.deviceType,V=S?.powerPreference;k?i.currentContext=k:C?i.currentContext=await i.webnnCreateMLContext(C):i.currentContext=await i.webnnCreateMLContext({deviceType:D,powerPreference:V})}else i.currentContext=await i.webnnCreateMLContext();break}l=await i._OrtCreateSession(t,a,u),i.webgpuOnCreateSession?.(l),l===0&&Rn("Can't create a session."),i.jsepOnCreateSession?.(),i.currentContext&&(i.webnnRegisterMLContext(l,i.currentContext),i.currentContext=void 0,i.shouldTransferToMLTensor=!0);let[m,p]=K2(l),y=!!n?.enableGraphCapture,v=[],x=[],L=[],T=[],E=[];for(let P=0;P<m;P++){let[S,k,C]=$0(l,P);S===0&&Rn("Can't get an input name."),h.push(S);let D=i.UTF8ToString(S);v.push(D),L.push(k===0?{name:D,isTensor:!1}:{name:D,isTensor:!0,type:Vo(k),shape:C})}for(let P=0;P<p;P++){let[S,k,C]=$0(l,P+m);S===0&&Rn("Can't get an output name."),_.push(S);let D=i.UTF8ToString(S);x.push(D),T.push(k===0?{name:D,isTensor:!1}:{name:D,isTensor:!0,type:Vo(k),shape:C});{if(y&&n?.preferredOutputLocation===void 0){E.push("gpu-buffer");continue}let V=typeof n?.preferredOutputLocation=="string"?n.preferredOutputLocation:n?.preferredOutputLocation?.[D]??"cpu";if(V!=="cpu"&&V!=="cpu-pinned"&&V!=="gpu-buffer"&&V!=="ml-tensor")throw new Error(`Not supported preferred output location: ${V}.`);if(y&&V!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${V}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);E.push(V)}}let I=null;return E.some(P=>P==="gpu-buffer"||P==="ml-tensor")&&(d=i._OrtCreateBinding(l),d===0&&Rn("Can't create IO binding."),I={handle:d,outputPreferredLocations:E,outputPreferredLocationsEncoded:E.map(P=>sy(P))}),jl.set(l,[l,h,_,I,y,!1]),[l,v,x,L,T]}catch(m){throw h.forEach(p=>i._OrtFree(p)),_.forEach(p=>i._OrtFree(p)),d!==0&&i._OrtReleaseBinding(d)!==0&&Rn("Can't release IO binding."),l!==0&&i._OrtReleaseSession(l)!==0&&Rn("Can't release session."),m}finally{i._free(t),u!==0&&i._OrtReleaseSessionOptions(u)!==0&&Rn("Can't release session options."),f.forEach(m=>i._free(m)),i.unmountExternalData?.()}},av=e=>{let n=Xn(),t=jl.get(e);if(!t)throw new Error(`cannot release session. invalid session id: ${e}`);let[a,i,l,u,d]=t;u&&(d&&n._OrtClearBoundOutputs(u.handle)!==0&&Rn("Can't clear bound outputs."),n._OrtReleaseBinding(u.handle)!==0&&Rn("Can't release IO binding.")),n.jsepOnReleaseSession?.(e),n.webnnOnReleaseSession?.(e),n.webgpuOnReleaseSession?.(e),i.forEach(f=>n._OrtFree(f)),l.forEach(f=>n._OrtFree(f)),n._OrtReleaseSession(a)!==0&&Rn("Can't release session."),jl.delete(e)},D0=async(e,n,t,a,i,l,u=!1)=>{if(!e){n.push(0);return}let d=Xn(),f=d.PTR_SIZE,h=e[0],_=e[1],m=e[3],p=m,y,v;if(h==="string"&&(m==="gpu-buffer"||m==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(u&&m!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${l} when enableGraphCapture is true.`);if(m==="gpu-buffer"){let T=e[2].gpuBuffer;v=vc(nf(h),_);{let E=d.jsepRegisterBuffer;if(!E)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');y=E(a,l,T,v)}}else if(m==="ml-tensor"){let T=e[2].mlTensor;v=vc(nf(h),_);let E=d.webnnRegisterMLTensor;if(!E)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');y=E(a,T,nf(h),_)}else{let T=e[2];if(Array.isArray(T)){v=f*T.length,y=d._malloc(v),t.push(y);for(let E=0;E<T.length;E++){if(typeof T[E]!="string")throw new TypeError(`tensor data at index ${E} is not a string`);d.setValue(y+E*f,yi(T[E],t),"*")}}else{let E=d.webnnIsGraphInput;if(h!=="string"&&E){let I=d.UTF8ToString(i);if(E(a,I)){let P=nf(h);v=vc(P,_),p="ml-tensor";let S=d.webnnCreateTemporaryTensor,k=d.webnnUploadTensor;if(!S||!k)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let C=await S(a,P,_);k(C,new Uint8Array(T.buffer,T.byteOffset,T.byteLength)),y=C}else v=T.byteLength,y=d._malloc(v),t.push(y),d.HEAPU8.set(new Uint8Array(T.buffer,T.byteOffset,v),y)}else v=T.byteLength,y=d._malloc(v),t.push(y),d.HEAPU8.set(new Uint8Array(T.buffer,T.byteOffset,v),y)}}let x=d.stackSave(),L=d.stackAlloc(4*_.length);try{_.forEach((E,I)=>d.setValue(L+I*f,E,f===4?"i32":"i64"));let T=d._OrtCreateTensor(nf(h),y,v,L,_.length,sy(p));T===0&&Rn(`Can't create tensor for input/output. session=${a}, index=${l}.`),n.push(T)}finally{d.stackRestore(x)}},iv=async(e,n,t,a,i,l)=>{let u=Xn(),d=u.PTR_SIZE,f=jl.get(e);if(!f)throw new Error(`cannot run inference. invalid session id: ${e}`);let h=f[0],_=f[1],m=f[2],p=f[3],y=f[4],v=f[5],x=n.length,L=a.length,T=0,E=[],I=[],P=[],S=[],k=u.stackSave(),C=u.stackAlloc(x*d),D=u.stackAlloc(x*d),V=u.stackAlloc(L*d),U=u.stackAlloc(L*d);try{[T,E]=Fx(l);for(let H=0;H<x;H++)await D0(t[H],I,S,e,_[n[H]],n[H],y);for(let H=0;H<L;H++)await D0(i[H],P,S,e,m[a[H]],x+a[H],y);for(let H=0;H<x;H++)u.setValue(C+H*d,I[H],"*"),u.setValue(D+H*d,_[n[H]],"*");for(let H=0;H<L;H++)u.setValue(V+H*d,P[H],"*"),u.setValue(U+H*d,m[a[H]],"*");if(p&&!v){let{handle:H,outputPreferredLocations:oe,outputPreferredLocationsEncoded:ae}=p;if(_.length!==x)throw new Error(`input count from feeds (${x}) is expected to be always equal to model's input count (${_.length}).`);for(let W=0;W<x;W++){let te=n[W];await u._OrtBindInput(H,_[te],I[W])!==0&&Rn(`Can't bind input[${W}] for session=${e}.`)}for(let W=0;W<L;W++){let te=a[W];i[W]?.[3]?u._OrtBindOutput(H,m[te],P[W],0)!==0&&Rn(`Can't bind pre-allocated output[${W}] for session=${e}.`):u._OrtBindOutput(H,m[te],0,ae[te])!==0&&Rn(`Can't bind output[${W}] to ${oe[W]} for session=${e}.`)}jl.set(e,[h,_,m,p,y,!0])}u.jsepOnRunStart?.(h),u.webnnOnRunStart?.(h);let ne;p?ne=await u._OrtRunWithBinding(h,p.handle,L,V,T):ne=await u._OrtRun(h,D,C,x,U,L,V,T),ne!==0&&Rn("failed to call OrtRun().");let ee=[];for(let H=0;H<L;H++){let oe=Number(u.getValue(V+H*d,"*"));if(oe===P[H]){ee.push(i[H]);continue}let ae=u.stackSave(),W=u.stackAlloc(4*d),te=!1,ie,_e=0;try{u._OrtGetTensorData(oe,W,W+d,W+2*d,W+3*d)!==0&&Rn(`Can't access output tensor data on index ${H}.`);let q=d===4?"i32":"i64",B=Number(u.getValue(W,q));_e=u.getValue(W+d,"*");let R=u.getValue(W+d*2,"*"),Q=Number(u.getValue(W+d*3,q)),G=[];for(let ze=0;ze<Q;ze++)G.push(Number(u.getValue(R+ze*d,q)));u._OrtFree(R)!==0&&Rn("Can't free memory for tensor dims.");let fe=G.reduce((ze,Ue)=>ze*Ue,1);ie=Vo(B);let Te=p?.outputPreferredLocations[a[H]];if(ie==="string"){if(Te==="gpu-buffer"||Te==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let ze=[];for(let Ue=0;Ue<fe;Ue++){let ft=u.getValue(_e+Ue*d,"*"),je=u.getValue(_e+(Ue+1)*d,"*"),le=Ue===fe-1?void 0:je-ft;ze.push(u.UTF8ToString(ft,le))}ee.push([ie,G,ze,"cpu"])}else if(Te==="gpu-buffer"&&fe>0){let ze=u.jsepGetBuffer;if(!ze)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Ue=ze(_e),ft=vc(B,fe);if(ft===void 0||!Ny(ie))throw new Error(`Unsupported data type: ${ie}`);te=!0,ee.push([ie,G,{gpuBuffer:Ue,download:u.jsepCreateDownloader(Ue,ft,ie),dispose:()=>{u._OrtReleaseTensor(oe)!==0&&Rn("Can't release tensor.")}},"gpu-buffer"])}else if(Te==="ml-tensor"&&fe>0){let ze=u.webnnEnsureTensor,Ue=u.webnnIsInt64Supported;if(!ze||!Ue)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(vc(B,fe)===void 0||!Uy(ie))throw new Error(`Unsupported data type: ${ie}`);if(ie==="int64"&&!Ue(e))throw new Error('preferredLocation "ml-tensor" for int64 output is not supported by current WebNN Context.');let ft=await ze(e,_e,B,G,!1);te=!0,ee.push([ie,G,{mlTensor:ft,download:u.webnnCreateMLTensorDownloader(_e,ie),dispose:()=>{u.webnnReleaseTensorId(_e),u._OrtReleaseTensor(oe)}},"ml-tensor"])}else{let ze=jy(ie),Ue=new ze(fe);new Uint8Array(Ue.buffer,Ue.byteOffset,Ue.byteLength).set(u.HEAPU8.subarray(_e,_e+Ue.byteLength)),ee.push([ie,G,Ue,"cpu"])}}finally{u.stackRestore(ae),ie==="string"&&_e&&u._free(_e),te||u._OrtReleaseTensor(oe),u.webnnOnRunEnd?.(h)}}return p&&!y&&(u._OrtClearBoundOutputs(p.handle)!==0&&Rn("Can't clear bound outputs."),jl.set(e,[h,_,m,p,y,!1])),ee}finally{u.stackRestore(k),I.forEach(ne=>u._OrtReleaseTensor(ne)),P.forEach(ne=>u._OrtReleaseTensor(ne)),S.forEach(ne=>u._free(ne)),T!==0&&u._OrtReleaseRunOptions(T),E.forEach(ne=>u._free(ne))}},ov=e=>{let n=Xn(),t=jl.get(e);if(!t)throw new Error("invalid session id");let a=t[0],i=n._OrtEndProfiling(a);i===0&&Rn("Can't get an profile file name."),n._OrtFree(i)},lv=e=>{let n=[];for(let t of e){let a=t[2];!Array.isArray(a)&&"buffer"in a&&n.push(a.buffer)}return n}}),Nl,La,Zd,Ep,Sp,i_,I0,o_,mc,_c,q2,FS,RS,BS,jS,NS,US,VS,GS=ut(()=>{Ti(),zS(),Ec(),Fy(),Nl=()=>!!Jn.wasm.proxy&&typeof document<"u",Zd=!1,Ep=!1,Sp=!1,o_=new Map,mc=(e,n)=>{let t=o_.get(e);t?t.push(n):o_.set(e,[n])},_c=()=>{if(Zd||!Ep||Sp||!La)throw new Error("worker not ready")},q2=e=>{switch(e.data.type){case"init-wasm":Zd=!1,e.data.err?(Sp=!0,I0[1](e.data.err)):(Ep=!0,I0[0]()),i_&&(URL.revokeObjectURL(i_),i_=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let n=o_.get(e.data.type);e.data.err?n.shift()[1](e.data.err):n.shift()[0](e.data.out);break}}},FS=async()=>{if(!Ep){if(Zd)throw new Error("multiple calls to 'initWasm()' detected.");if(Sp)throw new Error("previous call to 'initWasm()' failed.");if(Zd=!0,Nl())return new Promise((e,n)=>{La?.terminate(),Lx().then(([t,a])=>{try{La=a,La.onerror=l=>n(l),La.onmessage=q2,I0=[e,n];let i={type:"init-wasm",in:Jn};!i.in.wasm.wasmPaths&&(t||ry)&&(i.in.wasm.wasmPaths={wasm:new URL("/BG-REMOVAL/assets/ort-wasm-simd-threaded.jsep-B0T3yYHD.wasm",import.meta.url).href}),La.postMessage(i),i_=t}catch(i){n(i)}},n)});try{await Ry(Jn.wasm),await nv(Jn),Ep=!0}catch(e){throw Sp=!0,e}finally{Zd=!1}}},RS=async e=>{if(Nl())return _c(),new Promise((n,t)=>{mc("init-ep",[n,t]);let a={type:"init-ep",in:{epName:e,env:Jn}};La.postMessage(a)});await rv(Jn,e)},BS=async e=>Nl()?(_c(),new Promise((n,t)=>{mc("copy-from",[n,t]);let a={type:"copy-from",in:{buffer:e}};La.postMessage(a,[e.buffer])})):P_(e),jS=async(e,n)=>{if(Nl()){if(n?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return _c(),new Promise((t,a)=>{mc("create",[t,a]);let i={type:"create",in:{model:e,options:{...n}}},l=[];e instanceof Uint8Array&&l.push(e.buffer),La.postMessage(i,l)})}else return sv(e,n)},NS=async e=>{if(Nl())return _c(),new Promise((n,t)=>{mc("release",[n,t]);let a={type:"release",in:e};La.postMessage(a)});av(e)},US=async(e,n,t,a,i,l)=>{if(Nl()){if(t.some(u=>u[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(i.some(u=>u))throw new Error("pre-allocated output tensor is not supported for proxy.");return _c(),new Promise((u,d)=>{mc("run",[u,d]);let f=t,h={type:"run",in:{sessionId:e,inputIndices:n,inputs:f,outputIndices:a,options:l}};La.postMessage(h,lv(f))})}else return iv(e,n,t,a,i,l)},VS=async e=>{if(Nl())return _c(),new Promise((n,t)=>{mc("end-profiling",[n,t]);let a={type:"end-profiling",in:e};La.postMessage(a)});ov(e)}}),L0,Q2,WS,D$=ut(()=>{Ti(),GS(),Bt(),zy(),Bx(),L0=(e,n)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${n()}`)}},Q2=e=>{switch(e[3]){case"cpu":return new bi(e[0],e[2],e[1]);case"gpu-buffer":{let n=e[0];if(!Ny(n))throw new Error(`not supported data type: ${n} for deserializing GPU tensor`);let{gpuBuffer:t,download:a,dispose:i}=e[2];return bi.fromGpuBuffer(t,{dataType:n,dims:e[1],download:a,dispose:i})}case"ml-tensor":{let n=e[0];if(!Uy(n))throw new Error(`not supported data type: ${n} for deserializing MLTensor tensor`);let{mlTensor:t,download:a,dispose:i}=e[2];return bi.fromMLTensor(t,{dataType:n,dims:e[1],download:a,dispose:i})}default:throw new Error(`invalid data location: ${e[3]}`)}},WS=class{async fetchModelAndCopyToWasmMemory(e){return BS(await Vy(e))}async loadModel(e,n){xi();let t;typeof e=="string"?t=await this.fetchModelAndCopyToWasmMemory(e):t=e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await jS(t,n),Ba()}async dispose(){return NS(this.sessionId)}async run(e,n,t){xi();let a=[],i=[];Object.entries(e).forEach(m=>{let p=m[0],y=m[1],v=this.inputNames.indexOf(p);if(v===-1)throw new Error(`invalid input '${p}'`);a.push(y),i.push(v)});let l=[],u=[];Object.entries(n).forEach(m=>{let p=m[0],y=m[1],v=this.outputNames.indexOf(p);if(v===-1)throw new Error(`invalid output '${p}'`);l.push(y),u.push(v)});let d=a.map((m,p)=>L0(m,()=>`input "${this.inputNames[i[p]]}"`)),f=l.map((m,p)=>m?L0(m,()=>`output "${this.outputNames[u[p]]}"`):null),h=await US(this.sessionId,i,d,u,f,t),_={};for(let m=0;m<h.length;m++)_[this.outputNames[u[m]]]=l[m]??Q2(h[m]);return Ba(),_}startProfiling(){}endProfiling(){VS(this.sessionId)}}}),HS={};df(HS,{OnnxruntimeWebAssemblyBackend:()=>yy,initializeFlags:()=>gy,wasmBackend:()=>KS});var gy,yy,KS,I$=ut(()=>{Ti(),GS(),D$(),gy=()=>{(typeof Jn.wasm.initTimeout!="number"||Jn.wasm.initTimeout<0)&&(Jn.wasm.initTimeout=0);let e=Jn.wasm.simd;if(typeof e!="boolean"&&e!==void 0&&e!=="fixed"&&e!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),Jn.wasm.simd=!1),typeof Jn.wasm.proxy!="boolean"&&(Jn.wasm.proxy=!1),typeof Jn.wasm.trace!="boolean"&&(Jn.wasm.trace=!1),typeof Jn.wasm.numThreads!="number"||!Number.isInteger(Jn.wasm.numThreads)||Jn.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)Jn.wasm.numThreads=1;else{let n=typeof navigator>"u"?bO("node:os").cpus().length:navigator.hardwareConcurrency;Jn.wasm.numThreads=Math.min(4,Math.ceil((n||1)/2))}},yy=class{async init(e){gy(),await FS(),await RS(e)}async createInferenceSessionHandler(e,n){let t=new WS;return await t.loadModel(e,n),t}},KS=new yy});Ti();Ti();Ti();var L$="1.22.0-dev.20250409-89f8206ba4",z$=Ax;{let e=(I$(),Rp(HS)).wasmBackend;bc("webgpu",e,5),bc("webnn",e,5),bc("cpu",e,10),bc("wasm",e,10)}Object.defineProperty(Jn.versions,"web",{value:L$,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F$=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return Ly},get TRACE(){return Bp},get TRACE_FUNC_BEGIN(){return xi},get TRACE_FUNC_END(){return Ba},get Tensor(){return bi},default:z$,get env(){return Jn},get registerBackend(){return bc}},Symbol.toStringTag,{value:"Module"}));var z0={},R$={"onnxruntime-common":(e=>{e.exports=_O}),"onnxruntime-web":(e=>{e.exports=F$}),"?2ce3":(()=>{}),"?7992":(()=>{}),"?5af5":(()=>{}),"?2b25":(()=>{}),"?db59":(()=>{}),"?383f":(()=>{}),"?fa4b":(()=>{}),"./node_modules/@huggingface/jinja/dist/index.js":((e,n,t)=>{t.r(n),t.d(n,{Environment:()=>pt,Interpreter:()=>Mt,Template:()=>Js,parse:()=>Te,tokenize:()=>_});var a=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Comment:"Comment"}),i=class{constructor(z,ce){this.value=z,this.type=ce}};function l(z){return/\w/.test(z)}function u(z){return/[0-9]/.test(z)}var d=[["{%",a.OpenStatement],["%}",a.CloseStatement],["{{",a.OpenExpression],["}}",a.CloseExpression],["(",a.OpenParen],[")",a.CloseParen],["{",a.OpenCurlyBracket],["}",a.CloseCurlyBracket],["[",a.OpenSquareBracket],["]",a.CloseSquareBracket],[",",a.Comma],[".",a.Dot],[":",a.Colon],["|",a.Pipe],["<=",a.ComparisonBinaryOperator],[">=",a.ComparisonBinaryOperator],["==",a.ComparisonBinaryOperator],["!=",a.ComparisonBinaryOperator],["<",a.ComparisonBinaryOperator],[">",a.ComparisonBinaryOperator],["+",a.AdditiveBinaryOperator],["-",a.AdditiveBinaryOperator],["~",a.AdditiveBinaryOperator],["*",a.MultiplicativeBinaryOperator],["/",a.MultiplicativeBinaryOperator],["%",a.MultiplicativeBinaryOperator],["=",a.Equals]],f=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function h(z,ce={}){return z.endsWith(`
`)&&(z=z.slice(0,-1)),ce.lstrip_blocks&&(z=z.replace(/^[ \t]*({[#%-])/gm,"$1")),ce.trim_blocks&&(z=z.replace(/([#%-]})\n/g,"$1")),z.replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{").replace(/-#}\s*/g,"#}").replace(/\s*{#-/g,"{#").replace(/{%\s*(end)?generation\s*%}/gs,"")}function _(z,ce={}){const X=[],ue=h(z,ce);let pe=0,ke=0;const Qe=Tt=>{let At="";for(;Tt(ue[pe]);){if(ue[pe]==="\\"){if(++pe,pe>=ue.length)throw new SyntaxError("Unexpected end of input");const mt=ue[pe++],Zt=f.get(mt);if(Zt===void 0)throw new SyntaxError(`Unexpected escaped character: ${mt}`);At+=Zt;continue}if(At+=ue[pe++],pe>=ue.length)throw new SyntaxError("Unexpected end of input")}return At};e:for(;pe<ue.length;){const Tt=X.at(-1)?.type;if(Tt===void 0||Tt===a.CloseStatement||Tt===a.CloseExpression||Tt===a.Comment){let mt="";for(;pe<ue.length&&!(ue[pe]==="{"&&(ue[pe+1]==="%"||ue[pe+1]==="{"||ue[pe+1]==="#"));)mt+=ue[pe++];if(mt.length>0){X.push(new i(mt,a.Text));continue}}if(ue[pe]==="{"&&ue[pe+1]==="#"){pe+=2;let mt="";for(;ue[pe]!=="#"||ue[pe+1]!=="}";){if(pe+2>=ue.length)throw new SyntaxError("Missing end of comment tag");mt+=ue[pe++]}X.push(new i(mt,a.Comment)),pe+=2;continue}Qe(mt=>/\s/.test(mt));const At=ue[pe];if(At==="-"||At==="+"){const mt=X.at(-1)?.type;if(mt===a.Text||mt===void 0)throw new SyntaxError(`Unexpected character: ${At}`);switch(mt){case a.Identifier:case a.NumericLiteral:case a.StringLiteral:case a.CloseParen:case a.CloseSquareBracket:break;default:{++pe;const Zt=Qe(u);X.push(new i(`${At}${Zt}`,Zt.length>0?a.NumericLiteral:a.UnaryOperator));continue}}}for(const[mt,Zt]of d){if(mt==="}}"&&ke>0)continue;if(ue.slice(pe,pe+mt.length)===mt){X.push(new i(mt,Zt)),Zt===a.OpenExpression?ke=0:Zt===a.OpenCurlyBracket?++ke:Zt===a.CloseCurlyBracket&&--ke,pe+=mt.length;continue e}}if(At==="'"||At==='"'){++pe;const mt=Qe(Zt=>Zt!==At);X.push(new i(mt,a.StringLiteral)),++pe;continue}if(u(At)){let mt=Qe(u);if(ue[pe]==="."&&u(ue[pe+1])){++pe;const Zt=Qe(u);mt=`${mt}.${Zt}`}X.push(new i(mt,a.NumericLiteral));continue}if(l(At)){const mt=Qe(l);X.push(new i(mt,a.Identifier));continue}throw new SyntaxError(`Unexpected character: ${At}`)}return X}var m=class{type="Statement"},p=class extends m{constructor(z){super(),this.body=z}type="Program"},y=class extends m{constructor(z,ce,X){super(),this.test=z,this.body=ce,this.alternate=X}type="If"},v=class extends m{constructor(z,ce,X,ue){super(),this.loopvar=z,this.iterable=ce,this.body=X,this.defaultBlock=ue}type="For"},x=class extends m{type="Break"},L=class extends m{type="Continue"},T=class extends m{constructor(z,ce,X){super(),this.assignee=z,this.value=ce,this.body=X}type="Set"},E=class extends m{constructor(z,ce,X){super(),this.name=z,this.args=ce,this.body=X}type="Macro"},I=class extends m{constructor(z){super(),this.value=z}type="Comment"},P=class extends m{type="Expression"},S=class extends P{constructor(z,ce,X){super(),this.object=z,this.property=ce,this.computed=X}type="MemberExpression"},k=class extends P{constructor(z,ce){super(),this.callee=z,this.args=ce}type="CallExpression"},C=class extends P{constructor(z){super(),this.value=z}type="Identifier"},D=class extends P{constructor(z){super(),this.value=z}type="Literal"},V=class extends D{type="IntegerLiteral"},U=class extends D{type="FloatLiteral"},ne=class extends D{type="StringLiteral"},ee=class extends D{type="ArrayLiteral"},H=class extends D{type="TupleLiteral"},oe=class extends D{type="ObjectLiteral"},ae=class extends P{constructor(z,ce,X){super(),this.operator=z,this.left=ce,this.right=X}type="BinaryExpression"},W=class extends P{constructor(z,ce){super(),this.operand=z,this.filter=ce}type="FilterExpression"},te=class extends m{constructor(z,ce){super(),this.filter=z,this.body=ce}type="FilterStatement"},ie=class extends P{constructor(z,ce){super(),this.lhs=z,this.test=ce}type="SelectExpression"},_e=class extends P{constructor(z,ce,X){super(),this.operand=z,this.negate=ce,this.test=X}type="TestExpression"},q=class extends P{constructor(z,ce){super(),this.operator=z,this.argument=ce}type="UnaryExpression"},B=class extends P{constructor(z=void 0,ce=void 0,X=void 0){super(),this.start=z,this.stop=ce,this.step=X}type="SliceExpression"},R=class extends P{constructor(z,ce){super(),this.key=z,this.value=ce}type="KeywordArgumentExpression"},Q=class extends P{constructor(z){super(),this.argument=z}type="SpreadExpression"},G=class extends m{constructor(z,ce,X){super(),this.call=z,this.callerArgs=ce,this.body=X}type="CallStatement"},fe=class extends P{constructor(z,ce,X){super(),this.condition=z,this.trueExpr=ce,this.falseExpr=X}type="Ternary"};function Te(z){const ce=new p([]);let X=0;function ue(et,ot){const Et=z[X++];if(!Et||Et.type!==et)throw new Error(`Parser Error: ${ot}. ${Et.type} !== ${et}.`);return Et}function pe(et){if(!At(et))throw new SyntaxError(`Expected ${et}`);++X}function ke(){switch(z[X].type){case a.Comment:return new I(z[X++].value);case a.Text:return mt();case a.OpenStatement:return Zt();case a.OpenExpression:return qt();default:throw new SyntaxError(`Unexpected token type: ${z[X].type}`)}}function Qe(...et){return X+et.length<=z.length&&et.every((ot,Et)=>ot===z[X+Et].type)}function Tt(...et){return z[X]?.type===a.OpenStatement&&z[X+1]?.type===a.Identifier&&et.includes(z[X+1]?.value)}function At(...et){return X+et.length<=z.length&&et.every((ot,Et)=>z[X+Et].type==="Identifier"&&ot===z[X+Et].value)}function mt(){return new ne(ue(a.Text,"Expected text token").value)}function Zt(){if(ue(a.OpenStatement,"Expected opening statement token"),z[X].type!==a.Identifier)throw new SyntaxError(`Unknown statement, got ${z[X].type}`);const et=z[X].value;let ot;switch(et){case"set":++X,ot=On();break;case"if":++X,ot=wn(),ue(a.OpenStatement,"Expected {% token"),pe("endif"),ue(a.CloseStatement,"Expected %} token");break;case"macro":++X,ot=Un(),ue(a.OpenStatement,"Expected {% token"),pe("endmacro"),ue(a.CloseStatement,"Expected %} token");break;case"for":++X,ot=Bn(),ue(a.OpenStatement,"Expected {% token"),pe("endfor"),ue(a.CloseStatement,"Expected %} token");break;case"call":{++X;let Et=null;Qe(a.OpenParen)&&(Et=mr());const $n=Zr();if($n.type!=="Identifier")throw new SyntaxError("Expected identifier following call statement");const va=mr();ue(a.CloseStatement,"Expected closing statement token");const Cs=[];for(;!Tt("endcall");)Cs.push(ke());ue(a.OpenStatement,"Expected '{%'"),pe("endcall"),ue(a.CloseStatement,"Expected closing statement token");const Ps=new k($n,va);ot=new G(Ps,Et,Cs);break}case"break":++X,ue(a.CloseStatement,"Expected closing statement token"),ot=new x;break;case"continue":++X,ue(a.CloseStatement,"Expected closing statement token"),ot=new L;break;case"filter":{++X;let Et=Zr();Et instanceof C&&Qe(a.OpenParen)&&(Et=ur(Et)),ue(a.CloseStatement,"Expected closing statement token");const $n=[];for(;!Tt("endfilter");)$n.push(ke());ue(a.OpenStatement,"Expected '{%'"),pe("endfilter"),ue(a.CloseStatement,"Expected '%}'"),ot=new te(Et,$n);break}default:throw new SyntaxError(`Unknown statement type: ${et}`)}return ot}function qt(){ue(a.OpenExpression,"Expected opening expression token");const et=hr();return ue(a.CloseExpression,"Expected closing expression token"),et}function On(){const et=Sn();let ot=null;const Et=[];if(Qe(a.Equals))++X,ot=Sn();else{for(ue(a.CloseStatement,"Expected %} token");!Tt("endset");)Et.push(ke());ue(a.OpenStatement,"Expected {% token"),pe("endset")}return ue(a.CloseStatement,"Expected closing statement token"),new T(et,ot,Et)}function wn(){const et=hr();ue(a.CloseStatement,"Expected closing statement token");const ot=[],Et=[];for(;!Tt("elif","else","endif");)ot.push(ke());if(Tt("elif")){++X,++X;const $n=wn();Et.push($n)}else if(Tt("else"))for(++X,++X,ue(a.CloseStatement,"Expected closing statement token");!Tt("endif");)Et.push(ke());return new y(et,ot,Et)}function Un(){const et=Zr();if(et.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const ot=mr();ue(a.CloseStatement,"Expected closing statement token");const Et=[];for(;!Tt("endmacro");)Et.push(ke());return new E(et,ot,Et)}function Sn(et=!1){const ot=et?Zr:hr,Et=[ot()],$n=Qe(a.Comma);for(;$n&&(++X,Et.push(ot()),!!Qe(a.Comma)););return $n?new H(Et):Et[0]}function Bn(){const et=Sn(!0);if(!(et instanceof C||et instanceof H))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${et.type} instead`);if(!At("in"))throw new SyntaxError("Expected `in` keyword following loop variable");++X;const ot=hr();ue(a.CloseStatement,"Expected closing statement token");const Et=[];for(;!Tt("endfor","else");)Et.push(ke());const $n=[];if(Tt("else"))for(++X,++X,ue(a.CloseStatement,"Expected closing statement token");!Tt("endfor");)$n.push(ke());return new v(et,ot,Et,$n)}function hr(){return pr()}function pr(){const et=lr();if(At("if")){++X;const ot=lr();if(At("else")){++X;const Et=pr();return new fe(ot,et,Et)}else return new ie(et,ot)}return et}function lr(){let et=ea();for(;At("or");){const ot=z[X];++X;const Et=ea();et=new ae(ot,et,Et)}return et}function ea(){let et=Vs();for(;At("and");){const ot=z[X];++X;const Et=Vs();et=new ae(ot,et,Et)}return et}function Vs(){let et;for(;At("not");){const ot=z[X];++X;const Et=Vs();et=new q(ot,Et)}return et??Xr()}function Xr(){let et=ya();for(;;){let ot;if(At("not","in"))ot=new i("not in",a.Identifier),X+=2;else if(At("in"))ot=z[X++];else if(Qe(a.ComparisonBinaryOperator))ot=z[X++];else break;const Et=ya();et=new ae(ot,et,Et)}return et}function ya(){let et=ls();for(;Qe(a.AdditiveBinaryOperator);){const ot=z[X];++X;const Et=ls();et=new ae(ot,et,Et)}return et}function Vr(){const et=Yr(Zr());return Qe(a.OpenParen)?ur(et):et}function ur(et){let ot=new k(et,mr());return ot=Yr(ot),Qe(a.OpenParen)&&(ot=ur(ot)),ot}function mr(){ue(a.OpenParen,"Expected opening parenthesis for arguments list");const et=tr();return ue(a.CloseParen,"Expected closing parenthesis for arguments list"),et}function tr(){const et=[];for(;!Qe(a.CloseParen);){let ot;if(z[X].type===a.MultiplicativeBinaryOperator&&z[X].value==="*"){++X;const Et=hr();ot=new Q(Et)}else if(ot=hr(),Qe(a.Equals)){if(++X,!(ot instanceof C))throw new SyntaxError("Expected identifier for keyword argument");const Et=hr();ot=new R(ot,Et)}et.push(ot),Qe(a.Comma)&&++X}return et}function Er(){const et=[];let ot=!1;for(;!Qe(a.CloseSquareBracket);)Qe(a.Colon)?(et.push(void 0),++X,ot=!0):(et.push(hr()),Qe(a.Colon)&&(++X,ot=!0));if(et.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(ot){if(et.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new B(...et)}return et[0]}function Yr(et){for(;Qe(a.Dot)||Qe(a.OpenSquareBracket);){const ot=z[X];++X;let Et;const $n=ot.type===a.OpenSquareBracket;if($n)Et=Er(),ue(a.CloseSquareBracket,"Expected closing square bracket");else if(Et=Zr(),Et.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");et=new S(et,Et,$n)}return et}function ls(){let et=Gs();for(;Qe(a.MultiplicativeBinaryOperator);){const ot=z[X++],Et=Gs();et=new ae(ot,et,Et)}return et}function Gs(){let et=Na();for(;At("is");){++X;const ot=At("not");ot&&++X;const Et=Zr();if(!(Et instanceof C))throw new SyntaxError("Expected identifier for the test");et=new _e(et,ot,Et)}return et}function Na(){let et=Vr();for(;Qe(a.Pipe);){++X;let ot=Zr();if(!(ot instanceof C))throw new SyntaxError("Expected identifier for the filter");Qe(a.OpenParen)&&(ot=ur(ot)),et=new W(et,ot)}return et}function Zr(){const et=z[X++];switch(et.type){case a.NumericLiteral:{const ot=et.value;return ot.includes(".")?new U(Number(ot)):new V(Number(ot))}case a.StringLiteral:{let ot=et.value;for(;Qe(a.StringLiteral);)ot+=z[X++].value;return new ne(ot)}case a.Identifier:return new C(et.value);case a.OpenParen:{const ot=Sn();return ue(a.CloseParen,"Expected closing parenthesis, got ${tokens[current].type} instead."),ot}case a.OpenSquareBracket:{const ot=[];for(;!Qe(a.CloseSquareBracket);)ot.push(hr()),Qe(a.Comma)&&++X;return++X,new ee(ot)}case a.OpenCurlyBracket:{const ot=new Map;for(;!Qe(a.CloseCurlyBracket);){const Et=hr();ue(a.Colon,"Expected colon between key and value in object literal");const $n=hr();ot.set(Et,$n),Qe(a.Comma)&&++X}return++X,new oe(ot)}default:throw new SyntaxError(`Unexpected token: ${et.type}`)}}for(;X<z.length;)ce.body.push(ke());return ce}function ze(z,ce,X=1){ce===void 0&&(ce=z,z=0);const ue=[];for(let pe=z;pe<ce;pe+=X)ue.push(pe);return ue}function Ue(z,ce,X,ue=1){const pe=Math.sign(ue);pe>=0?(ce=(ce??=0)<0?Math.max(z.length+ce,0):Math.min(ce,z.length),X=(X??=z.length)<0?Math.max(z.length+X,0):Math.min(X,z.length)):(ce=(ce??=z.length-1)<0?Math.max(z.length+ce,-1):Math.min(ce,z.length-1),X=(X??=-1)<-1?Math.max(z.length+X,-1):Math.min(X,z.length-1));const ke=[];for(let Qe=ce;pe*Qe<pe*X;Qe+=ue)ke.push(z[Qe]);return ke}function ft(z){return z.replace(/\b\w/g,ce=>ce.toUpperCase())}function je(z){return le(new Date,z)}function le(z,ce){const X=new Intl.DateTimeFormat(void 0,{month:"long"}),ue=new Intl.DateTimeFormat(void 0,{month:"short"}),pe=ke=>ke<10?"0"+ke:ke.toString();return ce.replace(/%[YmdbBHM%]/g,ke=>{switch(ke){case"%Y":return z.getFullYear().toString();case"%m":return pe(z.getMonth()+1);case"%d":return pe(z.getDate());case"%b":return ue.format(z);case"%B":return X.format(z);case"%H":return pe(z.getHours());case"%M":return pe(z.getMinutes());case"%%":return"%";default:return ke}})}function J(z){return z.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function be(z,ce,X,ue){if(ue===0)return z;let pe=ue==null||ue<0?1/0:ue;const ke=ce.length===0?new RegExp("(?=)","gu"):new RegExp(J(ce),"gu");return z.replaceAll(ke,Qe=>pe>0?(--pe,X):Qe)}var Ae=class extends Error{},Ne=class extends Error{},De=class{type="RuntimeValue";value;builtins=new Map;constructor(z=void 0){this.value=z}__bool__(){return new Ge(!!this.value)}toString(){return String(this.value)}},xe=class extends De{type="IntegerValue"},Ve=class extends De{type="FloatValue";toString(){return this.value%1===0?this.value.toFixed(1):this.value.toString()}},Ee=class extends De{type="StringValue";builtins=new Map([["upper",new st(()=>new Ee(this.value.toUpperCase()))],["lower",new st(()=>new Ee(this.value.toLowerCase()))],["strip",new st(()=>new Ee(this.value.trim()))],["title",new st(()=>new Ee(ft(this.value)))],["capitalize",new st(()=>new Ee(this.value.charAt(0).toUpperCase()+this.value.slice(1)))],["length",new xe(this.value.length)],["rstrip",new st(()=>new Ee(this.value.trimEnd()))],["lstrip",new st(()=>new Ee(this.value.trimStart()))],["startswith",new st(z=>{if(z.length===0)throw new Error("startswith() requires at least one argument");const ce=z[0];if(ce instanceof Ee)return new Ge(this.value.startsWith(ce.value));if(ce instanceof Re){for(const X of ce.value){if(!(X instanceof Ee))throw new Error("startswith() tuple elements must be strings");if(this.value.startsWith(X.value))return new Ge(!0)}return new Ge(!1)}throw new Error("startswith() argument must be a string or tuple of strings")})],["endswith",new st(z=>{if(z.length===0)throw new Error("endswith() requires at least one argument");const ce=z[0];if(ce instanceof Ee)return new Ge(this.value.endsWith(ce.value));if(ce instanceof Re){for(const X of ce.value){if(!(X instanceof Ee))throw new Error("endswith() tuple elements must be strings");if(this.value.endsWith(X.value))return new Ge(!0)}return new Ge(!1)}throw new Error("endswith() argument must be a string or tuple of strings")})],["split",new st(z=>{const ce=z[0]??new nt;if(!(ce instanceof Ee||ce instanceof nt))throw new Error("sep argument must be a string or null");const X=z[1]??new xe(-1);if(!(X instanceof xe))throw new Error("maxsplit argument must be a number");let ue=[];if(ce instanceof nt){const pe=this.value.trimStart();for(const{0:ke,index:Qe}of pe.matchAll(/\S+/g)){if(X.value!==-1&&ue.length>=X.value&&Qe!==void 0){ue.push(ke+pe.slice(Qe+ke.length));break}ue.push(ke)}}else{if(ce.value==="")throw new Error("empty separator");ue=this.value.split(ce.value),X.value!==-1&&ue.length>X.value&&ue.push(ue.splice(X.value).join(ce.value))}return new Re(ue.map(pe=>new Ee(pe)))})],["replace",new st(z=>{if(z.length<2)throw new Error("replace() requires at least two arguments");const ce=z[0],X=z[1];if(!(ce instanceof Ee&&X instanceof Ee))throw new Error("replace() arguments must be strings");let ue;if(z.length>2?z[2].type==="KeywordArgumentsValue"?ue=z[2].value.get("count")??new nt:ue=z[2]:ue=new nt,!(ue instanceof xe||ue instanceof nt))throw new Error("replace() count argument must be a number or null");return new Ee(be(this.value,ce.value,X.value,ue.value))})]])},Ge=class extends De{type="BooleanValue"},Ye=class extends De{type="ObjectValue";__bool__(){return new Ge(this.value.size>0)}builtins=new Map([["get",new st(([z,ce])=>{if(!(z instanceof Ee))throw new Error(`Object key must be a string: got ${z.type}`);return this.value.get(z.value)??ce??new nt})],["items",new st(()=>this.items())],["keys",new st(()=>this.keys())],["values",new st(()=>this.values())]]);items(){return new Re(Array.from(this.value.entries()).map(([z,ce])=>new Re([new Ee(z),ce])))}keys(){return new Re(Array.from(this.value.keys()).map(z=>new Ee(z)))}values(){return new Re(Array.from(this.value.values()))}},_t=class extends Ye{type="KeywordArgumentsValue"},Re=class extends De{type="ArrayValue";builtins=new Map([["length",new xe(this.value.length)]]);__bool__(){return new Ge(this.value.length>0)}},xt=class extends Re{type="TupleValue"},st=class extends De{type="FunctionValue"},nt=class extends De{type="NullValue"},ct=class extends De{type="UndefinedValue"},pt=class{constructor(z){this.parent=z}variables=new Map([["namespace",new st(z=>{if(z.length===0)return new Ye(new Map);if(z.length!==1||!(z[0]instanceof Ye))throw new Error("`namespace` expects either zero arguments or a single object argument");return z[0]})]]);tests=new Map([["boolean",z=>z.type==="BooleanValue"],["callable",z=>z instanceof st],["odd",z=>{if(!(z instanceof xe))throw new Error(`cannot odd on ${z.type}`);return z.value%2!==0}],["even",z=>{if(!(z instanceof xe))throw new Error(`cannot even on ${z.type}`);return z.value%2===0}],["false",z=>z.type==="BooleanValue"&&!z.value],["true",z=>z.type==="BooleanValue"&&z.value],["none",z=>z.type==="NullValue"],["string",z=>z.type==="StringValue"],["number",z=>z instanceof xe||z instanceof Ve],["integer",z=>z instanceof xe],["iterable",z=>z.type==="ArrayValue"||z.type==="StringValue"],["mapping",z=>z.type==="ObjectValue"],["lower",z=>{const ce=z.value;return z.type==="StringValue"&&ce===ce.toLowerCase()}],["upper",z=>{const ce=z.value;return z.type==="StringValue"&&ce===ce.toUpperCase()}],["none",z=>z.type==="NullValue"],["defined",z=>z.type!=="UndefinedValue"],["undefined",z=>z.type==="UndefinedValue"],["equalto",(z,ce)=>z.value===ce.value],["eq",(z,ce)=>z.value===ce.value]]);set(z,ce){return this.declareVariable(z,tn(ce))}declareVariable(z,ce){if(this.variables.has(z))throw new SyntaxError(`Variable already declared: ${z}`);return this.variables.set(z,ce),ce}setVariable(z,ce){return this.variables.set(z,ce),ce}resolve(z){if(this.variables.has(z))return this;if(this.parent)return this.parent.resolve(z);throw new Error(`Unknown variable: ${z}`)}lookupVariable(z){try{return this.resolve(z).variables.get(z)??new ct}catch{return new ct}}};function lt(z){z.set("false",!1),z.set("true",!0),z.set("none",null),z.set("raise_exception",ce=>{throw new Error(ce)}),z.set("range",ze),z.set("strftime_now",je),z.set("True",!0),z.set("False",!1),z.set("None",null)}var Mt=class{global;constructor(z){this.global=z??new pt}run(z){return this.evaluate(z,this.global)}evaluateBinaryExpression(z,ce){const X=this.evaluate(z.left,ce);switch(z.operator.value){case"and":return X.__bool__().value?this.evaluate(z.right,ce):X;case"or":return X.__bool__().value?X:this.evaluate(z.right,ce)}const ue=this.evaluate(z.right,ce);switch(z.operator.value){case"==":return new Ge(X.value==ue.value);case"!=":return new Ge(X.value!=ue.value)}if(X instanceof ct||ue instanceof ct){if(ue instanceof ct&&["in","not in"].includes(z.operator.value))return new Ge(z.operator.value==="not in");throw new Error(`Cannot perform operation ${z.operator.value} on undefined values`)}else{if(X instanceof nt||ue instanceof nt)throw new Error("Cannot perform operation on null values");if(z.operator.value==="~")return new Ee(X.value.toString()+ue.value.toString());if((X instanceof xe||X instanceof Ve)&&(ue instanceof xe||ue instanceof Ve)){const pe=X.value,ke=ue.value;switch(z.operator.value){case"+":case"-":case"*":{const Qe=z.operator.value==="+"?pe+ke:z.operator.value==="-"?pe-ke:pe*ke;return X instanceof Ve||ue instanceof Ve?new Ve(Qe):new xe(Qe)}case"/":return new Ve(pe/ke);case"%":{const Qe=pe%ke;return X instanceof Ve||ue instanceof Ve?new Ve(Qe):new xe(Qe)}case"<":return new Ge(pe<ke);case">":return new Ge(pe>ke);case">=":return new Ge(pe>=ke);case"<=":return new Ge(pe<=ke)}}else if(X instanceof Re&&ue instanceof Re)switch(z.operator.value){case"+":return new Re(X.value.concat(ue.value))}else if(ue instanceof Re){const pe=ue.value.find(ke=>ke.value===X.value)!==void 0;switch(z.operator.value){case"in":return new Ge(pe);case"not in":return new Ge(!pe)}}}if(X instanceof Ee||ue instanceof Ee)switch(z.operator.value){case"+":return new Ee(X.value.toString()+ue.value.toString())}if(X instanceof Ee&&ue instanceof Ee)switch(z.operator.value){case"in":return new Ge(ue.value.includes(X.value));case"not in":return new Ge(!ue.value.includes(X.value))}if(X instanceof Ee&&ue instanceof Ye)switch(z.operator.value){case"in":return new Ge(ue.value.has(X.value));case"not in":return new Ge(!ue.value.has(X.value))}throw new SyntaxError(`Unknown operator "${z.operator.value}" between ${X.type} and ${ue.type}`)}evaluateArguments(z,ce){const X=[],ue=new Map;for(const pe of z)if(pe.type==="SpreadExpression"){const ke=pe,Qe=this.evaluate(ke.argument,ce);if(!(Qe instanceof Re))throw new Error(`Cannot unpack non-iterable type: ${Qe.type}`);for(const Tt of Qe.value)X.push(Tt)}else if(pe.type==="KeywordArgumentExpression"){const ke=pe;ue.set(ke.key.value,this.evaluate(ke.value,ce))}else{if(ue.size>0)throw new Error("Positional arguments must come before keyword arguments");X.push(this.evaluate(pe,ce))}return[X,ue]}applyFilter(z,ce,X){if(ce.type==="Identifier"){const ue=ce;if(ue.value==="tojson")return new Ee(an(z));if(z instanceof Re)switch(ue.value){case"list":return z;case"first":return z.value[0];case"last":return z.value[z.value.length-1];case"length":return new xe(z.value.length);case"reverse":return new Re(z.value.reverse());case"sort":return new Re(z.value.sort((pe,ke)=>{if(pe.type!==ke.type)throw new Error(`Cannot compare different types: ${pe.type} and ${ke.type}`);switch(pe.type){case"IntegerValue":case"FloatValue":return pe.value-ke.value;case"StringValue":return pe.value.localeCompare(ke.value);default:throw new Error(`Cannot compare type: ${pe.type}`)}}));case"join":return new Ee(z.value.map(pe=>pe.value).join(""));case"string":return new Ee(an(z));case"unique":{const pe=new Set,ke=[];for(const Qe of z.value)pe.has(Qe.value)||(pe.add(Qe.value),ke.push(Qe));return new Re(ke)}default:throw new Error(`Unknown ArrayValue filter: ${ue.value}`)}else if(z instanceof Ee)switch(ue.value){case"length":case"upper":case"lower":case"title":case"capitalize":{const pe=z.builtins.get(ue.value);if(pe instanceof st)return pe.value([],X);if(pe instanceof xe)return pe;throw new Error(`Unknown StringValue filter: ${ue.value}`)}case"trim":return new Ee(z.value.trim());case"indent":return new Ee(z.value.split(`
`).map((pe,ke)=>ke===0||pe.length===0?pe:"    "+pe).join(`
`));case"join":case"string":return z;case"int":{const pe=parseInt(z.value,10);return new xe(isNaN(pe)?0:pe)}case"float":{const pe=parseFloat(z.value);return new Ve(isNaN(pe)?0:pe)}default:throw new Error(`Unknown StringValue filter: ${ue.value}`)}else if(z instanceof xe||z instanceof Ve)switch(ue.value){case"abs":return z instanceof xe?new xe(Math.abs(z.value)):new Ve(Math.abs(z.value));case"int":return new xe(Math.floor(z.value));case"float":return new Ve(z.value);default:throw new Error(`Unknown NumericValue filter: ${ue.value}`)}else if(z instanceof Ye)switch(ue.value){case"items":return new Re(Array.from(z.value.entries()).map(([pe,ke])=>new Re([new Ee(pe),ke])));case"length":return new xe(z.value.size);default:throw new Error(`Unknown ObjectValue filter: ${ue.value}`)}else if(z instanceof Ge)switch(ue.value){case"bool":return new Ge(z.value);case"int":return new xe(z.value?1:0);case"float":return new Ve(z.value?1:0);case"string":return new Ee(z.value?"true":"false");default:throw new Error(`Unknown BooleanValue filter: ${ue.value}`)}throw new Error(`Cannot apply filter "${ue.value}" to type: ${z.type}`)}else if(ce.type==="CallExpression"){const ue=ce;if(ue.callee.type!=="Identifier")throw new Error(`Unknown filter: ${ue.callee.type}`);const pe=ue.callee.value;if(pe==="tojson"){const[,ke]=this.evaluateArguments(ue.args,X),Qe=ke.get("indent")??new nt;if(!(Qe instanceof xe||Qe instanceof nt))throw new Error("If set, indent must be a number");return new Ee(an(z,Qe.value))}else if(pe==="join"){let ke;if(z instanceof Ee)ke=Array.from(z.value);else if(z instanceof Re)ke=z.value.map(mt=>mt.value);else throw new Error(`Cannot apply filter "${pe}" to type: ${z.type}`);const[Qe,Tt]=this.evaluateArguments(ue.args,X),At=Qe.at(0)??Tt.get("separator")??new Ee("");if(!(At instanceof Ee))throw new Error("separator must be a string");return new Ee(ke.join(At.value))}else if(pe==="int"||pe==="float"){const[ke,Qe]=this.evaluateArguments(ue.args,X),Tt=ke.at(0)??Qe.get("default")??(pe==="int"?new xe(0):new Ve(0));if(z instanceof Ee){const At=pe==="int"?parseInt(z.value,10):parseFloat(z.value);return isNaN(At)?Tt:pe==="int"?new xe(At):new Ve(At)}else{if(z instanceof xe||z instanceof Ve)return z;if(z instanceof Ge)return pe==="int"?new xe(z.value?1:0):new Ve(z.value?1:0);throw new Error(`Cannot apply filter "${pe}" to type: ${z.type}`)}}else if(pe==="default"){const[ke,Qe]=this.evaluateArguments(ue.args,X),Tt=ke[0]??new Ee(""),At=ke[1]??Qe.get("boolean")??new Ge(!1);if(!(At instanceof Ge))throw new Error("`default` filter flag must be a boolean");return z instanceof ct||At.value&&!z.__bool__().value?Tt:z}if(z instanceof Re){switch(pe){case"selectattr":case"rejectattr":{const ke=pe==="selectattr";if(z.value.some(qt=>!(qt instanceof Ye)))throw new Error(`\`${pe}\` can only be applied to array of objects`);if(ue.args.some(qt=>qt.type!=="StringLiteral"))throw new Error(`arguments of \`${pe}\` must be strings`);const[Qe,Tt,At]=ue.args.map(qt=>this.evaluate(qt,X));let mt;if(Tt){const qt=X.tests.get(Tt.value);if(!qt)throw new Error(`Unknown test: ${Tt.value}`);mt=qt}else mt=(...qt)=>qt[0].__bool__().value;const Zt=z.value.filter(qt=>{const On=qt.value.get(Qe.value),wn=On?mt(On,At):!1;return ke?wn:!wn});return new Re(Zt)}case"map":{const[,ke]=this.evaluateArguments(ue.args,X);if(ke.has("attribute")){const Qe=ke.get("attribute");if(!(Qe instanceof Ee))throw new Error("attribute must be a string");const Tt=ke.get("default"),At=z.value.map(mt=>{if(!(mt instanceof Ye))throw new Error("items in map must be an object");return mt.value.get(Qe.value)??Tt??new ct});return new Re(At)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${pe}`)}else if(z instanceof Ee){switch(pe){case"indent":{const[ke,Qe]=this.evaluateArguments(ue.args,X),Tt=ke.at(0)??Qe.get("width")??new xe(4);if(!(Tt instanceof xe))throw new Error("width must be a number");const At=ke.at(1)??Qe.get("first")??new Ge(!1),mt=ke.at(2)??Qe.get("blank")??new Ge(!1),Zt=z.value.split(`
`),qt=" ".repeat(Tt.value),On=Zt.map((wn,Un)=>!At.value&&Un===0||!mt.value&&wn.length===0?wn:qt+wn);return new Ee(On.join(`
`))}case"replace":{const ke=z.builtins.get("replace");if(!(ke instanceof st))throw new Error("replace filter not available");const[Qe,Tt]=this.evaluateArguments(ue.args,X);return ke.value([...Qe,new _t(Tt)],X)}}throw new Error(`Unknown StringValue filter: ${pe}`)}else throw new Error(`Cannot apply filter "${pe}" to type: ${z.type}`)}throw new Error(`Unknown filter: ${ce.type}`)}evaluateFilterExpression(z,ce){const X=this.evaluate(z.operand,ce);return this.applyFilter(X,z.filter,ce)}evaluateTestExpression(z,ce){const X=this.evaluate(z.operand,ce),ue=ce.tests.get(z.test.value);if(!ue)throw new Error(`Unknown test: ${z.test.value}`);const pe=ue(X);return new Ge(z.negate?!pe:pe)}evaluateSelectExpression(z,ce){return this.evaluate(z.test,ce).__bool__().value?this.evaluate(z.lhs,ce):new ct}evaluateUnaryExpression(z,ce){const X=this.evaluate(z.argument,ce);switch(z.operator.value){case"not":return new Ge(!X.value);default:throw new SyntaxError(`Unknown operator: ${z.operator.value}`)}}evaluateTernaryExpression(z,ce){return this.evaluate(z.condition,ce).__bool__().value?this.evaluate(z.trueExpr,ce):this.evaluate(z.falseExpr,ce)}evalProgram(z,ce){return this.evaluateBlock(z.body,ce)}evaluateBlock(z,ce){let X="";for(const ue of z){const pe=this.evaluate(ue,ce);pe.type!=="NullValue"&&pe.type!=="UndefinedValue"&&(X+=pe.toString())}return new Ee(X)}evaluateIdentifier(z,ce){return ce.lookupVariable(z.value)}evaluateCallExpression(z,ce){const[X,ue]=this.evaluateArguments(z.args,ce);ue.size>0&&X.push(new _t(ue));const pe=this.evaluate(z.callee,ce);if(pe.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${pe.type}`);return pe.value(X,ce)}evaluateSliceExpression(z,ce,X){if(!(z instanceof Re||z instanceof Ee))throw new Error("Slice object must be an array or string");const ue=this.evaluate(ce.start,X),pe=this.evaluate(ce.stop,X),ke=this.evaluate(ce.step,X);if(!(ue instanceof xe||ue instanceof ct))throw new Error("Slice start must be numeric or undefined");if(!(pe instanceof xe||pe instanceof ct))throw new Error("Slice stop must be numeric or undefined");if(!(ke instanceof xe||ke instanceof ct))throw new Error("Slice step must be numeric or undefined");return z instanceof Re?new Re(Ue(z.value,ue.value,pe.value,ke.value)):new Ee(Ue(Array.from(z.value),ue.value,pe.value,ke.value).join(""))}evaluateMemberExpression(z,ce){const X=this.evaluate(z.object,ce);let ue;if(z.computed){if(z.property.type==="SliceExpression")return this.evaluateSliceExpression(X,z.property,ce);ue=this.evaluate(z.property,ce)}else ue=new Ee(z.property.value);let pe;if(X instanceof Ye){if(!(ue instanceof Ee))throw new Error(`Cannot access property with non-string: got ${ue.type}`);pe=X.value.get(ue.value)??X.builtins.get(ue.value)}else if(X instanceof Re||X instanceof Ee)if(ue instanceof xe)pe=X.value.at(ue.value),X instanceof Ee&&(pe=new Ee(X.value.at(ue.value)));else if(ue instanceof Ee)pe=X.builtins.get(ue.value);else throw new Error(`Cannot access property with non-string/non-number: got ${ue.type}`);else{if(!(ue instanceof Ee))throw new Error(`Cannot access property with non-string: got ${ue.type}`);pe=X.builtins.get(ue.value)}return pe instanceof De?pe:new ct}evaluateSet(z,ce){const X=z.value?this.evaluate(z.value,ce):this.evaluateBlock(z.body,ce);if(z.assignee.type==="Identifier"){const ue=z.assignee.value;ce.setVariable(ue,X)}else if(z.assignee.type==="TupleLiteral"){const ue=z.assignee;if(!(X instanceof Re))throw new Error(`Cannot unpack non-iterable type in set: ${X.type}`);const pe=X.value;if(pe.length!==ue.value.length)throw new Error(`Too ${ue.value.length>pe.length?"few":"many"} items to unpack in set`);for(let ke=0;ke<ue.value.length;++ke){const Qe=ue.value[ke];if(Qe.type!=="Identifier")throw new Error(`Cannot unpack to non-identifier in set: ${Qe.type}`);ce.setVariable(Qe.value,pe[ke])}}else if(z.assignee.type==="MemberExpression"){const ue=z.assignee,pe=this.evaluate(ue.object,ce);if(!(pe instanceof Ye))throw new Error("Cannot assign to member of non-object");if(ue.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");pe.value.set(ue.property.value,X)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(z.assignee)}`);return new nt}evaluateIf(z,ce){const X=this.evaluate(z.test,ce);return this.evaluateBlock(X.__bool__().value?z.body:z.alternate,ce)}evaluateFor(z,ce){const X=new pt(ce);let ue,pe;if(z.iterable.type==="SelectExpression"){const mt=z.iterable;pe=this.evaluate(mt.lhs,X),ue=mt.test}else pe=this.evaluate(z.iterable,X);if(!(pe instanceof Re||pe instanceof Ye))throw new Error(`Expected iterable or object type in for loop: got ${pe.type}`);pe instanceof Ye&&(pe=pe.keys());const ke=[],Qe=[];for(let mt=0;mt<pe.value.length;++mt){const Zt=new pt(X),qt=pe.value[mt];let On;if(z.loopvar.type==="Identifier")On=wn=>wn.setVariable(z.loopvar.value,qt);else if(z.loopvar.type==="TupleLiteral"){const wn=z.loopvar;if(qt.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${qt.type}`);const Un=qt;if(wn.value.length!==Un.value.length)throw new Error(`Too ${wn.value.length>Un.value.length?"few":"many"} items to unpack`);On=Sn=>{for(let Bn=0;Bn<wn.value.length;++Bn){if(wn.value[Bn].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${wn.value[Bn].type}`);Sn.setVariable(wn.value[Bn].value,Un.value[Bn])}}}else throw new Error(`Invalid loop variable(s): ${z.loopvar.type}`);ue&&(On(Zt),!this.evaluate(ue,Zt).__bool__().value)||(ke.push(qt),Qe.push(On))}let Tt="",At=!0;for(let mt=0;mt<ke.length;++mt){const Zt=new Map([["index",new xe(mt+1)],["index0",new xe(mt)],["revindex",new xe(ke.length-mt)],["revindex0",new xe(ke.length-mt-1)],["first",new Ge(mt===0)],["last",new Ge(mt===ke.length-1)],["length",new xe(ke.length)],["previtem",mt>0?ke[mt-1]:new ct],["nextitem",mt<ke.length-1?ke[mt+1]:new ct]]);X.setVariable("loop",new Ye(Zt)),Qe[mt](X);try{const qt=this.evaluateBlock(z.body,X);Tt+=qt.value}catch(qt){if(qt instanceof Ne)continue;if(qt instanceof Ae)break;throw qt}At=!1}if(At){const mt=this.evaluateBlock(z.defaultBlock,X);Tt+=mt.value}return new Ee(Tt)}evaluateMacro(z,ce){return ce.setVariable(z.name.value,new st((X,ue)=>{const pe=new pt(ue);X=X.slice();let ke;X.at(-1)?.type==="KeywordArgumentsValue"&&(ke=X.pop());for(let Qe=0;Qe<z.args.length;++Qe){const Tt=z.args[Qe],At=X[Qe];if(Tt.type==="Identifier"){const mt=Tt;if(!At)throw new Error(`Missing positional argument: ${mt.value}`);pe.setVariable(mt.value,At)}else if(Tt.type==="KeywordArgumentExpression"){const mt=Tt,Zt=At??ke?.value.get(mt.key.value)??this.evaluate(mt.value,pe);pe.setVariable(mt.key.value,Zt)}else throw new Error(`Unknown argument type: ${Tt.type}`)}return this.evaluateBlock(z.body,pe)})),new nt}evaluateCallStatement(z,ce){const X=new st((Tt,At)=>{const mt=new pt(At);if(z.callerArgs)for(let Zt=0;Zt<z.callerArgs.length;++Zt){const qt=z.callerArgs[Zt];if(qt.type!=="Identifier")throw new Error(`Caller parameter must be an identifier, got ${qt.type}`);mt.setVariable(qt.value,Tt[Zt]??new ct)}return this.evaluateBlock(z.body,mt)}),[ue,pe]=this.evaluateArguments(z.call.args,ce);ue.push(new _t(pe));const ke=this.evaluate(z.call.callee,ce);if(ke.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${ke.type}`);const Qe=new pt(ce);return Qe.setVariable("caller",X),ke.value(ue,Qe)}evaluateFilterStatement(z,ce){const X=this.evaluateBlock(z.body,ce);return this.applyFilter(X,z.filter,ce)}evaluate(z,ce){if(!z)return new ct;switch(z.type){case"Program":return this.evalProgram(z,ce);case"Set":return this.evaluateSet(z,ce);case"If":return this.evaluateIf(z,ce);case"For":return this.evaluateFor(z,ce);case"Macro":return this.evaluateMacro(z,ce);case"CallStatement":return this.evaluateCallStatement(z,ce);case"Break":throw new Ae;case"Continue":throw new Ne;case"IntegerLiteral":return new xe(z.value);case"FloatLiteral":return new Ve(z.value);case"StringLiteral":return new Ee(z.value);case"ArrayLiteral":return new Re(z.value.map(X=>this.evaluate(X,ce)));case"TupleLiteral":return new xt(z.value.map(X=>this.evaluate(X,ce)));case"ObjectLiteral":{const X=new Map;for(const[ue,pe]of z.value){const ke=this.evaluate(ue,ce);if(!(ke instanceof Ee))throw new Error(`Object keys must be strings: got ${ke.type}`);X.set(ke.value,this.evaluate(pe,ce))}return new Ye(X)}case"Identifier":return this.evaluateIdentifier(z,ce);case"CallExpression":return this.evaluateCallExpression(z,ce);case"MemberExpression":return this.evaluateMemberExpression(z,ce);case"UnaryExpression":return this.evaluateUnaryExpression(z,ce);case"BinaryExpression":return this.evaluateBinaryExpression(z,ce);case"FilterExpression":return this.evaluateFilterExpression(z,ce);case"FilterStatement":return this.evaluateFilterStatement(z,ce);case"TestExpression":return this.evaluateTestExpression(z,ce);case"SelectExpression":return this.evaluateSelectExpression(z,ce);case"Ternary":return this.evaluateTernaryExpression(z,ce);case"Comment":return new nt;default:throw new SyntaxError(`Unknown node type: ${z.type}`)}}};function tn(z){switch(typeof z){case"number":return Number.isInteger(z)?new xe(z):new Ve(z);case"string":return new Ee(z);case"boolean":return new Ge(z);case"undefined":return new ct;case"object":return z===null?new nt:Array.isArray(z)?new Re(z.map(tn)):new Ye(new Map(Object.entries(z).map(([ce,X])=>[ce,tn(X)])));case"function":return new st((ce,X)=>{const ue=z(...ce.map(pe=>pe.value))??null;return tn(ue)});default:throw new Error(`Cannot convert to runtime value: ${z}`)}}function an(z,ce,X){const ue=X??0;switch(z.type){case"NullValue":case"UndefinedValue":return"null";case"IntegerValue":case"FloatValue":case"StringValue":case"BooleanValue":return JSON.stringify(z.value);case"ArrayValue":case"ObjectValue":{const pe=ce?" ".repeat(ce):"",ke=`
`+pe.repeat(ue),Qe=ke+pe;if(z.type==="ArrayValue"){const Tt=z.value.map(At=>an(At,ce,ue+1));return ce?`[${Qe}${Tt.join(`,${Qe}`)}${ke}]`:`[${Tt.join(", ")}]`}else{const Tt=Array.from(z.value.entries()).map(([At,mt])=>{const Zt=`"${At}": ${an(mt,ce,ue+1)}`;return ce?`${Qe}${Zt}`:Zt});return ce?`{${Tt.join(",")}${ke}}`:`{${Tt.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${z.type}`)}}var Ft=`
`,or="{%- ",Or=" -%}";function Br(z){switch(z.operator.type){case"MultiplicativeBinaryOperator":return 4;case"AdditiveBinaryOperator":return 3;case"ComparisonBinaryOperator":return 2;case"Identifier":return z.operator.value==="and"?1:z.operator.value==="in"||z.operator.value==="not in"?2:0}return 0}function $r(z,ce="	"){const X=typeof ce=="number"?" ".repeat(ce):ce;return jr(z.body,0,X).replace(/\n$/,"")}function er(...z){return or+z.join(" ")+Or}function jr(z,ce,X){return z.map(ue=>ja(ue,ce,X)).join(Ft)}function ja(z,ce,X){const ue=X.repeat(ce);switch(z.type){case"Program":return jr(z.body,ce,X);case"If":return ga(z,ce,X);case"For":return Es(z,ce,X);case"Set":return Ss(z,ce,X);case"Macro":return zt(z,ce,X);case"Break":return ue+er("break");case"Continue":return ue+er("continue");case"CallStatement":return Zs(z,ce,X);case"FilterStatement":return En(z,ce,X);case"Comment":return ue+"{# "+z.value+" #}";default:return ue+"{{- "+Kt(z)+" -}}"}}function ga(z,ce,X){const ue=X.repeat(ce),pe=[];let ke=z;for(;ke&&(pe.push({test:ke.test,body:ke.body}),ke.alternate.length===1&&ke.alternate[0].type==="If");)ke=ke.alternate[0];let Qe=ue+er("if",Kt(pe[0].test))+Ft+jr(pe[0].body,ce+1,X);for(let Tt=1;Tt<pe.length;++Tt)Qe+=Ft+ue+er("elif",Kt(pe[Tt].test))+Ft+jr(pe[Tt].body,ce+1,X);return ke&&ke.alternate.length>0&&(Qe+=Ft+ue+er("else")+Ft+jr(ke.alternate,ce+1,X)),Qe+=Ft+ue+er("endif"),Qe}function Es(z,ce,X){const ue=X.repeat(ce);let pe="";if(z.iterable.type==="SelectExpression"){const Qe=z.iterable;pe=`${Kt(Qe.lhs)} if ${Kt(Qe.test)}`}else pe=Kt(z.iterable);let ke=ue+er("for",Kt(z.loopvar),"in",pe)+Ft+jr(z.body,ce+1,X);return z.defaultBlock.length>0&&(ke+=Ft+ue+er("else")+Ft+jr(z.defaultBlock,ce+1,X)),ke+=Ft+ue+er("endfor"),ke}function Ss(z,ce,X){const ue=X.repeat(ce),pe=Kt(z.assignee),ke=z.value?Kt(z.value):"",Qe=ue+er("set",`${pe}${z.value?" = "+ke:""}`);return z.body.length===0?Qe:Qe+Ft+jr(z.body,ce+1,X)+Ft+ue+er("endset")}function zt(z,ce,X){const ue=X.repeat(ce),pe=z.args.map(Kt).join(", ");return ue+er("macro",`${z.name.value}(${pe})`)+Ft+jr(z.body,ce+1,X)+Ft+ue+er("endmacro")}function Zs(z,ce,X){const ue=X.repeat(ce),pe=z.callerArgs&&z.callerArgs.length>0?`(${z.callerArgs.map(Kt).join(", ")})`:"",ke=Kt(z.call);let Qe=ue+er(`call${pe}`,ke)+Ft;return Qe+=jr(z.body,ce+1,X)+Ft,Qe+=ue+er("endcall"),Qe}function En(z,ce,X){const ue=X.repeat(ce),pe=z.filter.type==="Identifier"?z.filter.value:Kt(z.filter);let ke=ue+er("filter",pe)+Ft;return ke+=jr(z.body,ce+1,X)+Ft,ke+=ue+er("endfilter"),ke}function Kt(z,ce=-1){switch(z.type){case"SpreadExpression":return`*${Kt(z.argument)}`;case"Identifier":return z.value;case"IntegerLiteral":return`${z.value}`;case"FloatLiteral":return`${z.value}`;case"StringLiteral":return JSON.stringify(z.value);case"BinaryExpression":{const X=z,ue=Br(X),pe=Kt(X.left,ue),ke=Kt(X.right,ue+1),Qe=`${pe} ${X.operator.value} ${ke}`;return ue<ce?`(${Qe})`:Qe}case"UnaryExpression":{const X=z;return X.operator.value+(X.operator.value==="not"?" ":"")+Kt(X.argument,1/0)}case"CallExpression":{const X=z,ue=X.args.map(Kt).join(", ");return`${Kt(X.callee)}(${ue})`}case"MemberExpression":{const X=z;let ue=Kt(X.object);["Identifier","MemberExpression","CallExpression","StringLiteral","IntegerLiteral","FloatLiteral","ArrayLiteral","TupleLiteral","ObjectLiteral"].includes(X.object.type)||(ue=`(${ue})`);let pe=Kt(X.property);return!X.computed&&X.property.type!=="Identifier"&&(pe=`(${pe})`),X.computed?`${ue}[${pe}]`:`${ue}.${pe}`}case"FilterExpression":{const X=z,ue=Kt(X.operand,1/0);return X.filter.type==="CallExpression"?`${ue} | ${Kt(X.filter)}`:`${ue} | ${X.filter.value}`}case"SelectExpression":{const X=z;return`${Kt(X.lhs)} if ${Kt(X.test)}`}case"TestExpression":{const X=z;return`${Kt(X.operand)} is${X.negate?" not":""} ${X.test.value}`}case"ArrayLiteral":case"TupleLiteral":{const X=z.value.map(Kt),ue=z.type==="ArrayLiteral"?"[]":"()";return`${ue[0]}${X.join(", ")}${ue[1]}`}case"ObjectLiteral":return`{${Array.from(z.value.entries()).map(([ue,pe])=>`${Kt(ue)}: ${Kt(pe)}`).join(", ")}}`;case"SliceExpression":{const X=z,ue=X.start?Kt(X.start):"",pe=X.stop?Kt(X.stop):"",ke=X.step?`:${Kt(X.step)}`:"";return`${ue}:${pe}${ke}`}case"KeywordArgumentExpression":{const X=z;return`${X.key.value}=${Kt(X.value)}`}case"Ternary":{const X=z,ue=`${Kt(X.trueExpr)} if ${Kt(X.condition,0)} else ${Kt(X.falseExpr)}`;return ce>-1?`(${ue})`:ue}default:throw new Error(`Unknown expression type: ${z.type}`)}}var Js=class{parsed;constructor(z){const ce=_(z,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=Te(ce)}render(z){const ce=new pt;if(lt(ce),z)for(const[pe,ke]of Object.entries(z))ce.set(pe,ke);return new Mt(ce).run(this.parsed).value}format(z){return $r(this.parsed,z?.indent||"	")}}}),"./src/backends/onnx.js":((e,n,t)=>{var a;t.r(n),t.d(n,{Tensor:()=>d.Tensor,createInferenceSession:()=>L,deviceToExecutionProviders:()=>v,isONNXProxy:()=>k,isONNXTensor:()=>P,runInferenceSession:()=>I});var i=t("./src/env.js"),l=t("?2ce3"),u=t("onnxruntime-web"),d=t("onnxruntime-common");const f=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),h=[];let _,m;const p=Symbol.for("onnxruntime");if(p in globalThis)m=globalThis[p];else if(i.apis.IS_NODE_ENV){switch(m=l??(a||(a=t.t(l,2))),process.platform){case"win32":h.push("dml");break;case"linux":process.arch==="x64"&&h.push("cuda");break}h.push("cpu"),_=["cpu"]}else m=u,i.apis.IS_WEBNN_AVAILABLE&&h.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),i.apis.IS_WEBGPU_AVAILABLE&&h.push("webgpu"),h.push("wasm"),_=["wasm"];const y=m.InferenceSession;function v(C=null){if(!C)return _;switch(C){case"auto":return h;case"gpu":return h.filter(D=>["webgpu","cuda","dml","webnn-gpu"].includes(D))}if(h.includes(C))return[f[C]??C];throw new Error(`Unsupported device: "${C}". Should be one of: ${h.join(", ")}.`)}let x=null;async function L(C,D,V){x&&await x;const U=y.create(C,D);x??=U;const ne=await U;return ne.config=V,ne}let T=Promise.resolve();const E=i.apis.IS_BROWSER_ENV||i.apis.IS_WEBWORKER_ENV;async function I(C,D){const V=()=>C.run(D);return await(E?T=T.then(V):V())}function P(C){return C instanceof m.Tensor}const S=m?.env;S?.wasm&&(!(typeof ServiceWorkerGlobalScope<"u"&&self instanceof ServiceWorkerGlobalScope)&&!S.wasm.wasmPaths&&(S.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${i.env.version}/dist/`),S.wasm.proxy=!1),S?.webgpu&&(S.webgpu.powerPreference="high-performance");function k(){return S?.wasm?.proxy}i.env.backends.onnx=S}),"./src/base/feature_extraction_utils.js":((e,n,t)=>{t.r(n),t.d(n,{FeatureExtractor:()=>u,validate_audio_inputs:()=>d});var a=t("./src/utils/constants.js"),i=t("./src/utils/generic.js"),l=t("./src/utils/hub.js");class u extends i.Callable{constructor(h){super(),this.config=h}static async from_pretrained(h,_={}){const m=await(0,l.getModelJSON)(h,a.FEATURE_EXTRACTOR_NAME,!0,_);return new this(m)}}function d(f,h){if(!(f instanceof Float32Array||f instanceof Float64Array))throw new Error(`${h} expects input to be a Float32Array or a Float64Array, but got ${f?.constructor?.name??typeof f} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}}),"./src/base/image_processors_utils.js":((e,n,t)=>{t.r(n),t.d(n,{ImageProcessor:()=>P,center_to_corners_format:()=>m,post_process_instance_segmentation:()=>I,post_process_object_detection:()=>p,post_process_panoptic_segmentation:()=>E,post_process_semantic_segmentation:()=>y});var a=t("./src/utils/generic.js"),i=t("./src/utils/tensor.js"),l=t("./src/utils/maths.js");t("./src/utils/image.js");var u=t("./src/utils/core.js"),d=t("./src/utils/hub.js"),f=t("./src/utils/constants.js");function h(S,k,C=0,D=null){const V=S/k;let U=(0,l.bankers_round)(V)*k;return D!==null&&U>D&&(U=Math.floor(V)*k),U<C&&(U=Math.ceil(V)*k),U}function _([S,k],C){return[Math.max(Math.floor(S/C),1)*C,Math.max(Math.floor(k/C),1)*C]}function m([S,k,C,D]){return[S-C/2,k-D/2,S+C/2,k+D/2]}function p(S,k=.5,C=null,D=!1){const V=S.logits,U=S.pred_boxes,[ne,ee,H]=V.dims;if(C!==null&&C.length!==ne)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let oe=[];for(let ae=0;ae<ne;++ae){let W=C!==null?C[ae]:null,te={boxes:[],classes:[],scores:[]},ie=V[ae],_e=U[ae];for(let q=0;q<ee;++q){let B=ie[q],R=[],Q;if(D){Q=B.sigmoid().data;for(let G=0;G<Q.length;++G)Q[G]>k&&R.push(G)}else{let G=(0,l.max)(B.data)[1];if(G===H-1||(Q=(0,l.softmax)(B.data),Q[G]<k))continue;R.push(G)}for(const G of R){let fe=_e[q].data;fe=m(fe),W!==null&&(fe=fe.map((Te,ze)=>Te*W[(ze+1)%2])),te.boxes.push(fe),te.classes.push(G),te.scores.push(Q[G])}}oe.push(te)}return oe}function y(S,k=null){const C=S.logits,D=C.dims[0];if(k!==null&&k.length!==D)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const V=[];for(let U=0;U<D;++U){const ne=k!==null?k[U]:null;let ee=C[U];ne!==null&&(ee=(0,i.interpolate)(ee,ne,"bilinear",!1));const[H,oe]=ne??ee.dims.slice(-2),ae=new i.Tensor("int32",new Int32Array(H*oe),[H,oe]),W=ee[0].data,te=ae.data;for(let q=1;q<ee.dims[0];++q){const B=ee[q].data;for(let R=0;R<B.length;++R)B[R]>W[R]&&(W[R]=B[R],te[R]=q)}const ie=new Array(ee.dims[0]);for(let q=0;q<te.length;++q){const B=te[q];ie[B]=B}const _e=ie.filter(q=>q!==void 0);V.push({segmentation:ae,labels:_e})}return V}function v(S,k,C,D){const V=[],U=[],ne=[];for(let ee=0;ee<S.dims[0];++ee){const H=S[ee],oe=k[ee],ae=(0,l.max)(H.data)[1];if(ae===D)continue;const te=(0,l.softmax)(H.data)[ae];te>C&&(V.push(oe),U.push(te),ne.push(ae))}return[V,U,ne]}function x(S,k,C,D=.5,V=.8){const U=[];let ne=0,ee=0;const H=k[C].data;for(let ae=0;ae<S.length;++ae)S[ae]===C&&(U.push(ae),++ne),H[ae]>=D&&++ee;let oe=ne>0&&ee>0;return oe&&(oe=ne/ee>V),[oe,U]}function L(S,k,C,D,V,U=null,ne=null){const[ee,H]=ne??S[0].dims,oe=new i.Tensor("int32",new Int32Array(ee*H),[ee,H]),ae=[];if(ne!==null)for(let q=0;q<S.length;++q)S[q]=(0,i.interpolate)(S[q],ne,"bilinear",!1);const W=new Int32Array(S[0].data.length),te=new Float32Array(S[0].data.length);for(let q=0;q<S.length;++q){let B=k[q];const R=S[q].data;for(let Q=0;Q<R.length;++Q)R[Q]*=B,R[Q]>te[Q]&&(W[Q]=q,te[Q]=R[Q])}let ie=0;const _e=oe.data;for(let q=0;q<C.length;++q){const B=C[q],[R,Q]=x(W,S,q,D,V);if(R){++ie;for(const G of Q)_e[G]=ie;ae.push({id:ie,label_id:B,score:k[q]})}}return[oe,ae]}function T(S,k,C=28,D=3136,V=784*1280){if(S<C||k<C)throw new Error(`height:${S} or width:${k} must be larger than factor:${C}`);if(Math.max(S,k)/Math.min(S,k)>200)throw new Error(`absolute aspect ratio must be smaller than 200, got ${Math.max(S,k)/Math.min(S,k)}`);let U=Math.round(S/C)*C,ne=Math.round(k/C)*C;if(U*ne>V){const ee=Math.sqrt(S*k/V);U=Math.floor(S/ee/C)*C,ne=Math.floor(k/ee/C)*C}else if(U*ne<D){const ee=Math.sqrt(D/(S*k));U=Math.ceil(S*ee/C)*C,ne=Math.ceil(k*ee/C)*C}return[U,ne]}function E(S,k=.5,C=.5,D=.8,V=null,U=null){V===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),V=new Set);const ne=S.class_queries_logits??S.logits,H=(S.masks_queries_logits??S.pred_masks).sigmoid();let[oe,ae,W]=ne.dims;if(W-=1,U!==null&&U.length!==oe)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let te=[];for(let ie=0;ie<oe;++ie){let _e=U!==null?U[ie]:null,q=ne[ie],B=H[ie],[R,Q,G]=v(q,B,k,W);if(G.length===0){let[ze,Ue]=_e??B.dims.slice(-2),ft=new i.Tensor("int32",new Int32Array(ze*Ue).fill(-1),[ze,Ue]);te.push({segmentation:ft,segments_info:[]});continue}let[fe,Te]=L(R,Q,G,C,D,V,_e);te.push({segmentation:fe,segments_info:Te})}return te}function I(S,k=.5,C=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class P extends a.Callable{constructor(k){super(),this.image_mean=k.image_mean??k.mean,this.image_std=k.image_std??k.std,this.resample=k.resample??2,this.do_rescale=k.do_rescale??!0,this.rescale_factor=k.rescale_factor??1/255,this.do_normalize=k.do_normalize,this.do_thumbnail=k.do_thumbnail,this.size=k.size??k.image_size,this.do_resize=k.do_resize??this.size!==void 0,this.size_divisibility=k.size_divisibility??k.size_divisor,this.do_center_crop=k.do_center_crop,this.crop_size=k.crop_size,this.do_convert_rgb=k.do_convert_rgb??!0,this.do_crop_margin=k.do_crop_margin,this.pad_size=k.pad_size,this.do_pad=k.do_pad,this.min_pixels=k.min_pixels,this.max_pixels=k.max_pixels,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=k.do_flip_channel_order??!1,this.config=k}async thumbnail(k,C,D=2){const V=k.height,U=k.width,ne=C.height,ee=C.width;let H=Math.min(V,ne),oe=Math.min(U,ee);return H===V&&oe===U?k:(V>U?oe=Math.floor(U*H/V):U>V&&(H=Math.floor(V*oe/U)),await k.resize(oe,H,{resample:D}))}async crop_margin(k,C=200){const D=k.clone().grayscale(),V=(0,l.min)(D.data)[0],ne=(0,l.max)(D.data)[0]-V;if(ne===0)return k;const ee=C/255;let H=D.width,oe=D.height,ae=0,W=0;const te=D.data;for(let ie=0;ie<D.height;++ie){const _e=ie*D.width;for(let q=0;q<D.width;++q)(te[_e+q]-V)/ne<ee&&(H=Math.min(H,q),oe=Math.min(oe,ie),ae=Math.max(ae,q),W=Math.max(W,ie))}return k=await k.crop([H,oe,ae,W]),k}pad_image(k,C,D,{mode:V="constant",center:U=!1,constant_values:ne=0}={}){const[ee,H,oe]=C;let ae,W;if(typeof D=="number"?(ae=D,W=D):D==="square"?ae=W=Math.max(ee,H):(ae=D.width,W=D.height),ae!==H||W!==ee){const te=new Float32Array(ae*W*oe);if(Array.isArray(ne))for(let q=0;q<te.length;++q)te[q]=ne[q%oe];else ne!==0&&te.fill(ne);const[ie,_e]=U?[Math.floor((ae-H)/2),Math.floor((W-ee)/2)]:[0,0];for(let q=0;q<ee;++q){const B=(q+_e)*ae,R=q*H;for(let Q=0;Q<H;++Q){const G=(B+Q+ie)*oe,fe=(R+Q)*oe;for(let Te=0;Te<oe;++Te)te[G+Te]=k[fe+Te]}}if(V==="symmetric"){if(U)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const q=ee-1,B=H-1;for(let R=0;R<W;++R){const Q=R*ae,G=(0,u.calculateReflectOffset)(R,q)*H;for(let fe=0;fe<ae;++fe){if(R<ee&&fe<H)continue;const Te=(Q+fe)*oe,ze=(G+(0,u.calculateReflectOffset)(fe,B))*oe;for(let Ue=0;Ue<oe;++Ue)te[Te+Ue]=k[ze+Ue]}}}k=te,C=[W,ae,oe]}return[k,C]}rescale(k){for(let C=0;C<k.length;++C)k[C]=this.rescale_factor*k[C]}get_resize_output_image_size(k,C){const[D,V]=k.size;let U,ne;if(this.do_thumbnail){const{height:ee,width:H}=C;U=Math.min(ee,H)}else Number.isInteger(C)?(U=C,ne=this.config.max_size??U):C!==void 0&&(U=C.shortest_edge,ne=C.longest_edge);if(U!==void 0||ne!==void 0){const ee=U===void 0?1:Math.max(U/D,U/V),H=D*ee,oe=V*ee,ae=ne===void 0?1:Math.min(ne/H,ne/oe);let W=Math.floor(Number((H*ae).toFixed(2))),te=Math.floor(Number((oe*ae).toFixed(2)));return this.size_divisibility!==void 0&&([W,te]=_([W,te],this.size_divisibility)),[W,te]}else if(C!==void 0&&C.width!==void 0&&C.height!==void 0){let ee=C.width,H=C.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let oe=H/V,ae=ee/D;Math.abs(1-ae)<Math.abs(1-oe)?oe=ae:ae=oe,H=h(oe*V,this.config.ensure_multiple_of),ee=h(ae*D,this.config.ensure_multiple_of)}return[ee,H]}else{if(this.size_divisibility!==void 0)return _([D,V],this.size_divisibility);if(this.min_pixels!==void 0&&this.max_pixels!==void 0){const ee=this.config.patch_size*this.config.merge_size;return T(V,D,ee,this.min_pixels,this.max_pixels)}else throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(C)}`)}}async resize(k){const[C,D]=this.get_resize_output_image_size(k,this.size);return await k.resize(C,D,{resample:this.resample})}async preprocess(k,{do_normalize:C=null,do_pad:D=null,do_convert_rgb:V=null,do_convert_grayscale:U=null,do_flip_channel_order:ne=null}={}){this.do_crop_margin&&(k=await this.crop_margin(k));const[ee,H]=k.size;if(V??this.do_convert_rgb?k=k.rgb():U&&(k=k.grayscale()),this.do_resize&&(k=await this.resize(k)),this.do_thumbnail&&(k=await this.thumbnail(k,this.size,this.resample)),this.do_center_crop){let ie,_e;Number.isInteger(this.crop_size)?(ie=this.crop_size,_e=this.crop_size):(ie=this.crop_size.width,_e=this.crop_size.height),k=await k.center_crop(ie,_e)}const oe=[k.height,k.width];let ae=Float32Array.from(k.data),W=[k.height,k.width,k.channels];if(this.do_rescale&&this.rescale(ae),C??this.do_normalize){let ie=this.image_mean;Array.isArray(this.image_mean)||(ie=new Array(k.channels).fill(ie));let _e=this.image_std;if(Array.isArray(this.image_std)||(_e=new Array(k.channels).fill(ie)),ie.length!==k.channels||_e.length!==k.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${ie.length}) and \`image_std\` (${_e.length}) must match the number of channels in the image (${k.channels}).`);for(let q=0;q<ae.length;q+=k.channels)for(let B=0;B<k.channels;++B)ae[q+B]=(ae[q+B]-ie[B])/_e[B]}if(D??this.do_pad){if(this.pad_size)[ae,W]=this.pad_image(ae,[k.height,k.width,k.channels],this.pad_size);else if(this.size_divisibility){const[ie,_e]=_([W[1],W[0]],this.size_divisibility);[ae,W]=this.pad_image(ae,W,{width:ie,height:_e})}}if(ne??this.do_flip_channel_order){if(W[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let ie=0;ie<ae.length;ie+=3){const _e=ae[ie];ae[ie]=ae[ie+2],ae[ie+2]=_e}}const te=new i.Tensor("float32",ae,W).permute(2,0,1);return{original_size:[H,ee],reshaped_input_size:oe,pixel_values:te}}async _call(k,...C){Array.isArray(k)||(k=[k]);const D=await Promise.all(k.map(U=>this.preprocess(U)));return{pixel_values:(0,i.stack)(D.map(U=>U.pixel_values),0),original_sizes:D.map(U=>U.original_size),reshaped_input_sizes:D.map(U=>U.reshaped_input_size)}}static async from_pretrained(k,C={}){const D=await(0,d.getModelJSON)(k,f.IMAGE_PROCESSOR_NAME,!0,C);return new this(D)}}}),"./src/base/processing_utils.js":((e,n,t)=>{t.r(n),t.d(n,{Processor:()=>u});var a=t("./src/utils/constants.js"),i=t("./src/utils/generic.js"),l=t("./src/utils/hub.js");class u extends i.Callable{static classes=["image_processor_class","tokenizer_class","feature_extractor_class"];static uses_processor_config=!1;static uses_chat_template_file=!1;constructor(f,h,_){super(),this.config=f,this.components=h,this.chat_template=_}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(f,h={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(f,{tokenize:!1,chat_template:this.chat_template??void 0,...h})}batch_decode(...f){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...f)}decode(...f){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.decode(...f)}async _call(f,...h){for(const _ of[this.image_processor,this.feature_extractor,this.tokenizer])if(_)return _(f,...h);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(f,h={}){const[_,m,p]=await Promise.all([this.uses_processor_config?(0,l.getModelJSON)(f,a.PROCESSOR_NAME,!0,h):{},Promise.all(this.classes.filter(y=>y in this).map(async y=>{const v=await this[y].from_pretrained(f,h);return[y.replace(/_class$/,""),v]})).then(Object.fromEntries),this.uses_chat_template_file?(0,l.getModelText)(f,a.CHAT_TEMPLATE_NAME,!0,h):null]);return new this(_,m,p)}}}),"./src/configs.js":((e,n,t)=>{t.r(n),t.d(n,{AutoConfig:()=>_,PretrainedConfig:()=>h,getCacheShapes:()=>d});var a=t("./src/utils/core.js"),i=t("./src/utils/hub.js");async function l(m,p){return await(0,i.getModelJSON)(m,"config.json",!0,p)}function u(m){const p={};let y={};switch(m.model_type){case"llava":case"paligemma":case"gemma3":case"florence2":case"llava_onevision":case"idefics3":case"ultravox":case"voxtral":case"smolvlm":case"gemma3n":y=u(m.text_config);break;case"moondream1":y=u(m.phi_config);break;case"musicgen":y=u(m.decoder);break;case"multi_modality":y=u(m.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":p.num_heads="n_head",p.num_layers="n_layer",p.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":case"modernbert-decoder":p.num_heads="num_attention_heads",p.num_layers="num_hidden_layers",p.hidden_size="hidden_size";break;case"llama":case"llama4_text":case"arcee":case"lfm2":case"smollm3":case"olmo":case"olmo2":case"mobilellm":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":case"llava_qwen2":p.num_heads="num_key_value_heads",p.num_layers="num_hidden_layers",p.hidden_size="hidden_size",p.num_attention_heads="num_attention_heads",p.dim_kv="head_dim";break;case"qwen3":case"gemma":case"gemma2":case"vaultgemma":case"gemma3_text":case"gemma3n_text":case"glm":case"helium":case"ernie4_5":p.num_heads="num_key_value_heads",p.num_layers="num_hidden_layers",p.dim_kv="head_dim";break;case"openelm":p.num_heads="num_kv_heads",p.num_layers="num_transformer_layers",p.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":p.num_heads="num_heads",p.num_layers="num_layers",p.hidden_size="hidden_size";break;case"bloom":p.num_heads="n_head",p.num_layers="n_layer",p.hidden_size="hidden_size";break;case"mpt":p.num_heads="n_heads",p.num_layers="n_layers",p.hidden_size="d_model";break;case"exaone":p.num_heads="num_key_value_heads",p.num_layers="num_layers",p.dim_kv="head_dim",p.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":p.num_decoder_layers="num_decoder_layers",p.num_decoder_heads="num_heads",p.decoder_dim_kv="d_kv",p.num_encoder_layers="num_layers",p.num_encoder_heads="num_heads",p.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"lite-whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":p.num_decoder_layers="decoder_layers",p.num_decoder_heads="decoder_attention_heads",p.decoder_hidden_size="d_model",p.num_encoder_layers="encoder_layers",p.num_encoder_heads="encoder_attention_heads",p.encoder_hidden_size="d_model";break;case"speecht5":p.num_decoder_layers="decoder_layers",p.num_decoder_heads="decoder_attention_heads",p.decoder_hidden_size="hidden_size",p.num_encoder_layers="encoder_layers",p.num_encoder_heads="encoder_attention_heads",p.encoder_hidden_size="hidden_size";break;case"trocr":p.num_encoder_layers=p.num_decoder_layers="decoder_layers",p.num_encoder_heads=p.num_decoder_heads="decoder_attention_heads",p.encoder_hidden_size=p.decoder_hidden_size="d_model";break;case"musicgen_decoder":p.num_encoder_layers=p.num_decoder_layers="num_hidden_layers",p.num_encoder_heads=p.num_decoder_heads="num_attention_heads",p.encoder_hidden_size=p.decoder_hidden_size="hidden_size";break;case"moonshine":p.num_decoder_layers="decoder_num_hidden_layers",p.num_decoder_heads="decoder_num_key_value_heads",p.num_encoder_layers="encoder_num_hidden_layers",p.num_encoder_heads="encoder_num_key_value_heads",p.encoder_hidden_size=p.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const x=u(m.decoder),L="num_decoder_layers"in x,T=(0,a.pick)(m,["model_type","is_encoder_decoder"]);return L?(T.num_decoder_layers=x.num_decoder_layers,T.num_decoder_heads=x.num_decoder_heads,T.decoder_hidden_size=x.decoder_hidden_size,T.num_encoder_layers=x.num_encoder_layers,T.num_encoder_heads=x.num_encoder_heads,T.encoder_hidden_size=x.encoder_hidden_size):(T.num_layers=x.num_layers,T.num_heads=x.num_heads,T.hidden_size=x.hidden_size),T}const v={...y,...(0,a.pick)(m,["model_type","multi_query","is_encoder_decoder"])};for(const x in p)v[x]=m[p[x]];return v}function d(m,p){if(m.model_type==="lfm2"){const y=p?.prefix??"past_key_values",v=y==="present"?"present":"past",x={},{layer_types:L,num_attention_heads:T,num_key_value_heads:E,hidden_size:I,conv_L_cache:P}=m,S=I/T,k=p?.batch_size??1;for(let C=0;C<L.length;++C)if(L[C]==="full_attention")for(const D of["key","value"])x[`${y}.${C}.${D}`]=[k,E,0,S];else if(L[C]==="conv")x[`${v}_conv.${C}`]=[k,I,P];else throw new Error(`Unsupported layer type: ${L[C]}`);return x}return f(m,p)}function f(m,{prefix:p="past_key_values",batch_size:y=1}={}){const v={},x=m.normalized_config;if(x.is_encoder_decoder&&"num_encoder_heads"in x&&"num_decoder_heads"in x){const L=x.encoder_dim_kv??x.encoder_hidden_size/x.num_encoder_heads,T=x.decoder_dim_kv??x.decoder_hidden_size/x.num_decoder_heads,E=[y,x.num_encoder_heads,0,L],I=[y,x.num_decoder_heads,0,T];for(let P=0;P<x.num_decoder_layers;++P)v[`${p}.${P}.encoder.key`]=E,v[`${p}.${P}.encoder.value`]=E,v[`${p}.${P}.decoder.key`]=I,v[`${p}.${P}.decoder.value`]=I}else{const L=x.num_heads,T=x.num_layers,E=x.dim_kv??x.hidden_size/(x.num_attention_heads??L);if(x.model_type==="falcon"){const I=[y*L,0,E];for(let P=0;P<T;++P)v[`${p}.${P}.key`]=I,v[`${p}.${P}.value`]=I}else if(x.multi_query){const I=[y*L,0,2*E];for(let P=0;P<T;++P)v[`${p}.${P}.key_value`]=I}else if(x.model_type==="bloom"){const I=[y*L,E,0],P=[y*L,0,E];for(let S=0;S<T;++S)v[`${p}.${S}.key`]=I,v[`${p}.${S}.value`]=P}else if(x.model_type==="openelm")for(let I=0;I<T;++I){const P=[y,L[I],0,E];v[`${p}.${I}.key`]=P,v[`${p}.${I}.value`]=P}else{const I=[y,L,0,E];for(let P=0;P<T;++P)v[`${p}.${P}.key`]=I,v[`${p}.${P}.value`]=I}}return v}class h{model_type=null;is_encoder_decoder=!1;max_position_embeddings;"transformers.js_config";constructor(p){Object.assign(this,p),this.normalized_config=u(this)}static async from_pretrained(p,{progress_callback:y=null,config:v=null,cache_dir:x=null,local_files_only:L=!1,revision:T="main"}={}){v&&!(v instanceof h)&&(v=new h(v));const E=v??await l(p,{progress_callback:y,config:v,cache_dir:x,local_files_only:L,revision:T});return new this(E)}}class _{static async from_pretrained(...p){return h.from_pretrained(...p)}}}),"./src/env.js":((e,n,t)=>{t.r(n),t.d(n,{apis:()=>T,env:()=>C});var a=t("?db59"),i=t("?383f"),l=t("?fa4b");const u="3.7.3",d=typeof window<"u"&&typeof window.document<"u",f=typeof self<"u"&&["DedicatedWorkerGlobalScope","ServiceWorkerGlobalScope","SharedWorkerGlobalScope"].includes(self.constructor?.name),h=typeof self<"u"&&"caches"in self,_=typeof navigator<"u"&&"gpu"in navigator,m=typeof navigator<"u"&&"ml"in navigator,p=typeof process<"u",y=p&&process?.release?.name==="node",v=!D(a),x=!D(i),L=typeof globalThis.Deno<"u",T=Object.freeze({IS_BROWSER_ENV:d,IS_WEBWORKER_ENV:f,IS_WEB_CACHE_AVAILABLE:h,IS_WEBGPU_AVAILABLE:_,IS_WEBNN_AVAILABLE:m,IS_PROCESS_AVAILABLE:p,IS_NODE_ENV:y,IS_FS_AVAILABLE:v,IS_PATH_AVAILABLE:x}),E=v&&x;let I="./";if(E){const V=Object(import.meta).url;V?I=i.dirname(i.dirname(l.fileURLToPath(V))):typeof __dirname<"u"&&(I=i.dirname(__dirname))}const P=E?i.join(I,"/.cache/"):null,S="/models/",k=E?i.join(I,S):S,C={version:u,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(d||f),localModelPath:k,useFS:v,useBrowserCache:h&&!L,useFSCache:v,cacheDir:P,useCustomCache:!1,customCache:null};function D(V){return Object.keys(V).length===0}}),"./src/generation/configuration_utils.js":((e,n,t)=>{t.r(n),t.d(n,{GenerationConfig:()=>i});var a=t("./src/utils/core.js");class i{max_length=20;max_new_tokens=null;min_length=0;min_new_tokens=null;early_stopping=!1;max_time=null;do_sample=!1;num_beams=1;num_beam_groups=1;penalty_alpha=null;use_cache=!0;temperature=1;top_k=50;top_p=1;typical_p=1;epsilon_cutoff=0;eta_cutoff=0;diversity_penalty=0;repetition_penalty=1;encoder_repetition_penalty=1;length_penalty=1;no_repeat_ngram_size=0;bad_words_ids=null;force_words_ids=null;renormalize_logits=!1;constraints=null;forced_bos_token_id=null;forced_eos_token_id=null;remove_invalid_values=!1;exponential_decay_length_penalty=null;suppress_tokens=null;streamer=null;begin_suppress_tokens=null;forced_decoder_ids=null;guidance_scale=null;num_return_sequences=1;output_attentions=!1;output_hidden_states=!1;output_scores=!1;return_dict_in_generate=!1;pad_token_id=null;bos_token_id=null;eos_token_id=null;encoder_no_repeat_ngram_size=0;decoder_start_token_id=null;generation_kwargs={};constructor(u){Object.assign(this,(0,a.pick)(u,Object.getOwnPropertyNames(this)))}}}),"./src/generation/logits_process.js":((e,n,t)=>{t.r(n),t.d(n,{ClassifierFreeGuidanceLogitsProcessor:()=>T,ForcedBOSTokenLogitsProcessor:()=>f,ForcedEOSTokenLogitsProcessor:()=>h,LogitsProcessor:()=>l,LogitsProcessorList:()=>d,LogitsWarper:()=>u,MinLengthLogitsProcessor:()=>v,MinNewTokensLengthLogitsProcessor:()=>x,NoBadWordsLogitsProcessor:()=>L,NoRepeatNGramLogitsProcessor:()=>p,RepetitionPenaltyLogitsProcessor:()=>y,SuppressTokensAtBeginLogitsProcessor:()=>_,TemperatureLogitsWarper:()=>E,TopKLogitsWarper:()=>P,TopPLogitsWarper:()=>I,WhisperTimeStampLogitsProcessor:()=>m});var a=t("./src/utils/generic.js");t("./src/utils/tensor.js");var i=t("./src/utils/maths.js");class l extends a.Callable{_call(k,C){throw Error("`_call` should be implemented in a subclass")}}class u extends a.Callable{_call(k,C){throw Error("`_call` should be implemented in a subclass")}}class d extends a.Callable{constructor(){super(),this.processors=[]}push(k){this.processors.push(k)}extend(k){this.processors.push(...k)}_call(k,C){let D=C;for(const V of this.processors)D=V(k,D);return D}[Symbol.iterator](){return this.processors.values()}}class f extends l{constructor(k){super(),this.bos_token_id=k}_call(k,C){for(let D=0;D<k.length;++D)if(k[D].length===1){const V=C[D].data;V.fill(-1/0),V[this.bos_token_id]=0}return C}}class h extends l{constructor(k,C){super(),this.max_length=k,this.eos_token_id=Array.isArray(C)?C:[C]}_call(k,C){for(let D=0;D<k.length;++D)if(k[D].length===this.max_length-1){const V=C[D].data;V.fill(-1/0);for(const U of this.eos_token_id)V[U]=0}return C}}class _ extends l{constructor(k,C){super(),this.begin_suppress_tokens=k,this.begin_index=C}_call(k,C){for(let D=0;D<k.length;++D)if(k[D].length===this.begin_index){const V=C[D].data;for(const U of this.begin_suppress_tokens)V[U]=-1/0}return C}}class m extends l{constructor(k,C){super(),this.eos_token_id=Array.isArray(k.eos_token_id)?k.eos_token_id[0]:k.eos_token_id,this.no_timestamps_token_id=k.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=C.length,C.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=k.max_initial_timestamp_index}_call(k,C){for(let D=0;D<k.length;++D){const V=C[D].data;if(V[this.no_timestamps_token_id]=-1/0,k[D].length===this.begin_index-1){V.fill(-1/0),V[this.timestamp_begin]=0;continue}const U=k[D].slice(this.begin_index),ne=U.length>=1&&U[U.length-1]>=this.timestamp_begin,ee=U.length<2||U[U.length-2]>=this.timestamp_begin;if(ne&&(ee?V.subarray(this.timestamp_begin).fill(-1/0):V.subarray(0,this.eos_token_id).fill(-1/0)),k[D].length===this.begin_index&&this.max_initial_timestamp_index!==null){const W=this.timestamp_begin+this.max_initial_timestamp_index;V.subarray(W+1).fill(-1/0)}const H=(0,i.log_softmax)(V),oe=Math.log(H.subarray(this.timestamp_begin).map(Math.exp).reduce((W,te)=>W+te)),ae=(0,i.max)(H.subarray(0,this.timestamp_begin))[0];oe>ae&&V.subarray(0,this.timestamp_begin).fill(-1/0)}return C}}class p extends l{constructor(k){super(),this.no_repeat_ngram_size=k}getNgrams(k){const C=k.length,D=[];for(let U=0;U<C+1-this.no_repeat_ngram_size;++U){const ne=[];for(let ee=0;ee<this.no_repeat_ngram_size;++ee)ne.push(k[U+ee]);D.push(ne.map(Number))}const V=new Map;for(const U of D){const ne=U.slice(0,U.length-1),ee=JSON.stringify(ne),H=V.get(ee)??[];H.push(U[U.length-1]),V.set(ee,H)}return V}getGeneratedNgrams(k,C){const D=C.slice(C.length+1-this.no_repeat_ngram_size,C.length);return k.get(JSON.stringify(D.map(Number)))??[]}calcBannedNgramTokens(k){const C=[];if(k.length+1<this.no_repeat_ngram_size)return C;{const D=this.getNgrams(k);return this.getGeneratedNgrams(D,k)}}_call(k,C){for(let D=0;D<k.length;++D){const V=C[D].data,U=this.calcBannedNgramTokens(k[D]);for(const ne of U)V[ne]=-1/0}return C}}class y extends l{constructor(k){super(),this.penalty=k}_call(k,C){for(let D=0;D<k.length;++D){const V=C[D].data;for(const U of new Set(k[D])){const ne=Number(U);V[ne]<0?V[ne]*=this.penalty:V[ne]/=this.penalty}}return C}}class v extends l{constructor(k,C){super(),this.min_length=k,this.eos_token_id=Array.isArray(C)?C:[C]}_call(k,C){for(let D=0;D<k.length;++D)if(k[D].length<this.min_length){const V=C[D].data;for(const U of this.eos_token_id)V[U]=-1/0}return C}}class x extends l{constructor(k,C,D){super(),this.prompt_length_to_skip=k,this.min_new_tokens=C,this.eos_token_id=Array.isArray(D)?D:[D]}_call(k,C){for(let D=0;D<k.length;++D)if(k[D].length-this.prompt_length_to_skip<this.min_new_tokens){const U=C[D].data;for(const ne of this.eos_token_id)U[ne]=-1/0}return C}}class L extends l{constructor(k,C){super(),this.bad_words_ids=k,this.eos_token_id=Array.isArray(C)?C:[C]}_call(k,C){for(let D=0;D<k.length;++D){const V=C[D].data,U=k[D];for(const ne of this.bad_words_ids){if(U.length<ne.length-1)continue;let ee=!0;for(let H=1;H<=ne.length-1;++H)if(ne.at(-H-1)!=U.at(-H)){ee=!1;break}ee&&(V[ne.at(-1)]=-1/0)}}return C}}class T extends l{constructor(k){if(super(),k<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${k}.`);this.guidance_scale=k}_call(k,C){if(C.dims[0]!==2*k.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${C.dims[0]} for the logits and ${k.length} for the input ids.`);const D=k.length,V=C.slice([0,D],null),U=C.slice([D,C.dims[0]],null);for(let ne=0;ne<U.data.length;++ne)U.data[ne]+=(V.data[ne]-U.data[ne])*this.guidance_scale;return U}}class E extends u{constructor(k){super(),this.temperature=k}_call(k,C){const D=C.data;for(let V=0;V<D.length;++V)D[V]/=this.temperature;return C}}class I extends u{constructor(k,{filter_value:C=-1/0,min_tokens_to_keep:D=1}={}){if(super(),k<0||k>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${k}`);if(!Number.isInteger(D)||D<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${D}`);this.top_p=k,this.filter_value=C,this.min_tokens_to_keep=D}}class P extends u{constructor(k,{filter_value:C=-1/0,min_tokens_to_keep:D=1}={}){if(super(),!Number.isInteger(k)||k<0)throw new Error(`\`top_k\` must be a positive integer, but is ${k}`);this.top_k=Math.max(k,D),this.filter_value=C}}}),"./src/generation/logits_sampler.js":((e,n,t)=>{t.r(n),t.d(n,{LogitsSampler:()=>u});var a=t("./src/utils/generic.js"),i=t("./src/utils/tensor.js"),l=t("./src/utils/maths.js");t("./src/generation/configuration_utils.js");class u extends a.Callable{constructor(m){super(),this.generation_config=m}async _call(m){return this.sample(m)}async sample(m){throw Error("sample should be implemented in subclasses.")}getLogits(m,p){let y=m.dims.at(-1),v=m.data;if(p===-1)v=v.slice(-y);else{let x=p*y;v=v.slice(x,x+y)}return v}randomSelect(m){let p=0;for(let v=0;v<m.length;++v)p+=m[v];let y=Math.random()*p;for(let v=0;v<m.length;++v)if(y-=m[v],y<=0)return v;return 0}static getSampler(m){if(m.do_sample)return new f(m);if(m.num_beams>1)return new h(m);if(m.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${m.num_return_sequences}.`);return new d(m)}}class d extends u{async sample(m){const p=(0,l.max)(m.data)[1];return[[BigInt(p),0]]}}class f extends u{async sample(m){let p=m.dims.at(-1);this.generation_config.top_k>0&&(p=Math.min(this.generation_config.top_k,p));const[y,v]=await(0,i.topk)(m,p),x=(0,l.softmax)(y.data);return Array.from({length:this.generation_config.num_beams},()=>{const L=this.randomSelect(x);return[v.data[L],Math.log(x[L])]})}}class h extends u{async sample(m){let p=m.dims.at(-1);this.generation_config.top_k>0&&(p=Math.min(this.generation_config.top_k,p));const[y,v]=await(0,i.topk)(m,p),x=(0,l.softmax)(y.data);return Array.from({length:this.generation_config.num_beams},(L,T)=>[v.data[T],Math.log(x[T])])}}}),"./src/generation/stopping_criteria.js":((e,n,t)=>{t.r(n),t.d(n,{EosTokenCriteria:()=>d,InterruptableStoppingCriteria:()=>f,MaxLengthCriteria:()=>u,StoppingCriteria:()=>i,StoppingCriteriaList:()=>l});var a=t("./src/utils/generic.js");class i extends a.Callable{_call(_,m){throw Error("StoppingCriteria needs to be subclassed")}}class l extends a.Callable{constructor(){super(),this.criteria=[]}push(_){this.criteria.push(_)}extend(_){_ instanceof l?_=_.criteria:_ instanceof i&&(_=[_]),this.criteria.push(..._)}_call(_,m){const p=new Array(_.length).fill(!1);for(const y of this.criteria){const v=y(_,m);for(let x=0;x<p.length;++x)p[x]||=v[x]}return p}[Symbol.iterator](){return this.criteria.values()}}class u extends i{constructor(_,m=null){super(),this.max_length=_,this.max_position_embeddings=m}_call(_){return _.map(m=>m.length>=this.max_length)}}class d extends i{constructor(_){super(),Array.isArray(_)||(_=[_]),this.eos_token_id=_}_call(_,m){return _.map(p=>{const y=p.at(-1);return this.eos_token_id.some(v=>y==v)})}}class f extends i{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(_,m){return new Array(_.length).fill(this.interrupted)}}}),"./src/generation/streamers.js":((e,n,t)=>{t.r(n),t.d(n,{BaseStreamer:()=>u,TextStreamer:()=>f,WhisperTextStreamer:()=>h});var a=t("./src/utils/core.js"),i=t("./src/tokenizers.js"),l=t("./src/env.js");class u{put(m){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const d=l.apis.IS_PROCESS_AVAILABLE?_=>process.stdout.write(_):_=>console.log(_);class f extends u{constructor(m,{skip_prompt:p=!1,callback_function:y=null,token_callback_function:v=null,skip_special_tokens:x=!0,decode_kwargs:L={},...T}={}){super(),this.tokenizer=m,this.skip_prompt=p,this.callback_function=y??d,this.token_callback_function=v,this.decode_kwargs={skip_special_tokens:x,...L,...T},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(m){if(m.length>1)throw Error("TextStreamer only supports batch size of 1");const p=this.next_tokens_are_prompt;if(p&&(this.next_tokens_are_prompt=!1,this.skip_prompt))return;const y=m[0];this.token_callback_function?.(y),this.token_cache=(0,a.mergeArrays)(this.token_cache,y);const v=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let x;p||v.endsWith(`
`)?(x=v.slice(this.print_len),this.token_cache=[],this.print_len=0):v.length>0&&(0,i.is_chinese_char)(v.charCodeAt(v.length-1))?(x=v.slice(this.print_len),this.print_len+=x.length):(x=v.slice(this.print_len,v.lastIndexOf(" ")+1),this.print_len+=x.length),this.on_finalized_text(x,!1)}end(){let m;this.token_cache.length>0?(m=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):m="",this.next_tokens_are_prompt=!0,this.on_finalized_text(m,!0)}on_finalized_text(m,p){m.length>0&&this.callback_function?.(m),p&&this.callback_function===d&&l.apis.IS_PROCESS_AVAILABLE&&this.callback_function?.(`
`)}}class h extends f{constructor(m,{skip_prompt:p=!1,callback_function:y=null,token_callback_function:v=null,on_chunk_start:x=null,on_chunk_end:L=null,on_finalize:T=null,time_precision:E=.02,skip_special_tokens:I=!0,decode_kwargs:P={}}={}){super(m,{skip_prompt:p,skip_special_tokens:I,callback_function:y,token_callback_function:v,decode_kwargs:P}),this.timestamp_begin=m.timestamp_begin,this.on_chunk_start=x,this.on_chunk_end=L,this.on_finalize=T,this.time_precision=E,this.waiting_for_timestamp=!1}put(m){if(m.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const p=m[0];if(p.length===1){const y=Number(p[0])-this.timestamp_begin;if(y>=0){const v=y*this.time_precision;this.waiting_for_timestamp?this.on_chunk_end?.(v):this.on_chunk_start?.(v),this.waiting_for_timestamp=!this.waiting_for_timestamp,this.token_callback_function?.(p);return}}return super.put(m)}end(){super.end(),this.on_finalize?.()}}}),"./src/models.js":((e,n,t)=>{t.r(n),t.d(n,{ASTForAudioClassification:()=>tu,ASTModel:()=>eu,ASTPreTrainedModel:()=>so,AlbertForMaskedLM:()=>dt,AlbertForQuestionAnswering:()=>wt,AlbertForSequenceClassification:()=>vt,AlbertModel:()=>gt,AlbertPreTrainedModel:()=>Ke,ArceeForCausalLM:()=>Ir,ArceeModel:()=>Pn,ArceePreTrainedModel:()=>gn,AutoModel:()=>hm,AutoModelForAudioClassification:()=>Lo,AutoModelForAudioFrameClassification:()=>lc,AutoModelForAudioTextToText:()=>Em,AutoModelForCTC:()=>rp,AutoModelForCausalLM:()=>Wn,AutoModelForDepthEstimation:()=>Mm,AutoModelForDocumentQuestionAnswering:()=>q_,AutoModelForImageClassification:()=>W_,AutoModelForImageFeatureExtraction:()=>sp,AutoModelForImageMatting:()=>bm,AutoModelForImageSegmentation:()=>H_,AutoModelForImageTextToText:()=>Tm,AutoModelForImageToImage:()=>wm,AutoModelForMaskGeneration:()=>Hd,AutoModelForMaskedLM:()=>tp,AutoModelForNormalEstimation:()=>xm,AutoModelForObjectDetection:()=>Ol,AutoModelForPoseEstimation:()=>Q_,AutoModelForQuestionAnswering:()=>G_,AutoModelForSemanticSegmentation:()=>K_,AutoModelForSeq2SeqLM:()=>_m,AutoModelForSequenceClassification:()=>pm,AutoModelForSpeechSeq2Seq:()=>Gd,AutoModelForTextToSpectrogram:()=>gm,AutoModelForTextToWaveform:()=>ym,AutoModelForTokenClassification:()=>mm,AutoModelForUniversalSegmentation:()=>Wd,AutoModelForVision2Seq:()=>vm,AutoModelForXVector:()=>Ia,AutoModelForZeroShotObjectDetection:()=>np,BartForConditionalGeneration:()=>vn,BartForSequenceClassification:()=>nr,BartModel:()=>us,BartPretrainedModel:()=>_r,BaseModelOutput:()=>Ae,BeitForImageClassification:()=>Sr,BeitModel:()=>Fn,BeitPreTrainedModel:()=>sn,BertForMaskedLM:()=>xe,BertForQuestionAnswering:()=>Ge,BertForSequenceClassification:()=>Ve,BertForTokenClassification:()=>Ee,BertModel:()=>De,BertPreTrainedModel:()=>Ne,BlenderbotForConditionalGeneration:()=>Yn,BlenderbotModel:()=>Mn,BlenderbotPreTrainedModel:()=>_n,BlenderbotSmallForConditionalGeneration:()=>ba,BlenderbotSmallModel:()=>cs,BlenderbotSmallPreTrainedModel:()=>Nn,BloomForCausalLM:()=>Xc,BloomModel:()=>Lr,BloomPreTrainedModel:()=>gf,CLIPModel:()=>Wa,CLIPPreTrainedModel:()=>ta,CLIPSegForImageSegmentation:()=>Ha,CLIPSegModel:()=>Hr,CLIPSegPreTrainedModel:()=>Ii,CLIPTextModel:()=>$i,CLIPTextModelWithProjection:()=>uu,CLIPVisionModel:()=>ao,CLIPVisionModelWithProjection:()=>rl,CamembertForMaskedLM:()=>At,CamembertForQuestionAnswering:()=>qt,CamembertForSequenceClassification:()=>mt,CamembertForTokenClassification:()=>Zt,CamembertModel:()=>Tt,CamembertPreTrainedModel:()=>Qe,CausalLMOutput:()=>zo,CausalLMOutputWithPast:()=>Sm,ChineseCLIPModel:()=>cu,ChineseCLIPPreTrainedModel:()=>$t,ClapAudioModelWithProjection:()=>kh,ClapModel:()=>oi,ClapPreTrainedModel:()=>Hi,ClapTextModelWithProjection:()=>Ah,CodeGenForCausalLM:()=>He,CodeGenModel:()=>ye,CodeGenPreTrainedModel:()=>re,CohereForCausalLM:()=>Vc,CohereModel:()=>mf,CoherePreTrainedModel:()=>Qa,ConvBertForMaskedLM:()=>Zs,ConvBertForQuestionAnswering:()=>Js,ConvBertForSequenceClassification:()=>En,ConvBertForTokenClassification:()=>Kt,ConvBertModel:()=>zt,ConvBertPreTrainedModel:()=>Ss,ConvNextForImageClassification:()=>Yf,ConvNextModel:()=>Xf,ConvNextPreTrainedModel:()=>Fu,ConvNextV2ForImageClassification:()=>Jf,ConvNextV2Model:()=>Zf,ConvNextV2PreTrainedModel:()=>Ru,DFineForObjectDetection:()=>ku,DFineModel:()=>vl,DFinePreTrainedModel:()=>Au,DINOv3ConvNextModel:()=>sh,DINOv3ConvNextPreTrainedModel:()=>ju,DINOv3ViTModel:()=>rh,DINOv3ViTPreTrainedModel:()=>nh,DPTForDepthEstimation:()=>Bf,DPTModel:()=>Rf,DPTPreTrainedModel:()=>md,DacDecoderModel:()=>ci,DacDecoderOutput:()=>Rd,DacEncoderModel:()=>dr,DacEncoderOutput:()=>ko,DacModel:()=>$a,DacPreTrainedModel:()=>ca,DebertaForMaskedLM:()=>Un,DebertaForQuestionAnswering:()=>hr,DebertaForSequenceClassification:()=>Sn,DebertaForTokenClassification:()=>Bn,DebertaModel:()=>wn,DebertaPreTrainedModel:()=>On,DebertaV2ForMaskedLM:()=>ea,DebertaV2ForQuestionAnswering:()=>ya,DebertaV2ForSequenceClassification:()=>Vs,DebertaV2ForTokenClassification:()=>Xr,DebertaV2Model:()=>lr,DebertaV2PreTrainedModel:()=>pr,DecisionTransformerModel:()=>Fd,DecisionTransformerPreTrainedModel:()=>zd,DeiTForImageClassification:()=>Af,DeiTModel:()=>Pf,DeiTPreTrainedModel:()=>Du,DepthAnythingForDepthEstimation:()=>jf,DepthAnythingPreTrainedModel:()=>Jp,DepthProForDepthEstimation:()=>Uf,DepthProPreTrainedModel:()=>bl,DetrForObjectDetection:()=>Ui,DetrForSegmentation:()=>yl,DetrModel:()=>xo,DetrObjectDetectionOutput:()=>To,DetrPreTrainedModel:()=>Mo,DetrSegmentationOutput:()=>Eo,Dinov2ForImageClassification:()=>th,Dinov2Model:()=>tm,Dinov2PreTrainedModel:()=>eh,Dinov2WithRegistersForImageClassification:()=>Bu,Dinov2WithRegistersModel:()=>bd,Dinov2WithRegistersPreTrainedModel:()=>Co,DistilBertForMaskedLM:()=>Yr,DistilBertForQuestionAnswering:()=>Er,DistilBertForSequenceClassification:()=>mr,DistilBertForTokenClassification:()=>tr,DistilBertModel:()=>ur,DistilBertPreTrainedModel:()=>Vr,DonutSwinModel:()=>em,DonutSwinPreTrainedModel:()=>Qf,EfficientNetForImageClassification:()=>$d,EfficientNetModel:()=>vr,EfficientNetPreTrainedModel:()=>la,ElectraForMaskedLM:()=>X,ElectraForQuestionAnswering:()=>ke,ElectraForSequenceClassification:()=>ue,ElectraForTokenClassification:()=>pe,ElectraModel:()=>ce,ElectraPreTrainedModel:()=>z,Ernie4_5_ForCausalLM:()=>Sh,Ernie4_5_Model:()=>ka,Ernie4_5_PretrainedModel:()=>kd,EsmForMaskedLM:()=>Na,EsmForSequenceClassification:()=>Zr,EsmForTokenClassification:()=>et,EsmModel:()=>Gs,EsmPreTrainedModel:()=>ls,ExaoneForCausalLM:()=>mu,ExaoneModel:()=>pf,ExaonePreTrainedModel:()=>sa,FalconForCausalLM:()=>Ph,FalconModel:()=>im,FalconPreTrainedModel:()=>Ch,FastViTForImageClassification:()=>ti,FastViTModel:()=>rd,FastViTPreTrainedModel:()=>Tu,Florence2ForConditionalGeneration:()=>zc,Florence2PreTrainedModel:()=>Ai,GLPNForDepthEstimation:()=>qf,GLPNModel:()=>vd,GLPNPreTrainedModel:()=>yd,GPT2LMHeadModel:()=>fo,GPT2Model:()=>al,GPT2PreTrainedModel:()=>co,GPTBigCodeForCausalLM:()=>K,GPTBigCodeModel:()=>N,GPTBigCodePreTrainedModel:()=>$,GPTJForCausalLM:()=>b,GPTJModel:()=>mo,GPTJPreTrainedModel:()=>ra,GPTNeoForCausalLM:()=>xa,GPTNeoModel:()=>Li,GPTNeoPreTrainedModel:()=>Os,GPTNeoXForCausalLM:()=>na,GPTNeoXModel:()=>il,GPTNeoXPreTrainedModel:()=>zi,Gemma2ForCausalLM:()=>aa,Gemma2Model:()=>Ri,Gemma2PreTrainedModel:()=>bn,Gemma3ForCausalLM:()=>cl,Gemma3Model:()=>ul,Gemma3PreTrainedModel:()=>Gc,Gemma3nForConditionalGeneration:()=>wa,Gemma3nPreTrainedModel:()=>ki,GemmaForCausalLM:()=>cr,GemmaModel:()=>rs,GemmaPreTrainedModel:()=>gu,GlmForCausalLM:()=>jc,GlmModel:()=>_s,GlmPreTrainedModel:()=>hf,GraniteForCausalLM:()=>Sa,GraniteModel:()=>Ea,GranitePreTrainedModel:()=>qa,GroundingDinoForObjectDetection:()=>nm,GroundingDinoPreTrainedModel:()=>ah,GroupViTModel:()=>ei,GroupViTPreTrainedModel:()=>Mf,HeliumForCausalLM:()=>go,HeliumModel:()=>pu,HeliumPreTrainedModel:()=>Bc,HieraForImageClassification:()=>Of,HieraModel:()=>kf,HieraPreTrainedModel:()=>dd,HubertForCTC:()=>yh,HubertForSequenceClassification:()=>vh,HubertModel:()=>gh,HubertPreTrainedModel:()=>sm,IJepaForImageClassification:()=>wu,IJepaModel:()=>Jc,IJepaPreTrainedModel:()=>Ja,Idefics3ForConditionalGeneration:()=>tl,Idefics3PreTrainedModel:()=>Ma,ImageMattingOutput:()=>un,JAISLMHeadModel:()=>fu,JAISModel:()=>po,JAISPreTrainedModel:()=>ho,JinaCLIPModel:()=>du,JinaCLIPPreTrainedModel:()=>lo,JinaCLIPTextModel:()=>uo,JinaCLIPVisionModel:()=>ks,Lfm2ForCausalLM:()=>hu,Lfm2Model:()=>Fc,Lfm2PreTrainedModel:()=>Ta,LiteWhisperForConditionalGeneration:()=>Ic,Llama4ForCausalLM:()=>Xt,Llama4PreTrainedModel:()=>jt,LlamaForCausalLM:()=>Pt,LlamaModel:()=>yt,LlamaPreTrainedModel:()=>at,LlavaForConditionalGeneration:()=>Jo,LlavaOnevisionForConditionalGeneration:()=>Lc,LlavaPreTrainedModel:()=>su,LlavaQwen2ForCausalLM:()=>ou,LongT5ForConditionalGeneration:()=>Vn,LongT5Model:()=>jn,LongT5PreTrainedModel:()=>Kn,M2M100ForConditionalGeneration:()=>uh,M2M100Model:()=>ai,M2M100PreTrainedModel:()=>Hs,MBartForCausalLM:()=>As,MBartForConditionalGeneration:()=>ms,MBartForSequenceClassification:()=>rr,MBartModel:()=>ps,MBartPreTrainedModel:()=>gr,MPNetForMaskedLM:()=>Ua,MPNetForQuestionAnswering:()=>we,MPNetForSequenceClassification:()=>Ei,MPNetForTokenClassification:()=>Si,MPNetModel:()=>Gr,MPNetPreTrainedModel:()=>Ps,MT5ForConditionalGeneration:()=>Dr,MT5Model:()=>Wr,MT5PreTrainedModel:()=>Cn,MarianMTModel:()=>Is,MarianModel:()=>lh,MarianPreTrainedModel:()=>Gi,MaskFormerForInstanceSegmentation:()=>Kf,MaskFormerModel:()=>gd,MaskFormerPreTrainedModel:()=>_d,MaskedLMOutput:()=>Ur,Metric3DForDepthEstimation:()=>Gf,Metric3DPreTrainedModel:()=>Vf,Metric3Dv2ForDepthEstimation:()=>Hf,Metric3Dv2PreTrainedModel:()=>Wf,MgpstrForSceneTextRecognition:()=>Pl,MgpstrModelOutput:()=>Po,MgpstrPreTrainedModel:()=>Cl,MimiDecoderModel:()=>ys,MimiDecoderOutput:()=>ln,MimiEncoderModel:()=>In,MimiEncoderOutput:()=>Gn,MimiModel:()=>pn,MimiPreTrainedModel:()=>xn,MistralForCausalLM:()=>am,MistralModel:()=>Ad,MistralPreTrainedModel:()=>oa,MobileBertForMaskedLM:()=>$n,MobileBertForQuestionAnswering:()=>Cs,MobileBertForSequenceClassification:()=>va,MobileBertModel:()=>Et,MobileBertPreTrainedModel:()=>ot,MobileLLMForCausalLM:()=>Uc,MobileLLMModel:()=>Nc,MobileLLMPreTrainedModel:()=>Ka,MobileNetV1ForImageClassification:()=>hs,MobileNetV1ForSemanticSegmentation:()=>Oa,MobileNetV1Model:()=>Zn,MobileNetV1PreTrainedModel:()=>ec,MobileNetV2ForImageClassification:()=>om,MobileNetV2ForSemanticSegmentation:()=>Ld,MobileNetV2Model:()=>Ih,MobileNetV2PreTrainedModel:()=>tc,MobileNetV3ForImageClassification:()=>Lh,MobileNetV3ForSemanticSegmentation:()=>gs,MobileNetV3Model:()=>qs,MobileNetV3PreTrainedModel:()=>ss,MobileNetV4ForImageClassification:()=>Ki,MobileNetV4ForSemanticSegmentation:()=>ui,MobileNetV4Model:()=>li,MobileNetV4PreTrainedModel:()=>nc,MobileViTForImageClassification:()=>gl,MobileViTModel:()=>sd,MobileViTPreTrainedModel:()=>Eu,MobileViTV2ForImageClassification:()=>Tf,MobileViTV2Model:()=>xf,MobileViTV2PreTrainedModel:()=>wo,ModelOutput:()=>be,ModernBertDecoderForCausalLM:()=>or,ModernBertDecoderModel:()=>Ft,ModernBertDecoderPreTrainedModel:()=>an,ModernBertForMaskedLM:()=>lt,ModernBertForSequenceClassification:()=>Mt,ModernBertForTokenClassification:()=>tn,ModernBertModel:()=>pt,ModernBertPreTrainedModel:()=>ct,Moondream1ForConditionalGeneration:()=>el,MoonshineForConditionalGeneration:()=>Yo,MoonshineModel:()=>ff,MoonshinePreTrainedModel:()=>ru,MptForCausalLM:()=>Yc,MptModel:()=>hl,MptPreTrainedModel:()=>vo,MultiModalityCausalLM:()=>zh,MultiModalityPreTrainedModel:()=>ua,MusicgenForCausalLM:()=>U_,MusicgenForConditionalGeneration:()=>Id,MusicgenModel:()=>qr,MusicgenPreTrainedModel:()=>Dd,NeoBertForMaskedLM:()=>Re,NeoBertForQuestionAnswering:()=>nt,NeoBertForSequenceClassification:()=>xt,NeoBertForTokenClassification:()=>st,NeoBertModel:()=>_t,NeoBertPreTrainedModel:()=>Ye,NomicBertModel:()=>Br,NomicBertPreTrainedModel:()=>Or,OPTForCausalLM:()=>Xp,OPTModel:()=>bo,OPTPreTrainedModel:()=>ji,Olmo2ForCausalLM:()=>Ds,Olmo2Model:()=>$s,Olmo2PreTrainedModel:()=>ll,OlmoForCausalLM:()=>_u,OlmoModel:()=>yo,OlmoPreTrainedModel:()=>Fi,OpenELMForCausalLM:()=>Hc,OpenELMModel:()=>dl,OpenELMPreTrainedModel:()=>Wc,OwlViTForObjectDetection:()=>Ef,OwlViTModel:()=>Su,OwlViTPreTrainedModel:()=>Ni,Owlv2ForObjectDetection:()=>ri,Owlv2Model:()=>ad,Owlv2PreTrainedModel:()=>Cu,PaliGemmaForConditionalGeneration:()=>iu,PaliGemmaPreTrainedModel:()=>au,PatchTSMixerForPrediction:()=>rc,PatchTSMixerModel:()=>Bh,PatchTSMixerPreTrainedModel:()=>Ao,PatchTSTForPrediction:()=>Rh,PatchTSTModel:()=>Fh,PatchTSTPreTrainedModel:()=>qi,Phi3ForCausalLM:()=>Qp,Phi3Model:()=>qp,Phi3PreTrainedModel:()=>Qc,Phi3VForCausalLM:()=>Oi,Phi3VPreTrainedModel:()=>nl,PhiForCausalLM:()=>bu,PhiModel:()=>Jr,PhiPreTrainedModel:()=>Za,PreTrainedModel:()=>J,PretrainedMixin:()=>fn,PvtForImageClassification:()=>td,PvtModel:()=>Mu,PvtPreTrainedModel:()=>ed,PyAnnoteForAudioFrameClassification:()=>dh,PyAnnoteModel:()=>ch,PyAnnotePreTrainedModel:()=>Gu,QuestionAnsweringModelOutput:()=>Pr,Qwen2ForCausalLM:()=>Ya,Qwen2Model:()=>Ca,Qwen2PreTrainedModel:()=>Xa,Qwen2VLForConditionalGeneration:()=>vu,Qwen2VLPreTrainedModel:()=>fl,Qwen3ForCausalLM:()=>qc,Qwen3Model:()=>Kc,Qwen3PreTrainedModel:()=>ia,RFDetrForObjectDetection:()=>ds,RFDetrModel:()=>ud,RFDetrObjectDetectionOutput:()=>Cr,RFDetrPreTrainedModel:()=>Pu,RTDetrForObjectDetection:()=>id,RTDetrModel:()=>yr,RTDetrObjectDetectionOutput:()=>So,RTDetrPreTrainedModel:()=>Sf,RTDetrV2ForObjectDetection:()=>Zp,RTDetrV2Model:()=>Cf,RTDetrV2ObjectDetectionOutput:()=>ld,RTDetrV2PreTrainedModel:()=>od,ResNetForImageClassification:()=>$f,ResNetModel:()=>hd,ResNetPreTrainedModel:()=>fd,RoFormerForMaskedLM:()=>jr,RoFormerForQuestionAnswering:()=>Es,RoFormerForSequenceClassification:()=>ja,RoFormerForTokenClassification:()=>ga,RoFormerModel:()=>er,RoFormerPreTrainedModel:()=>$r,RobertaForMaskedLM:()=>ro,RobertaForQuestionAnswering:()=>Pc,RobertaForSequenceClassification:()=>Ql,RobertaForTokenClassification:()=>Cc,RobertaModel:()=>Va,RobertaPreTrainedModel:()=>Ws,SamImageSegmentationOutput:()=>oh,SamModel:()=>ih,SamPreTrainedModel:()=>Uu,SapiensForDepthEstimation:()=>Nf,SapiensForNormalEstimation:()=>zu,SapiensForSemanticSegmentation:()=>Lu,SapiensPreTrainedModel:()=>si,SegformerForImageClassification:()=>$h,SegformerForSemanticSegmentation:()=>Od,SegformerModel:()=>Oh,SegformerPreTrainedModel:()=>Yu,Seq2SeqLMOutput:()=>X_,SequenceClassifierOutput:()=>Nt,SiglipModel:()=>io,SiglipPreTrainedModel:()=>sl,SiglipTextModel:()=>oo,SiglipVisionModel:()=>Di,SmolLM3ForCausalLM:()=>_o,SmolLM3Model:()=>Rc,SmolLM3PreTrainedModel:()=>ol,SmolVLMForConditionalGeneration:()=>lu,SnacDecoderModel:()=>Oo,SnacEncoderModel:()=>Ls,SnacModel:()=>Bd,SnacPreTrainedModel:()=>Da,SpeechT5ForSpeechToText:()=>Xu,SpeechT5ForTextToSpeech:()=>Cd,SpeechT5HifiGan:()=>Th,SpeechT5Model:()=>xh,SpeechT5PreTrainedModel:()=>Qu,SqueezeBertForMaskedLM:()=>de,SqueezeBertForQuestionAnswering:()=>Ie,SqueezeBertForSequenceClassification:()=>me,SqueezeBertModel:()=>se,SqueezeBertPreTrainedModel:()=>F,StableLmForCausalLM:()=>Dh,StableLmModel:()=>Ju,StableLmPreTrainedModel:()=>Zu,Starcoder2ForCausalLM:()=>sr,Starcoder2Model:()=>El,Starcoder2PreTrainedModel:()=>Tl,StyleTextToSpeech2Model:()=>Sd,StyleTextToSpeech2PreTrainedModel:()=>Ed,Swin2SRForImageSuperResolution:()=>Ff,Swin2SRModel:()=>zf,Swin2SRPreTrainedModel:()=>Iu,SwinForImageClassification:()=>If,SwinForSemanticSegmentation:()=>Lf,SwinModel:()=>Df,SwinPreTrainedModel:()=>pd,T5ForConditionalGeneration:()=>Dn,T5Model:()=>Ut,T5PreTrainedModel:()=>Qt,TableTransformerForObjectDetection:()=>$u,TableTransformerModel:()=>Pa,TableTransformerObjectDetectionOutput:()=>cd,TableTransformerPreTrainedModel:()=>Ou,TokenClassifierOutput:()=>Fr,TrOCRForCausalLM:()=>Eh,TrOCRPreTrainedModel:()=>Pd,UltravoxModel:()=>Nh,UltravoxPreTrainedModel:()=>jh,UniSpeechForCTC:()=>hh,UniSpeechForSequenceClassification:()=>Ku,UniSpeechModel:()=>fh,UniSpeechPreTrainedModel:()=>Hu,UniSpeechSatForAudioFrameClassification:()=>rm,UniSpeechSatForCTC:()=>ph,UniSpeechSatForSequenceClassification:()=>mh,UniSpeechSatModel:()=>Md,UniSpeechSatPreTrainedModel:()=>xl,VaultGemmaForCausalLM:()=>_f,VaultGemmaModel:()=>Bi,VaultGemmaPreTrainedModel:()=>yu,ViTForImageClassification:()=>yf,ViTMAEModel:()=>xu,ViTMAEPreTrainedModel:()=>bf,ViTMSNForImageClassification:()=>wf,ViTMSNModel:()=>ml,ViTMSNPreTrainedModel:()=>nd,ViTModel:()=>Yp,ViTPreTrainedModel:()=>Zc,VisionEncoderDecoderModel:()=>Zo,VitMatteForImageMatting:()=>_l,VitMattePreTrainedModel:()=>ni,VitPoseForPoseEstimation:()=>pl,VitPosePreTrainedModel:()=>vf,VitsModel:()=>Ks,VitsModelOutput:()=>qd,VitsPreTrainedModel:()=>Sl,VoxtralForConditionalGeneration:()=>lm,Wav2Vec2BertForCTC:()=>Kr,Wav2Vec2BertForSequenceClassification:()=>_h,Wav2Vec2BertModel:()=>Nr,Wav2Vec2BertPreTrainedModel:()=>qu,Wav2Vec2ForAudioFrameClassification:()=>wd,Wav2Vec2ForCTC:()=>zr,Wav2Vec2ForSequenceClassification:()=>Vu,Wav2Vec2Model:()=>Aa,Wav2Vec2PreTrainedModel:()=>fs,WavLMForAudioFrameClassification:()=>Td,WavLMForCTC:()=>bh,WavLMForSequenceClassification:()=>wh,WavLMForXVector:()=>Mh,WavLMModel:()=>xd,WavLMPreTrainedModel:()=>ii,WeSpeakerResNetModel:()=>Wu,WeSpeakerResNetPreTrainedModel:()=>Wi,WhisperForConditionalGeneration:()=>Xo,WhisperModel:()=>nu,WhisperPreTrainedModel:()=>Ga,XLMForQuestionAnswering:()=>$c,XLMForSequenceClassification:()=>kc,XLMForTokenClassification:()=>Oc,XLMModel:()=>Qo,XLMPreTrainedModel:()=>Ci,XLMRobertaForMaskedLM:()=>Yl,XLMRobertaForQuestionAnswering:()=>Dc,XLMRobertaForSequenceClassification:()=>Zl,XLMRobertaForTokenClassification:()=>Jl,XLMRobertaModel:()=>Xl,XLMRobertaPreTrainedModel:()=>Pi,XLMWithLMHeadModel:()=>Ac,XVectorOutput:()=>Kd,YolosForObjectDetection:()=>Nu,YolosModel:()=>wl,YolosObjectDetectionOutput:()=>Ml,YolosPreTrainedModel:()=>Vi});var a=t("./src/configs.js"),i=t("./src/backends/onnx.js"),l=t("./src/utils/dtypes.js"),u=t("./src/utils/generic.js"),d=t("./src/utils/core.js"),f=t("./src/utils/hub.js"),h=t("./src/utils/constants.js"),_=t("./src/generation/logits_process.js"),m=t("./src/generation/configuration_utils.js"),p=t("./src/utils/tensor.js"),y=t("./src/utils/image.js"),v=t("./src/utils/maths.js"),x=t("./src/generation/stopping_criteria.js"),L=t("./src/generation/logits_sampler.js"),T=t("./src/env.js"),E=t("./src/models/whisper/generation_whisper.js"),I=t("./src/models/whisper/common_whisper.js");const P={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7,MultiModality:8,Phi3V:9,AudioTextToText:10,AutoEncoder:11,ImageAudioTextToText:12},S=new Map,k=new Map,C=new Map;async function D(A,O,Z){let ge=Z.config?.["transformers.js_config"]??{},Se=Z.device??ge.device;Se&&typeof Se!="string"&&(Se.hasOwnProperty(O)?Se=Se[O]:(console.warn(`device not specified for "${O}". Using the default device.`),Se=null));const Oe=Se??(T.apis.IS_NODE_ENV?"cpu":"wasm"),Xe=(0,i.deviceToExecutionProviders)(Oe),it=ge.device_config??{};it.hasOwnProperty(Oe)&&(ge={...ge,...it[Oe]});let ht=Z.dtype??ge.dtype;if(typeof ht!="string"&&(ht&&ht.hasOwnProperty(O)?ht=ht[O]:(ht=l.DEFAULT_DEVICE_DTYPE_MAPPING[Oe]??l.DATA_TYPES.fp32,console.warn(`dtype not specified for "${O}". Using the default dtype (${ht}) for this device (${Oe}).`))),ht===l.DATA_TYPES.auto){let nn=ge.dtype;typeof nn!="string"&&(nn=nn?.[O]),nn&&nn!==l.DATA_TYPES.auto&&l.DATA_TYPES.hasOwnProperty(nn)?ht=nn:ht=l.DEFAULT_DEVICE_DTYPE_MAPPING[Oe]??l.DATA_TYPES.fp32}const St=ht;if(l.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(St)){if(St===l.DATA_TYPES.fp16&&Oe==="webgpu"&&!await(0,l.isWebGpuFp16Supported)())throw new Error(`The device (${Oe}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${St}. Should be one of: ${Object.keys(l.DATA_TYPES).join(", ")}`);const Vt=ge.kv_cache_dtype,Yt=Vt?typeof Vt=="string"?Vt:Vt[St]??"float32":void 0;if(Yt&&!["float32","float16"].includes(Yt))throw new Error(`Invalid kv_cache_dtype: ${Yt}. Should be one of: float32, float16`);const Wt={dtype:St,kv_cache_dtype:Yt,device:Oe},bt=l.DEFAULT_DTYPE_SUFFIX_MAPPING[St],yn=`${O}${bt}.onnx`,Ct=`${Z.subfolder??""}/${yn}`,Lt={...Z.session_options};Lt.executionProviders??=Xe;const cn=ge.free_dimension_overrides;cn?Lt.freeDimensionOverrides??=cn:Oe.startsWith("webnn")&&!Lt.freeDimensionOverrides&&console.warn(`WebNN does not currently support dynamic shapes and requires 'free_dimension_overrides' to be set in config.json, preferably as a field within config["transformers.js_config"]["device_config"]["${Oe}"]. When 'free_dimension_overrides' is not set, you may experience significant performance degradation.`);const Ln=T.apis.IS_NODE_ENV&&T.env.useFSCache,Hn=(0,f.getModelFile)(A,Ct,!0,Z,Ln),br=Z.use_external_data_format??ge.use_external_data_format;let wr=[];if(br){let nn;typeof br=="object"?br.hasOwnProperty(yn)?nn=br[yn]:br.hasOwnProperty(O)?nn=br[O]:nn=!1:nn=br;const ir=+nn;if(ir>f.MAX_EXTERNAL_DATA_CHUNKS)throw new Error(`The number of external data chunks (${ir}) exceeds the maximum allowed value (${f.MAX_EXTERNAL_DATA_CHUNKS}).`);for(let Rr=0;Rr<ir;++Rr){const Fo=`${yn}_data${Rr===0?"":"_"+Rr}`,as=`${Z.subfolder??""}/${Fo}`;wr.push(new Promise(async(da,$l)=>{const Rs=await(0,f.getModelFile)(A,as,!0,Z,Ln);da(Rs instanceof Uint8Array?{path:Fo,data:Rs}:Fo)}))}}else Lt.externalData!==void 0&&(wr=Lt.externalData.map(async nn=>{if(typeof nn.data=="string"){const ir=await(0,f.getModelFile)(A,nn.data,!0,Z);return{...nn,data:ir}}return nn}));if(wr.length>0){const nn=await Promise.all(wr);T.apis.IS_NODE_ENV||(Lt.externalData=nn)}if(Oe==="webgpu"){const nn=(0,a.getCacheShapes)(Z.config,{prefix:"present"});if(Object.keys(nn).length>0&&!(0,i.isONNXProxy)()){const ir={};for(const Rr in nn)ir[Rr]="gpu-buffer";Lt.preferredOutputLocation=ir}}return{buffer_or_path:await Hn,session_options:Lt,session_config:Wt}}async function V(A,O,Z){return Object.fromEntries(await Promise.all(Object.keys(O).map(async ge=>{const{buffer_or_path:Se,session_options:Oe,session_config:Xe}=await D(A,O[ge],Z),it=await(0,i.createInferenceSession)(Se,Oe,Xe);return[ge,it]})))}async function U(A,O,Z){return Object.fromEntries(await Promise.all(Object.keys(O).map(async ge=>{const Se=await(0,f.getModelJSON)(A,O[ge],!1,Z);return[ge,Se]})))}function ne(A,O){const Z=Object.create(null),ge=[];for(const Xe of A.inputNames){const it=O[Xe];if(!(it instanceof p.Tensor)){ge.push(Xe);continue}Z[Xe]=(0,i.isONNXProxy)()?it.clone():it}if(ge.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${ge.join(", ")}.`);const Se=Object.keys(O).length,Oe=A.inputNames.length;if(Se>Oe){let Xe=Object.keys(O).filter(it=>!A.inputNames.includes(it));console.warn(`WARNING: Too many inputs were provided (${Se} > ${Oe}). The following inputs will be ignored: "${Xe.join(", ")}".`)}return Z}async function ee(A,O){const Z=ne(A,O);try{const ge=Object.fromEntries(Object.entries(Z).map(([Oe,Xe])=>[Oe,Xe.ort_tensor])),Se=await(0,i.runInferenceSession)(A,ge);return H(Se)}catch(ge){const Se=Object.fromEntries(Object.entries(Z).map(([Oe,Xe])=>{const it={type:Xe.type,dims:Xe.dims,location:Xe.location};return it.location!=="gpu-buffer"&&(it.data=Xe.data),[Oe,it]}));throw console.error(`An error occurred during model execution: "${ge}".`),console.error("Inputs given to model:",Se),ge}}function H(A){for(let O in A)(0,i.isONNXTensor)(A[O])?A[O]=new p.Tensor(A[O]):typeof A[O]=="object"&&H(A[O]);return A}function oe(A){if(A instanceof p.Tensor)return A;if(A.length===0)throw Error("items must be non-empty");if(Array.isArray(A[0])){if(A.some(O=>O.length!==A[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new p.Tensor("int64",BigInt64Array.from(A.flat().map(O=>BigInt(O))),[A.length,A[0].length])}else return new p.Tensor("int64",BigInt64Array.from(A.map(O=>BigInt(O))),[1,A.length])}function ae(A){return new p.Tensor("bool",[A],[1])}async function W(A,O){let{encoder_outputs:Z,input_ids:ge,decoder_input_ids:Se,...Oe}=O;if(!Z){const it=(0,d.pick)(O,A.sessions.model.inputNames);Z=(await te(A,it)).last_hidden_state}return Oe.input_ids=Se,Oe.encoder_hidden_states=Z,A.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(Oe.encoder_attention_mask=O.attention_mask),await _e(A,Oe,!0)}async function te(A,O){const Z=A.sessions.model,ge=(0,d.pick)(O,Z.inputNames);if(Z.inputNames.includes("inputs_embeds")&&!ge.inputs_embeds){if(!O.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");ge.inputs_embeds=await A.encode_text({input_ids:O.input_ids})}if(Z.inputNames.includes("token_type_ids")&&!ge.token_type_ids){if(!ge.input_ids)throw new Error("Both `input_ids` and `token_type_ids` are missing in the model inputs.");ge.token_type_ids=(0,p.zeros_like)(ge.input_ids)}if(Z.inputNames.includes("pixel_mask")&&!ge.pixel_mask){if(!ge.pixel_values)throw new Error("Both `pixel_values` and `pixel_mask` are missing in the model inputs.");const Se=ge.pixel_values.dims;ge.pixel_mask=(0,p.ones)([Se[0],Se[2],Se[3]])}return await ee(Z,ge)}async function ie(A,O){const Z=await A.encode(O);return await A.decode(Z)}async function _e(A,O,Z=!1){const ge=A.sessions[Z?"decoder_model_merged":"model"],{past_key_values:Se,...Oe}=O;if(ge.inputNames.includes("use_cache_branch")&&(Oe.use_cache_branch=ae(!!Se)),ge.inputNames.includes("position_ids")&&Oe.attention_mask&&!Oe.position_ids){const it=["paligemma","gemma3_text","gemma3"].includes(A.config.model_type)?1:0;Oe.position_ids=ze(Oe,Se,it)}A.addPastKeyValues(Oe,Se);const Xe=(0,d.pick)(Oe,ge.inputNames);return await ee(ge,Xe)}function q({modality_token_id:A,inputs_embeds:O,modality_features:Z,input_ids:ge,attention_mask:Se}){const Oe=ge.tolist().map(St=>St.reduce((Vt,Yt,Wt)=>(Yt==A&&Vt.push(Wt),Vt),[])),Xe=Oe.reduce((St,Vt)=>St+Vt.length,0),it=Z.dims[0];if(Xe!==it)throw new Error(`Number of tokens and features do not match: tokens: ${Xe}, features ${it}`);let ht=0;for(let St=0;St<Oe.length;++St){const Vt=Oe[St],Yt=O[St];for(let Wt=0;Wt<Vt.length;++Wt)Yt[Vt[Wt]].data.set(Z[ht++].data)}return{inputs_embeds:O,attention_mask:Se}}function B({image_token_id:A,inputs_embeds:O,image_features:Z,input_ids:ge,attention_mask:Se}){return q({modality_token_id:A,inputs_embeds:O,modality_features:Z,input_ids:ge,attention_mask:Se})}function R({audio_token_id:A,inputs_embeds:O,audio_features:Z,input_ids:ge,attention_mask:Se}){return q({modality_token_id:A,inputs_embeds:O,modality_features:Z,input_ids:ge,attention_mask:Se})}async function Q(A,{encode_function:O,merge_function:Z,modality_input_name:ge,modality_output_name:Se,input_ids:Oe=null,attention_mask:Xe=null,position_ids:it=null,inputs_embeds:ht=null,past_key_values:St=null,generation_config:Vt=null,logits_processor:Yt=null,...Wt}){const bt=Wt[ge];if(!ht){if(ht=await A.encode_text({input_ids:Oe,...Wt}),bt&&Oe.dims[1]!==1){const Ct=await O({[ge]:bt,...Wt});({inputs_embeds:ht,attention_mask:Xe}=Z({[Se]:Ct,inputs_embeds:ht,input_ids:Oe,attention_mask:Xe}))}else if(St&&bt&&Oe.dims[1]===1){const Ct=Oe.dims[1],Lt=Object.values(St)[0].dims.at(-2);Xe=(0,p.cat)([(0,p.ones)([Oe.dims[0],Lt]),Xe.slice(null,[Xe.dims[1]-Ct,Xe.dims[1]])],1)}}if(!it&&A.config.model_type==="qwen2_vl"){const{image_grid_thw:Ct,video_grid_thw:Lt}=Wt;[it]=A.get_rope_index(Oe,Ct,Lt,Xe)}return await _e(A,{inputs_embeds:ht,past_key_values:St,attention_mask:Xe,position_ids:it,generation_config:Vt,logits_processor:Yt},!0)}async function G(A,O){return await Q(A,{...O,modality_input_name:"audio_values",modality_output_name:"audio_features",encode_function:A.encode_audio.bind(A),merge_function:A._merge_input_ids_with_audio_features.bind(A)})}async function fe(A,O){return await Q(A,{...O,modality_input_name:"pixel_values",modality_output_name:"image_features",encode_function:A.encode_image.bind(A),merge_function:A._merge_input_ids_with_image_features.bind(A)})}function Te(A,O=0){const[Z,ge]=A.dims,Se=A.data,Oe=new BigInt64Array(Se.length);for(let Xe=0;Xe<Z;++Xe){const it=Xe*ge;let ht=BigInt(O);for(let St=0;St<ge;++St){const Vt=it+St;Se[Vt]===0n?Oe[Vt]=BigInt(1):(Oe[Vt]=ht,ht+=Se[Vt])}}return{data:Oe,dims:A.dims}}function ze(A,O=null,Z=0){const{input_ids:ge,inputs_embeds:Se,attention_mask:Oe}=A,{data:Xe,dims:it}=Te(Oe,Z);let ht=new p.Tensor("int64",Xe,it);if(O){const St=-(ge??Se).dims.at(1);ht=ht.slice(null,[St,null])}return ht}function Ue(A,O,Z,ge){const Se=Z.past_key_values?Object.values(Z.past_key_values)[0].dims.at(-2):0;if(!Z.attention_mask){let Oe;for(const Xe of["input_ids","inputs_embeds","position_ids"])if(Z[Xe]){Oe=Z[Xe].dims;break}if(!Oe)throw new Error("attention_mask is not provided, and unable to infer its shape from model inputs.");Z.attention_mask=(0,p.ones)([Oe[0],Se+Oe[1]])}if(Z.past_key_values){const{input_ids:Oe,attention_mask:Xe}=Z;Xe&&Xe.dims[1]>Oe.dims[1]||Se<Oe.dims[1]&&(Z.input_ids=Oe.slice(null,[Se,null]))}return Z}function ft(A,O,Z,ge){return Z.past_key_values&&(O=O.map(Se=>[Se.at(-1)])),{...Z,decoder_input_ids:oe(O)}}function je(A,...O){return A.config.is_encoder_decoder?ft(A,...O):Ue(A,...O)}function le(A,O,Z,ge){const Se=!!Z.past_key_values;return ge.guidance_scale!==null&&ge.guidance_scale>1&&(Se?Z.input_ids=(0,p.cat)([Z.input_ids,Z.input_ids],0):(Z.input_ids=(0,p.cat)([Z.input_ids,(0,p.full_like)(Z.input_ids,BigInt(ge.pad_token_id))],0),Z.attention_mask=(0,p.cat)([Z.attention_mask,(0,p.full_like)(Z.attention_mask,0n)],0))),(Se||!Z.pixel_values)&&(Z.pixel_values=(0,p.full)([0,0,3,384,384],1)),Se&&(Z.images_seq_mask=new p.Tensor("bool",new Array(1).fill(!0).fill(!1,0,1),[1,1]),Z.images_emb_mask=new p.Tensor("bool",new Array(0).fill(!1),[1,1,0])),Z}class J extends u.Callable{main_input_name="input_ids";forward_params=["input_ids","attention_mask"];constructor(O,Z,ge){super(),this.config=O,this.sessions=Z,this.configs=ge;const Se=C.get(this.constructor),Oe=S.get(Se);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,Oe){case P.DecoderOnly:this.can_generate=!0,this._forward=_e,this._prepare_inputs_for_generation=Ue;break;case P.Seq2Seq:case P.Vision2Seq:case P.Musicgen:this.can_generate=!0,this._forward=W,this._prepare_inputs_for_generation=ft;break;case P.EncoderDecoder:this._forward=W;break;case P.ImageTextToText:this.can_generate=!0,this._forward=fe,this._prepare_inputs_for_generation=je;break;case P.AudioTextToText:this.can_generate=!0,this._forward=G,this._prepare_inputs_for_generation=je;break;case P.Phi3V:case P.ImageAudioTextToText:this.can_generate=!0,this._prepare_inputs_for_generation=je;break;case P.MultiModality:this.can_generate=!0,this._prepare_inputs_for_generation=le;break;case P.AutoEncoder:this._forward=ie;break;default:this._forward=te;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){const O=[];for(const Z of Object.values(this.sessions))Z?.handler?.dispose&&O.push(Z.handler.dispose());return await Promise.all(O)}static async from_pretrained(O,{progress_callback:Z=null,config:ge=null,cache_dir:Se=null,local_files_only:Oe=!1,revision:Xe="main",model_file_name:it=null,subfolder:ht="onnx",device:St=null,dtype:Vt=null,use_external_data_format:Yt=null,session_options:Wt={}}={}){let bt={progress_callback:Z,config:ge,cache_dir:Se,local_files_only:Oe,revision:Xe,model_file_name:it,subfolder:ht,device:St,dtype:Vt,use_external_data_format:Yt,session_options:Wt};const yn=C.get(this),Ct=S.get(yn);ge=bt.config=await a.AutoConfig.from_pretrained(O,bt);let Lt;if(Ct===P.DecoderOnly)Lt=await Promise.all([V(O,{model:bt.model_file_name??"model"},bt),U(O,{generation_config:"generation_config.json"},bt)]);else if(Ct===P.Seq2Seq||Ct===P.Vision2Seq)Lt=await Promise.all([V(O,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},bt),U(O,{generation_config:"generation_config.json"},bt)]);else if(Ct===P.MaskGeneration)Lt=await Promise.all([V(O,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},bt)]);else if(Ct===P.EncoderDecoder)Lt=await Promise.all([V(O,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},bt)]);else if(Ct===P.ImageTextToText){const cn={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};ge.is_encoder_decoder&&(cn.model="encoder_model"),Lt=await Promise.all([V(O,cn,bt),U(O,{generation_config:"generation_config.json"},bt)])}else if(Ct===P.AudioTextToText){const cn={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",decoder_model_merged:"decoder_model_merged"};Lt=await Promise.all([V(O,cn,bt),U(O,{generation_config:"generation_config.json"},bt)])}else if(Ct===P.ImageAudioTextToText){const cn={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};Lt=await Promise.all([V(O,cn,bt),U(O,{generation_config:"generation_config.json"},bt)])}else if(Ct===P.Musicgen)Lt=await Promise.all([V(O,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},bt),U(O,{generation_config:"generation_config.json"},bt)]);else if(Ct===P.MultiModality)Lt=await Promise.all([V(O,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},bt),U(O,{generation_config:"generation_config.json"},bt)]);else if(Ct===P.Phi3V)Lt=await Promise.all([V(O,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},bt),U(O,{generation_config:"generation_config.json"},bt)]);else if(Ct===P.AutoEncoder)Lt=await Promise.all([V(O,{encoder_model:"encoder_model",decoder_model:"decoder_model"},bt)]);else{if(Ct!==P.EncoderOnly){const cn=yn??ge?.model_type;cn!=="custom"&&console.warn(`Model type for '${cn}' not found, assuming encoder-only architecture. Please report this at ${h.GITHUB_ISSUE_URL}.`)}Lt=await Promise.all([V(O,{model:bt.model_file_name??"model"},bt)])}return new this(ge,...Lt)}async _call(O){return await this.forward(O)}async forward(O){return await this._forward(this,O)}get generation_config(){return this.configs?.generation_config??null}_get_logits_warper(O){const Z=new _.LogitsProcessorList;return O.temperature!==null&&O.temperature!==1&&Z.push(new _.TemperatureLogitsWarper(O.temperature)),O.top_k!==null&&O.top_k!==0&&Z.push(new _.TopKLogitsWarper(O.top_k)),O.top_p!==null&&O.top_p<1&&Z.push(new _.TopPLogitsWarper(O.top_p)),Z}_get_logits_processor(O,Z,ge=null){const Se=new _.LogitsProcessorList;if(O.repetition_penalty!==null&&O.repetition_penalty!==1&&Se.push(new _.RepetitionPenaltyLogitsProcessor(O.repetition_penalty)),O.no_repeat_ngram_size!==null&&O.no_repeat_ngram_size>0&&Se.push(new _.NoRepeatNGramLogitsProcessor(O.no_repeat_ngram_size)),O.bad_words_ids!==null&&Se.push(new _.NoBadWordsLogitsProcessor(O.bad_words_ids,O.eos_token_id)),O.min_length!==null&&O.eos_token_id!==null&&O.min_length>0&&Se.push(new _.MinLengthLogitsProcessor(O.min_length,O.eos_token_id)),O.min_new_tokens!==null&&O.eos_token_id!==null&&O.min_new_tokens>0&&Se.push(new _.MinNewTokensLengthLogitsProcessor(Z,O.min_new_tokens,O.eos_token_id)),O.forced_bos_token_id!==null&&Se.push(new _.ForcedBOSTokenLogitsProcessor(O.forced_bos_token_id)),O.forced_eos_token_id!==null&&Se.push(new _.ForcedEOSTokenLogitsProcessor(O.max_length,O.forced_eos_token_id)),O.begin_suppress_tokens!==null){const Oe=Z>1||O.forced_bos_token_id===null?Z:Z+1;Se.push(new _.SuppressTokensAtBeginLogitsProcessor(O.begin_suppress_tokens,Oe))}return O.guidance_scale!==null&&O.guidance_scale>1&&Se.push(new _.ClassifierFreeGuidanceLogitsProcessor(O.guidance_scale)),ge!==null&&Se.extend(ge),Se}_prepare_generation_config(O,Z,ge=m.GenerationConfig){const Se={...this.config};for(const Xe of["decoder","generator","text_config"])Xe in Se&&Object.assign(Se,Se[Xe]);const Oe=new ge(Se);return Object.assign(Oe,this.generation_config??{}),O&&Object.assign(Oe,O),Z&&Object.assign(Oe,(0,d.pick)(Z,Object.getOwnPropertyNames(Oe))),Oe}_get_stopping_criteria(O,Z=null){const ge=new x.StoppingCriteriaList;return O.max_length!==null&&ge.push(new x.MaxLengthCriteria(O.max_length,this.config.max_position_embeddings??null)),O.eos_token_id!==null&&ge.push(new x.EosTokenCriteria(O.eos_token_id)),Z&&ge.extend(Z),ge}_validate_model_class(){if(!this.can_generate){const O=[sc,ac,Qi,Al],Z=C.get(this.constructor),ge=new Set,Se=this.config.model_type;for(const Xe of O){const it=Xe.get(Se);it&&ge.add(it[0])}let Oe=`The current model class (${Z}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw ge.size>0&&(Oe+=` Please use the following class instead: ${[...ge].join(", ")}`),Error(Oe)}}prepare_inputs_for_generation(...O){return this._prepare_inputs_for_generation(this,...O)}_update_model_kwargs_for_generation({generated_input_ids:O,outputs:Z,model_inputs:ge,is_encoder_decoder:Se}){return ge.past_key_values=this.getPastKeyValues(Z,ge.past_key_values),ge.input_ids=new p.Tensor("int64",O.flat(),[O.length,1]),Se||(ge.attention_mask=(0,p.cat)([ge.attention_mask,(0,p.ones)([ge.attention_mask.dims[0],1])],1)),ge.position_ids=null,ge}_prepare_model_inputs({inputs:O,bos_token_id:Z,model_kwargs:ge}){const Se=(0,d.pick)(ge,this.forward_params),Oe=this.main_input_name;if(Oe in Se){if(O)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else Se[Oe]=O;return{inputs_tensor:Se[Oe],model_inputs:Se,model_input_name:Oe}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:O,model_inputs:Z,model_input_name:ge,generation_config:Se}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!Z.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:Xe,pixel_values:it,attention_mask:ht,...St}=Z,Vt=await this._prepare_inputs_embeds(Z);Z={...St,...(0,d.pick)(Vt,["inputs_embeds","attention_mask"])}}let{last_hidden_state:Oe}=await te(this,Z);if(Se.guidance_scale!==null&&Se.guidance_scale>1)Oe=(0,p.cat)([Oe,(0,p.full_like)(Oe,0)],0),"attention_mask"in Z&&(Z.attention_mask=(0,p.cat)([Z.attention_mask,(0,p.zeros_like)(Z.attention_mask)],0));else if(Z.decoder_input_ids){const Xe=oe(Z.decoder_input_ids).dims[0];if(Xe!==Oe.dims[0]){if(Oe.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${Oe.dims[0]}) than the decoder inputs (${Xe}).`);Oe=(0,p.cat)(Array.from({length:Xe},()=>Oe),0)}}return Z.encoder_outputs=Oe,Z}_prepare_decoder_input_ids_for_generation({batch_size:O,model_input_name:Z,model_kwargs:ge,decoder_start_token_id:Se,bos_token_id:Oe,generation_config:Xe}){let{decoder_input_ids:it,...ht}=ge;if(!(it instanceof p.Tensor)){if(it)Array.isArray(it[0])||(it=Array.from({length:O},()=>it));else if(Se??=Oe,this.config.model_type==="musicgen")it=Array.from({length:O*this.config.decoder.num_codebooks},()=>[Se]);else if(Array.isArray(Se)){if(Se.length!==O)throw new Error(`\`decoder_start_token_id\` expcted to have length ${O} but got ${Se.length}`);it=Se}else it=Array.from({length:O},()=>[Se]);it=oe(it)}return ge.decoder_attention_mask=(0,p.ones_like)(it),{input_ids:it,model_inputs:ht}}async generate({inputs:O=null,generation_config:Z=null,logits_processor:ge=null,stopping_criteria:Se=null,streamer:Oe=null,...Xe}){this._validate_model_class(),Z=this._prepare_generation_config(Z,Xe);let{inputs_tensor:it,model_inputs:ht,model_input_name:St}=this._prepare_model_inputs({inputs:O,model_kwargs:Xe});const Vt=this.config.is_encoder_decoder;Vt&&("encoder_outputs"in ht||(ht=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:it,model_inputs:ht,model_input_name:St,generation_config:Z})));let Yt;Vt?{input_ids:Yt,model_inputs:ht}=this._prepare_decoder_input_ids_for_generation({batch_size:ht[St].dims.at(0),model_input_name:St,model_kwargs:ht,decoder_start_token_id:Z.decoder_start_token_id,bos_token_id:Z.bos_token_id,generation_config:Z}):Yt=ht[St];let Wt=Yt.dims.at(-1);Z.max_new_tokens!==null&&(Z.max_length=Wt+Z.max_new_tokens);const bt=this._get_logits_processor(Z,Wt,ge),yn=this._get_stopping_criteria(Z,Se),Ct=ht[St].dims.at(0),Lt=L.LogitsSampler.getSampler(Z),cn=new Array(Ct).fill(0),Ln=Yt.tolist();Oe&&Oe.put(Ln);let Hn,br={};for(;;){if(ht=this.prepare_inputs_for_generation(Ln,ht,Z),Hn=await this.forward(ht),Z.output_attentions&&Z.return_dict_in_generate){const as=this.getAttentions(Hn);for(const da in as)da in br||(br[da]=[]),br[da].push(as[da])}const nn=Hn.logits.slice(null,-1,null),ir=bt(Ln,nn),Rr=[];for(let as=0;as<ir.dims.at(0);++as){const da=ir[as],$l=await Lt(da);for(const[Rs,uc]of $l){const Ro=BigInt(Rs);cn[as]+=uc,Ln[as].push(Ro),Rr.push([Ro]);break}}if(Oe&&Oe.put(Rr),yn(Ln).every(as=>as))break;ht=this._update_model_kwargs_for_generation({generated_input_ids:Rr,outputs:Hn,model_inputs:ht,is_encoder_decoder:Vt})}Oe&&Oe.end();const wr=this.getPastKeyValues(Hn,ht.past_key_values,!0),ar=new p.Tensor("int64",Ln.flat(),[Ln.length,Ln[0].length]);if(Z.return_dict_in_generate)return{sequences:ar,past_key_values:wr,...br};for(const nn of Object.values(Hn))nn.location==="gpu-buffer"&&nn.dispose();return ar}getPastKeyValues(O,Z,ge=!1){const Se=Object.create(null);for(const Oe in O)if(Oe.startsWith("present")){const Xe=Oe.replace("present_conv","past_conv").replace("present","past_key_values"),it=Oe.includes("encoder");if(it&&Z?Se[Xe]=Z[Xe]:Se[Xe]=O[Oe],Z&&(!it||ge)){const ht=Z[Xe];ht.location==="gpu-buffer"&&ht.dispose()}}return Se}getAttentions(O){const Z={};for(const ge of["cross_attentions","encoder_attentions","decoder_attentions"])for(const Se in O)Se.startsWith(ge)&&(ge in Z||(Z[ge]=[]),Z[ge].push(O[Se]));return Z}addPastKeyValues(O,Z){if(Z)Object.assign(O,Z);else{const ge=this.sessions.decoder_model_merged??this.sessions.model,Se=(O[this.main_input_name]??O.attention_mask)?.dims?.[0]??1,Oe=ge?.config?.kv_cache_dtype??"float32",Xe=Oe==="float16"?p.DataTypeMap.float16:p.DataTypeMap.float32,it=(0,a.getCacheShapes)(this.config,{batch_size:Se});for(const ht in it){const St=it[ht].reduce((Vt,Yt)=>Vt*Yt,1);O[ht]=new p.Tensor(Oe,new Xe(St),it[ht])}}}async encode_image({pixel_values:O}){return(await ee(this.sessions.vision_encoder,{pixel_values:O})).image_features}async encode_text({input_ids:O}){return(await ee(this.sessions.embed_tokens,{input_ids:O})).inputs_embeds}async encode_audio({audio_values:O}){return(await ee(this.sessions.audio_encoder,{audio_values:O})).audio_features}}class be{}class Ae extends be{constructor({last_hidden_state:O,hidden_states:Z=null,attentions:ge=null}){super(),this.last_hidden_state=O,this.hidden_states=Z,this.attentions=ge}}class Ne extends J{}class De extends Ne{}class xe extends Ne{async _call(O){return new Ur(await super._call(O))}}class Ve extends Ne{async _call(O){return new Nt(await super._call(O))}}class Ee extends Ne{async _call(O){return new Fr(await super._call(O))}}class Ge extends Ne{async _call(O){return new Pr(await super._call(O))}}class Ye extends J{}class _t extends Ye{}class Re extends Ye{async _call(O){return new Ur(await super._call(O))}}class xt extends Ye{async _call(O){return new Nt(await super._call(O))}}class st extends Ye{async _call(O){return new Fr(await super._call(O))}}class nt extends Ye{async _call(O){return new Pr(await super._call(O))}}class ct extends J{}class pt extends ct{}class lt extends ct{async _call(O){return new Ur(await super._call(O))}}class Mt extends ct{async _call(O){return new Nt(await super._call(O))}}class tn extends ct{async _call(O){return new Fr(await super._call(O))}}class an extends J{}class Ft extends an{}class or extends an{}class Or extends J{}class Br extends Or{}class $r extends J{}class er extends $r{}class jr extends $r{async _call(O){return new Ur(await super._call(O))}}class ja extends $r{async _call(O){return new Nt(await super._call(O))}}class ga extends $r{async _call(O){return new Fr(await super._call(O))}}class Es extends $r{async _call(O){return new Pr(await super._call(O))}}class Ss extends J{}class zt extends Ss{}class Zs extends Ss{async _call(O){return new Ur(await super._call(O))}}class En extends Ss{async _call(O){return new Nt(await super._call(O))}}class Kt extends Ss{async _call(O){return new Fr(await super._call(O))}}class Js extends Ss{async _call(O){return new Pr(await super._call(O))}}class z extends J{}class ce extends z{}class X extends z{async _call(O){return new Ur(await super._call(O))}}class ue extends z{async _call(O){return new Nt(await super._call(O))}}class pe extends z{async _call(O){return new Fr(await super._call(O))}}class ke extends z{async _call(O){return new Pr(await super._call(O))}}class Qe extends J{}class Tt extends Qe{}class At extends Qe{async _call(O){return new Ur(await super._call(O))}}class mt extends Qe{async _call(O){return new Nt(await super._call(O))}}class Zt extends Qe{async _call(O){return new Fr(await super._call(O))}}class qt extends Qe{async _call(O){return new Pr(await super._call(O))}}class On extends J{}class wn extends On{}class Un extends On{async _call(O){return new Ur(await super._call(O))}}class Sn extends On{async _call(O){return new Nt(await super._call(O))}}class Bn extends On{async _call(O){return new Fr(await super._call(O))}}class hr extends On{async _call(O){return new Pr(await super._call(O))}}class pr extends J{}class lr extends pr{}class ea extends pr{async _call(O){return new Ur(await super._call(O))}}class Vs extends pr{async _call(O){return new Nt(await super._call(O))}}class Xr extends pr{async _call(O){return new Fr(await super._call(O))}}class ya extends pr{async _call(O){return new Pr(await super._call(O))}}class Vr extends J{}class ur extends Vr{}class mr extends Vr{async _call(O){return new Nt(await super._call(O))}}class tr extends Vr{async _call(O){return new Fr(await super._call(O))}}class Er extends Vr{async _call(O){return new Pr(await super._call(O))}}class Yr extends Vr{async _call(O){return new Ur(await super._call(O))}}class ls extends J{}class Gs extends ls{}class Na extends ls{async _call(O){return new Ur(await super._call(O))}}class Zr extends ls{async _call(O){return new Nt(await super._call(O))}}class et extends ls{async _call(O){return new Fr(await super._call(O))}}class ot extends J{}class Et extends ot{}class $n extends ot{async _call(O){return new Ur(await super._call(O))}}class va extends ot{async _call(O){return new Nt(await super._call(O))}}class Cs extends ot{async _call(O){return new Pr(await super._call(O))}}class Ps extends J{}class Gr extends Ps{}class Ua extends Ps{async _call(O){return new Ur(await super._call(O))}}class Ei extends Ps{async _call(O){return new Nt(await super._call(O))}}class Si extends Ps{async _call(O){return new Fr(await super._call(O))}}class we extends Ps{async _call(O){return new Pr(await super._call(O))}}class F extends J{}class se extends F{}class de extends F{async _call(O){return new Ur(await super._call(O))}}class me extends F{async _call(O){return new Nt(await super._call(O))}}class Ie extends F{async _call(O){return new Pr(await super._call(O))}}class Ke extends J{}class gt extends Ke{}class vt extends Ke{async _call(O){return new Nt(await super._call(O))}}class wt extends Ke{async _call(O){return new Pr(await super._call(O))}}class dt extends Ke{async _call(O){return new Ur(await super._call(O))}}class Qt extends J{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"]}class Ut extends Qt{}class Dn extends Qt{}class Kn extends J{}class jn extends Kn{}class Vn extends Kn{}class Cn extends J{}class Wr extends Cn{}class Dr extends Cn{}class _r extends J{}class us extends _r{}class vn extends _r{}class nr extends _r{async _call(O){return new Nt(await super._call(O))}}class gr extends J{}class ps extends gr{}class ms extends gr{}class rr extends gr{async _call(O){return new Nt(await super._call(O))}}class As extends gr{}class _n extends J{}class Mn extends _n{}class Yn extends _n{}class Nn extends J{}class cs extends Nn{}class ba extends Nn{}class Ws extends J{}class Va extends Ws{}class ro extends Ws{async _call(O){return new Ur(await super._call(O))}}class Ql extends Ws{async _call(O){return new Nt(await super._call(O))}}class Cc extends Ws{async _call(O){return new Fr(await super._call(O))}}class Pc extends Ws{async _call(O){return new Pr(await super._call(O))}}class Ci extends J{}class Qo extends Ci{}class Ac extends Ci{async _call(O){return new Ur(await super._call(O))}}class kc extends Ci{async _call(O){return new Nt(await super._call(O))}}class Oc extends Ci{async _call(O){return new Fr(await super._call(O))}}class $c extends Ci{async _call(O){return new Pr(await super._call(O))}}class Pi extends J{}class Xl extends Pi{}class Yl extends Pi{async _call(O){return new Ur(await super._call(O))}}class Zl extends Pi{async _call(O){return new Nt(await super._call(O))}}class Jl extends Pi{async _call(O){return new Fr(await super._call(O))}}class Dc extends Pi{async _call(O){return new Pr(await super._call(O))}}class so extends J{}class eu extends so{}class tu extends so{}class Ga extends J{requires_attention_mask=!1;main_input_name="input_features";forward_params=["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"]}class nu extends Ga{}class Xo extends Ga{_prepare_generation_config(O,Z){return super._prepare_generation_config(O,Z,E.WhisperGenerationConfig)}_retrieve_init_tokens(O){const Z=[O.decoder_start_token_id];let ge=O.language;const Se=O.task;if(O.is_multilingual){ge||(console.warn("No language specified - defaulting to English (en)."),ge="en");const Xe=`<|${(0,I.whisper_language_to_code)(ge)}|>`;Z.push(O.lang_to_id[Xe]),Z.push(O.task_to_id[Se??"transcribe"])}else if(ge||Se)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!O.return_timestamps&&O.no_timestamps_token_id&&Z.at(-1)!==O.no_timestamps_token_id?Z.push(O.no_timestamps_token_id):O.return_timestamps&&Z.at(-1)===O.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),Z.pop()),Z.filter(Oe=>Oe!=null)}async generate({inputs:O=null,generation_config:Z=null,logits_processor:ge=null,stopping_criteria:Se=null,...Oe}){Z=this._prepare_generation_config(Z,Oe);const Xe=Oe.decoder_input_ids??this._retrieve_init_tokens(Z);if(Z.return_timestamps&&(ge??=new _.LogitsProcessorList,ge.push(new _.WhisperTimeStampLogitsProcessor(Z,Xe))),Z.begin_suppress_tokens&&(ge??=new _.LogitsProcessorList,ge.push(new _.SuppressTokensAtBeginLogitsProcessor(Z.begin_suppress_tokens,Xe.length))),Z.return_token_timestamps){if(!Z.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");Z.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),Z.output_attentions=!0,Z.return_dict_in_generate=!0}const it=await super.generate({inputs:O,generation_config:Z,logits_processor:ge,decoder_input_ids:Xe,...Oe});return Z.return_token_timestamps&&(it.token_timestamps=this._extract_token_timestamps(it,Z.alignment_heads,Z.num_frames)),it}_extract_token_timestamps(O,Z,ge=null,Se=.02){if(!O.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");ge==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let Oe=this.config.median_filter_width;Oe===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),Oe=7);const Xe=O.cross_attentions,it=Array.from({length:this.config.decoder_layers},(Ct,Lt)=>(0,p.cat)(Xe.map(cn=>cn[Lt]),2)),ht=(0,p.stack)(Z.map(([Ct,Lt])=>{if(Ct>=it.length)throw new Error(`Layer index ${Ct} is out of bounds for cross attentions (length ${it.length}).`);return ge?it[Ct].slice(null,Lt,null,[0,ge]):it[Ct].slice(null,Lt)})).transpose(1,0,2,3),[St,Vt]=(0,p.std_mean)(ht,-2,0,!0),Yt=ht.clone();for(let Ct=0;Ct<Yt.dims[0];++Ct){const Lt=Yt[Ct];for(let cn=0;cn<Lt.dims[0];++cn){const Ln=Lt[cn],Hn=St[Ct][cn][0].data,br=Vt[Ct][cn][0].data;for(let wr=0;wr<Ln.dims[0];++wr){let ar=Ln[wr].data;for(let nn=0;nn<ar.length;++nn)ar[nn]=(ar[nn]-br[nn])/Hn[nn];ar.set((0,v.medianFilter)(ar,Oe))}}}const Wt=[(0,p.mean)(Yt,1)],bt=O.sequences.dims,yn=new p.Tensor("float32",new Float32Array(bt[0]*bt[1]),bt);for(let Ct=0;Ct<bt[0];++Ct){const Lt=Wt[Ct].neg().squeeze_(0),[cn,Ln]=(0,v.dynamic_time_warping)(Lt.tolist()),Hn=Array.from({length:cn.length-1},(ar,nn)=>cn[nn+1]-cn[nn]),br=(0,d.mergeArrays)([1],Hn).map(ar=>!!ar),wr=[];for(let ar=0;ar<br.length;++ar)br[ar]&&wr.push(Ln[ar]*Se);yn[Ct].data.set(wr,1)}return yn}}class Ic extends Xo{}class ru extends J{requires_attention_mask=!1;main_input_name="input_values";forward_params=["input_values","decoder_input_ids","past_key_values"]}class ff extends ru{}class Yo extends ru{}class Zo extends J{main_input_name="pixel_values";forward_params=["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"]}class su extends J{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class Jo extends su{_merge_input_ids_with_image_features(O){const Z=O.image_features.dims.at(-1),ge=O.image_features.view(-1,Z);return B({image_token_id:this.config.image_token_index,...O,image_features:ge})}}class Lc extends Jo{}class el extends Jo{}class Ai extends J{forward_params=["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"];main_input_name="inputs_embeds"}class zc extends Ai{_merge_input_ids_with_image_features({inputs_embeds:O,image_features:Z,input_ids:ge,attention_mask:Se}){return{inputs_embeds:(0,p.cat)([Z,O],1),attention_mask:(0,p.cat)([(0,p.ones)(Z.dims.slice(0,2)),Se],1)}}async _prepare_inputs_embeds({input_ids:O,pixel_values:Z,inputs_embeds:ge,attention_mask:Se}){if(!O&&!Z)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let Oe,Xe;return O&&(Oe=await this.encode_text({input_ids:O})),Z&&(Xe=await this.encode_image({pixel_values:Z})),Oe&&Xe?{inputs_embeds:ge,attention_mask:Se}=this._merge_input_ids_with_image_features({inputs_embeds:Oe,image_features:Xe,input_ids:O,attention_mask:Se}):ge=Oe||Xe,{inputs_embeds:ge,attention_mask:Se}}async forward({input_ids:O,pixel_values:Z,attention_mask:ge,decoder_input_ids:Se,decoder_attention_mask:Oe,encoder_outputs:Xe,past_key_values:it,inputs_embeds:ht,decoder_inputs_embeds:St}){if(ht||({inputs_embeds:ht,attention_mask:ge}=await this._prepare_inputs_embeds({input_ids:O,pixel_values:Z,inputs_embeds:ht,attention_mask:ge})),!Xe){let{last_hidden_state:Wt}=await te(this,{inputs_embeds:ht,attention_mask:ge});Xe=Wt}if(!St){if(!Se)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");St=await this.encode_text({input_ids:Se})}return await _e(this,{inputs_embeds:St,attention_mask:Oe,encoder_attention_mask:ge,encoder_hidden_states:Xe,past_key_values:it},!0)}}class au extends J{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class iu extends au{_merge_input_ids_with_image_features(O){const Z=O.image_features.dims.at(-1),ge=O.image_features.view(-1,Z);return B({image_token_id:this.config.image_token_index,...O,image_features:ge})}}class ou extends su{_merge_input_ids_with_image_features(O){const Z=O.image_features.dims.at(-1),ge=O.image_features.view(-1,Z);return B({image_token_id:this.config.image_token_index,...O,image_features:ge})}}class ki extends J{forward_params=["input_ids","attention_mask","inputs_embeds","per_layer_inputs","position_ids","pixel_values","input_features","input_features_mask","past_key_values"]}class wa extends ki{async forward({input_ids:O=null,attention_mask:Z=null,pixel_values:ge=null,input_features:Se=null,input_features_mask:Oe=null,position_ids:Xe=null,inputs_embeds:it=null,per_layer_inputs:ht=null,past_key_values:St=null,generation_config:Vt=null,logits_processor:Yt=null,...Wt}){if((!it||!ht)&&({inputs_embeds:it,per_layer_inputs:ht}=await ee(this.sessions.embed_tokens,{input_ids:O}),O.dims[1]!==1)){if(ge){const{image_features:yn}=await ee(this.sessions.vision_encoder,{pixel_values:ge});({inputs_embeds:it,attention_mask:Z}=this._merge_input_ids_with_image_features({image_features:yn,inputs_embeds:it,input_ids:O,attention_mask:Z}))}if(Se){const{audio_features:yn}=await ee(this.sessions.audio_encoder,{input_features:Se,input_features_mask:Oe});({inputs_embeds:it,attention_mask:Z}=this._merge_input_ids_with_audio_features({audio_features:yn,inputs_embeds:it,input_ids:O,attention_mask:Z}))}}return await _e(this,{inputs_embeds:it,per_layer_inputs:ht,past_key_values:St,attention_mask:Z,position_ids:Xe,generation_config:Vt,logits_processor:Yt},!0)}_merge_input_ids_with_image_features(O){const Z=O.image_features.dims.at(-1),ge=O.image_features.view(-1,Z);return B({image_token_id:this.config.image_token_id,...O,image_features:ge})}_merge_input_ids_with_audio_features(O){const Z=O.audio_features.dims.at(-1),ge=O.audio_features.view(-1,Z);return R({audio_token_id:this.config.audio_token_id,...O,audio_features:ge})}}class Ma extends J{forward_params=["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"]}class tl extends Ma{async encode_image({pixel_values:O,pixel_attention_mask:Z}){return(await ee(this.sessions.vision_encoder,{pixel_values:O,pixel_attention_mask:Z})).image_features}_merge_input_ids_with_image_features(O){const Z=O.image_features.dims.at(-1),ge=O.image_features.view(-1,Z);return B({image_token_id:this.config.image_token_id,...O,image_features:ge})}}class lu extends tl{}class nl extends J{forward_params=["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"]}class Oi extends nl{async forward({input_ids:O=null,attention_mask:Z=null,pixel_values:ge=null,image_sizes:Se=null,position_ids:Oe=null,inputs_embeds:Xe=null,past_key_values:it=null,generation_config:ht=null,logits_processor:St=null,...Vt}){if(!Xe){let Wt;if(ge&&O.dims[1]!==1){if(!Se)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:Wt}=await ee(this.sessions.vision_encoder,{pixel_values:ge,image_sizes:Se}))}else{const bt=this.config.normalized_config.hidden_size;Wt=new p.Tensor("float32",[],[0,bt])}({inputs_embeds:Xe}=await ee(this.sessions.prepare_inputs_embeds,{input_ids:O,image_features:Wt}))}return await _e(this,{inputs_embeds:Xe,past_key_values:it,attention_mask:Z,position_ids:Oe,generation_config:ht,logits_processor:St},!1)}}class ta extends J{}class Wa extends ta{}class $i extends ta{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"text_model"})}}class uu extends ta{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"text_model"})}}class ao extends ta{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"vision_model"})}}class rl extends ta{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"vision_model"})}}class sl extends J{}class io extends sl{}class oo extends sl{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"text_model"})}}class Di extends ta{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"vision_model"})}}class $t extends J{}class cu extends $t{}class lo extends J{}class du extends lo{async forward(O){const Z=!O.input_ids,ge=!O.pixel_values;if(Z&&ge)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(Z&&(O.input_ids=(0,p.ones)([O.pixel_values.dims[0],1])),ge){const{image_size:St}=this.config.vision_config;O.pixel_values=(0,p.full)([0,3,St,St],0)}const{text_embeddings:Se,image_embeddings:Oe,l2norm_text_embeddings:Xe,l2norm_image_embeddings:it}=await super.forward(O),ht={};return Z||(ht.text_embeddings=Se,ht.l2norm_text_embeddings=Xe),ge||(ht.image_embeddings=Oe,ht.l2norm_image_embeddings=it),ht}}class uo extends lo{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"text_model"})}}class ks extends lo{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"vision_model"})}}class Ii extends J{}class Hr extends Ii{}class Ha extends Ii{}class co extends J{}class al extends co{}class fo extends co{}class ho extends J{}class po extends ho{}class fu extends ho{}class Os extends J{}class Li extends Os{}class xa extends Os{}class zi extends J{}class il extends zi{}class na extends zi{}class ra extends J{}class mo extends ra{}class b extends ra{}class $ extends J{}class N extends ${}class K extends ${}class re extends J{}class ye extends re{}class He extends re{}class at extends J{}class yt extends at{}class Pt extends at{}class jt extends J{}class Xt extends jt{}class gn extends J{}class Pn extends gn{}class Ir extends gn{}class Ta extends J{}class Fc extends Ta{}class hu extends Ta{}class ol extends J{}class Rc extends ol{}class _o extends ol{}class Bc extends J{}class pu extends Bc{}class go extends Bc{}class hf extends J{}class _s extends hf{}class jc extends hf{}class sa extends J{}class pf extends sa{}class mu extends sa{}class Ka extends J{}class Nc extends Ka{}class Uc extends Ka{}class Fi extends J{}class yo extends Fi{}class _u extends Fi{}class ll extends J{}class $s extends ll{}class Ds extends ll{}class qa extends J{}class Ea extends qa{}class Sa extends qa{}class Qa extends J{}class mf extends Qa{}class Vc extends Qa{}class gu extends J{}class rs extends gu{}class cr extends gu{}class bn extends J{}class Ri extends bn{}class aa extends bn{}class yu extends J{}class Bi extends yu{}class _f extends yu{}class Gc extends J{}class ul extends Gc{}class cl extends Gc{}class Wc extends J{}class dl extends Wc{}class Hc extends Wc{}class Xa extends J{}class Ca extends Xa{}class Ya extends Xa{}class ia extends J{}class Kc extends ia{}class qc extends ia{}class fl extends J{forward_params=["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"]}class vu extends fl{get_rope_index(O,Z,ge,Se){const{vision_config:Oe,image_token_id:Xe,video_token_id:it,vision_start_token_id:ht}=this.config,St=Oe.spatial_merge_size??2,Vt=[];if(Z||ge){let Yt=O.tolist();Se||(Se=(0,p.ones_like)(O));const Wt=Se.tolist(),bt=Array.from({length:3},Ln=>Array.from({length:O.dims[0]},Hn=>Array.from({length:O.dims[1]},br=>1))),yn=Z?Z.tolist():[],Ct=ge?ge.tolist():[];let Lt=0,cn=0;for(let Ln=0;Ln<Yt.length;++Ln){const Hn=Yt[Ln].filter((qn,Mr)=>Wt[Ln][Mr]==1),wr=Hn.reduce((qn,Mr,Xi)=>(Mr==ht&&qn.push(Xi),qn),[]).map(qn=>Hn[qn+1]),ar=wr.filter(qn=>qn==Xe).length,nn=wr.filter(qn=>qn==it).length;let ir=[],Rr=0,Fo=ar,as=nn;for(let qn=0;qn<wr.length;++qn){const Mr=Hn.findIndex((jo,fa)=>fa>Rr&&jo==Xe),Xi=Hn.findIndex((jo,fa)=>fa>Rr&&jo==it),es=Fo>0&&Mr!==-1?Mr:Hn.length+1,Yi=as>0&&Xi!==-1?Xi:Hn.length+1;let cc,Qd,Bo,ws;es<Yi?([Qd,Bo,ws]=yn[Lt],++Lt,--Fo,cc=es):([Qd,Bo,ws]=Ct[cn],++cn,--as,cc=Yi);const[Cm,Dl,Qs]=[Number(Qd),Math.floor(Number(Bo)/St),Math.floor(Number(ws)/St)],ap=cc-Rr,Pm=ir.length>0?(0,v.max)(ir.at(-1))[0]+1:0;ir.push(Array.from({length:3*ap},(jo,fa)=>Pm+fa%ap));const Zi=ap+Pm,dc=Cm*Dl*Qs,Z_=Array.from({length:dc},(jo,fa)=>Zi+Math.floor(fa/(Dl*Qs))),J_=Array.from({length:dc},(jo,fa)=>Zi+Math.floor(fa/Qs)%Dl),eg=Array.from({length:dc},(jo,fa)=>Zi+fa%Qs);ir.push([Z_,J_,eg].flat()),Rr=cc+dc}if(Rr<Hn.length){const qn=ir.length>0?(0,v.max)(ir.at(-1))[0]+1:0,Mr=Hn.length-Rr;ir.push(Array.from({length:3*Mr},(Xi,es)=>qn+es%Mr))}const da=ir.reduce((qn,Mr)=>qn+Mr.length,0),$l=new Array(da);let Rs=0;for(let qn=0;qn<3;++qn)for(let Mr=0;Mr<ir.length;++Mr){const Xi=ir[Mr],es=Xi.length/3;for(let Yi=qn*es;Yi<(qn+1)*es;++Yi)$l[Rs++]=Xi[Yi]}let uc=0;const Ro=Wt[Ln];for(let qn=0;qn<Ro.length;++qn)if(Ro[qn]==1){for(let Mr=0;Mr<3;++Mr)bt[Mr][Ln][qn]=$l[Mr*da/3+uc];++uc}const Y_=(0,v.max)($l)[0];Vt.push(Y_+1-Yt[Ln].length)}return[new p.Tensor("int64",bt.flat(1/0),[3,O.dims[0],O.dims[1]]),new p.Tensor("int64",Vt,[Vt.length,1])]}else if(Se){const{data:Yt,dims:Wt}=Te(Se),bt=BigInt64Array.from({length:3*Yt.length},(Ct,Lt)=>Yt[Lt%Yt.length]),yn=Array.from({length:Wt[0]},(Ct,Lt)=>(0,v.max)(Yt.subarray(Wt[1]*Lt,Wt[1]*(Lt+1)))[0]+1n+BigInt(Wt[1]));return[new p.Tensor("int64",bt,[3,...Wt]),new p.Tensor("int64",yn,[yn.length,1])]}else{const[Yt,Wt]=O.dims,bt=BigInt64Array.from({length:3*Yt*Wt},(yn,Ct)=>BigInt(Math.floor(Ct%Wt/Yt)));return[new p.Tensor("int64",bt,[3,...O.dims]),(0,p.zeros)([Yt,1])]}}async encode_image({pixel_values:O,image_grid_thw:Z}){return(await ee(this.sessions.vision_encoder,{pixel_values:O,grid_thw:Z})).image_features}_merge_input_ids_with_image_features(O){return B({image_token_id:this.config.image_token_id,...O})}prepare_inputs_for_generation(O,Z,ge){if(Z.attention_mask&&!Z.position_ids)if(!Z.past_key_values)[Z.position_ids,Z.rope_deltas]=this.get_rope_index(Z.input_ids,Z.image_grid_thw,Z.video_grid_thw,Z.attention_mask);else{Z.pixel_values=null;const Se=BigInt(Object.values(Z.past_key_values)[0].dims.at(-2)),Oe=Z.rope_deltas.map(Xe=>Se+Xe);Z.position_ids=(0,p.stack)([Oe,Oe,Oe],0)}return Z}}class Za extends J{}class Jr extends Za{}class bu extends Za{}class Qc extends J{}class qp extends Qc{}class Qp extends Qc{}class gf extends J{}class Lr extends gf{}class Xc extends gf{}class vo extends J{}class hl extends vo{}class Yc extends vo{}class ji extends J{}class bo extends ji{}class Xp extends ji{}class Zc extends J{}class Yp extends Zc{}class yf extends Zc{async _call(O){return new Nt(await super._call(O))}}class Ja extends J{}class Jc extends Ja{}class wu extends Ja{async _call(O){return new Nt(await super._call(O))}}class vf extends J{}class pl extends vf{}class ed extends J{}class Mu extends ed{}class td extends ed{async _call(O){return new Nt(await super._call(O))}}class bf extends J{}class xu extends bf{}class nd extends J{}class ml extends nd{}class wf extends nd{async _call(O){return new Nt(await super._call(O))}}class Mf extends J{}class ei extends Mf{}class Tu extends J{}class rd extends Tu{}class ti extends Tu{async _call(O){return new Nt(await super._call(O))}}class ni extends J{}class _l extends ni{async _call(O){return new un(await super._call(O))}}class Eu extends J{}class sd extends Eu{}class gl extends Eu{async _call(O){return new Nt(await super._call(O))}}class wo extends J{}class xf extends wo{}class Tf extends wo{async _call(O){return new Nt(await super._call(O))}}class Ni extends J{}class Su extends Ni{}class Ef extends Ni{}class Cu extends J{}class ad extends Cu{}class ri extends Cu{}class sn extends J{}class Fn extends sn{}class Sr extends sn{async _call(O){return new Nt(await super._call(O))}}class Mo extends J{}class xo extends Mo{}class Ui extends Mo{async _call(O){return new To(await super._call(O))}}class yl extends Mo{async _call(O){return new Eo(await super._call(O))}}class To extends be{constructor({logits:O,pred_boxes:Z}){super(),this.logits=O,this.pred_boxes=Z}}class Eo extends be{constructor({logits:O,pred_boxes:Z,pred_masks:ge}){super(),this.logits=O,this.pred_boxes=Z,this.pred_masks=ge}}class Sf extends J{}class yr extends Sf{}class id extends Sf{async _call(O){return new So(await super._call(O))}}class So extends be{constructor({logits:O,pred_boxes:Z}){super(),this.logits=O,this.pred_boxes=Z}}class od extends J{}class Cf extends od{}class Zp extends od{async _call(O){return new ld(await super._call(O))}}class ld extends So{}class Pu extends J{}class ud extends Pu{}class ds extends Pu{async _call(O){return new Cr(await super._call(O))}}class Cr extends So{}class Au extends J{}class vl extends Au{}class ku extends Au{async _call(O){return new So(await super._call(O))}}class Ou extends J{}class Pa extends Ou{}class $u extends Ou{async _call(O){return new cd(await super._call(O))}}class cd extends To{}class Du extends J{}class Pf extends Du{}class Af extends Du{async _call(O){return new Nt(await super._call(O))}}class dd extends J{}class kf extends dd{}class Of extends dd{async _call(O){return new Nt(await super._call(O))}}class fd extends J{}class hd extends fd{}class $f extends fd{async _call(O){return new Nt(await super._call(O))}}class pd extends J{}class Df extends pd{}class If extends pd{async _call(O){return new Nt(await super._call(O))}}class Lf extends pd{}class Iu extends J{}class zf extends Iu{}class Ff extends Iu{}class md extends J{}class Rf extends md{}class Bf extends md{}class Jp extends J{}class jf extends Jp{}class si extends J{}class Lu extends si{}class Nf extends si{}class zu extends si{}class bl extends J{}class Uf extends bl{}class Vf extends J{}class Gf extends Vf{}class Wf extends J{}class Hf extends Wf{}class _d extends J{}class gd extends _d{}class Kf extends _d{}class yd extends J{}class vd extends yd{}class qf extends yd{}class Qf extends J{}class em extends Qf{}class Fu extends J{}class Xf extends Fu{}class Yf extends Fu{async _call(O){return new Nt(await super._call(O))}}class Ru extends J{}class Zf extends Ru{}class Jf extends Ru{async _call(O){return new Nt(await super._call(O))}}class eh extends J{}class tm extends eh{}class th extends eh{async _call(O){return new Nt(await super._call(O))}}class Co extends J{}class bd extends Co{}class Bu extends Co{async _call(O){return new Nt(await super._call(O))}}class nh extends J{}class rh extends nh{}class ju extends J{}class sh extends ju{}class ah extends J{}class nm extends ah{}class Vi extends J{}class wl extends Vi{}class Nu extends Vi{async _call(O){return new Ml(await super._call(O))}}class Ml extends be{constructor({logits:O,pred_boxes:Z}){super(),this.logits=O,this.pred_boxes=Z}}class Uu extends J{}class ih extends Uu{async get_image_embeddings({pixel_values:O}){return await te(this,{pixel_values:O})}async forward(O){if((!O.image_embeddings||!O.image_positional_embeddings)&&(O={...O,...await this.get_image_embeddings(O)}),!O.input_labels&&O.input_points){const ge=O.input_points.dims.slice(0,-1),Se=ge.reduce((Oe,Xe)=>Oe*Xe,1);O.input_labels=new p.Tensor("int64",new BigInt64Array(Se).fill(1n),ge)}const Z={image_embeddings:O.image_embeddings,image_positional_embeddings:O.image_positional_embeddings};return O.input_points&&(Z.input_points=O.input_points),O.input_labels&&(Z.input_labels=O.input_labels),O.input_boxes&&(Z.input_boxes=O.input_boxes),await ee(this.sessions.prompt_encoder_mask_decoder,Z)}async _call(O){return new oh(await super._call(O))}}class oh extends be{constructor({iou_scores:O,pred_masks:Z}){super(),this.iou_scores=O,this.pred_masks=Z}}class Gi extends J{}class lh extends Gi{}class Is extends Gi{}class Hs extends J{}class ai extends Hs{}class uh extends Hs{}class fs extends J{}class Aa extends fs{}class zr extends fs{async _call(O){return new zo(await super._call(O))}}class Vu extends fs{async _call(O){return new Nt(await super._call(O))}}class wd extends fs{async _call(O){return new Fr(await super._call(O))}}class Gu extends J{}class ch extends Gu{}class dh extends Gu{async _call(O){return new Fr(await super._call(O))}}class Wi extends J{}class Wu extends Wi{}class Hu extends J{}class fh extends Hu{}class hh extends Hu{async _call(O){return new zo(await super._call(O))}}class Ku extends Hu{async _call(O){return new Nt(await super._call(O))}}class xl extends J{}class Md extends xl{}class ph extends xl{async _call(O){return new zo(await super._call(O))}}class mh extends xl{async _call(O){return new Nt(await super._call(O))}}class rm extends xl{async _call(O){return new Fr(await super._call(O))}}class qu extends J{}class Nr extends qu{}class Kr extends qu{async _call(O){return new zo(await super._call(O))}}class _h extends qu{async _call(O){return new Nt(await super._call(O))}}class sm extends J{}class gh extends fs{}class yh extends fs{async _call(O){return new zo(await super._call(O))}}class vh extends fs{async _call(O){return new Nt(await super._call(O))}}class ii extends J{}class xd extends ii{}class bh extends ii{async _call(O){return new zo(await super._call(O))}}class wh extends ii{async _call(O){return new Nt(await super._call(O))}}class Mh extends ii{async _call(O){return new Kd(await super._call(O))}}class Td extends ii{async _call(O){return new Fr(await super._call(O))}}class Ed extends J{}class Sd extends Ed{}class Qu extends J{}class xh extends Qu{}class Xu extends Qu{}class Cd extends Qu{async generate_speech(O,Z,{threshold:ge=.5,minlenratio:Se=0,maxlenratio:Oe=20,vocoder:Xe=null}={}){const it={input_ids:O},{encoder_outputs:ht,encoder_attention_mask:St}=await te(this,it),Vt=ht.dims[1]/this.config.reduction_factor,Yt=Math.floor(Vt*Oe),Wt=Math.floor(Vt*Se),bt=this.config.num_mel_bins;let yn=[],Ct=null,Lt=null,cn=0;for(;;){++cn;const br=ae(!!Lt);let wr;Lt?wr=Lt.output_sequence_out:wr=new p.Tensor("float32",new Float32Array(bt),[1,1,bt]);let ar={use_cache_branch:br,output_sequence:wr,encoder_attention_mask:St,speaker_embeddings:Z,encoder_hidden_states:ht};this.addPastKeyValues(ar,Ct),Lt=await ee(this.sessions.decoder_model_merged,ar),Ct=this.getPastKeyValues(Lt,Ct);const{prob:nn,spectrum:ir}=Lt;if(yn.push(ir),cn>=Wt&&(Array.from(nn.data).filter(Rr=>Rr>=ge).length>0||cn>=Yt))break}const Ln=(0,p.cat)(yn),{waveform:Hn}=await ee(Xe.sessions.model,{spectrogram:Ln});return{spectrogram:Ln,waveform:Hn}}}class Th extends J{main_input_name="spectrogram"}class Pd extends J{}class Eh extends Pd{}class oa extends J{}class Ad extends oa{}class am extends oa{}class kd extends J{}class ka extends kd{}class Sh extends kd{}class Tl extends J{}class El extends Tl{}class sr extends Tl{}class Ch extends J{}class im extends Ch{}class Ph extends Ch{}class Hi extends J{}class oi extends Hi{}class Ah extends Hi{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"text_model"})}}class kh extends Hi{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"audio_model"})}}class Sl extends J{}class Ks extends Sl{async _call(O){return new qd(await super._call(O))}}class Yu extends J{}class Oh extends Yu{}class $h extends Yu{}class Od extends Yu{}class Zu extends J{}class Ju extends Zu{}class Dh extends Zu{}class la extends J{}class vr extends la{}class $d extends la{async _call(O){return new Nt(await super._call(O))}}class Dd extends J{}class qr extends Dd{}class U_ extends Dd{}class Id extends J{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"];_apply_and_filter_by_delay_pattern_mask(O){const[Z,ge]=O.dims,Se=this.config.decoder.num_codebooks,Oe=ge-Se;let Xe=0;for(let St=0;St<O.size;++St){if(O.data[St]===this.config.decoder.pad_token_id)continue;const Vt=St%ge,Yt=Math.floor(St/ge)%Se,Wt=Vt-Yt;Wt>0&&Wt<=Oe&&(O.data[Xe++]=O.data[St])}const it=Math.floor(Z/Se),ht=Xe/(it*Se);return new p.Tensor(O.type,O.data.slice(0,Xe),[it,Se,ht])}prepare_inputs_for_generation(O,Z,ge){let Se=structuredClone(O);for(let Xe=0;Xe<Se.length;++Xe)for(let it=0;it<Se[Xe].length;++it)Xe%this.config.decoder.num_codebooks>=it&&(Se[Xe][it]=BigInt(this.config.decoder.pad_token_id));return ge.guidance_scale!==null&&ge.guidance_scale>1&&(Se=Se.concat(Se)),super.prepare_inputs_for_generation(Se,Z,ge)}async generate(O){const Z=await super.generate(O),ge=this._apply_and_filter_by_delay_pattern_mask(Z).unsqueeze_(0),{audio_values:Se}=await ee(this.sessions.encodec_decode,{audio_codes:ge});return Se}}class ec extends J{}class Zn extends ec{}class hs extends ec{async _call(O){return new Nt(await super._call(O))}}class Oa extends ec{}class tc extends J{}class Ih extends tc{}class om extends tc{async _call(O){return new Nt(await super._call(O))}}class Ld extends tc{}class ss extends J{}class qs extends ss{}class Lh extends ss{async _call(O){return new Nt(await super._call(O))}}class gs extends ss{}class nc extends J{}class li extends nc{}class Ki extends nc{async _call(O){return new Nt(await super._call(O))}}class ui extends nc{}class zd extends J{}class Fd extends zd{}class ua extends J{}class zh extends ua{forward_params=["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"];constructor(...O){super(...O),this._generation_mode="text"}async forward(O){const Z=this._generation_mode??"text";let ge;if(Z==="text"||!O.past_key_values){const ht=this.sessions.prepare_inputs_embeds,St=(0,d.pick)(O,ht.inputNames);ge=await ee(ht,St)}else{const ht=this.sessions.gen_img_embeds,St=(0,d.pick)({image_ids:O.input_ids},ht.inputNames);ge=await ee(ht,St)}const Se={...O,...ge},Oe=await _e(this,Se),Xe=this.sessions[Z==="text"?"lm_head":"gen_head"];if(!Xe)throw new Error(`Unable to find "${Xe}" generation head`);const it=await ee(Xe,(0,d.pick)(Oe,Xe.inputNames));return{...ge,...Oe,...it}}async generate(O){return this._generation_mode="text",super.generate(O)}async generate_images(O){this._generation_mode="image";const Z=(O.inputs??O[this.main_input_name]).dims[1],Se=(await super.generate(O)).slice(null,[Z,null]),Oe=this.sessions.image_decode,{decoded_image:Xe}=await ee(Oe,{generated_tokens:Se}),it=Xe.add_(1).mul_(255/2).clamp_(0,255).to("uint8"),ht=[];for(const St of it){const Vt=y.RawImage.fromTensor(St);ht.push(Vt)}return ht}}class Po extends be{constructor({char_logits:O,bpe_logits:Z,wp_logits:ge}){super(),this.char_logits=O,this.bpe_logits=Z,this.wp_logits=ge}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class Cl extends J{}class Pl extends Cl{async _call(O){return new Po(await super._call(O))}}class qi extends J{}class Fh extends qi{}class Rh extends qi{}class Ao extends J{}class Bh extends Ao{}class rc extends Ao{}class jh extends J{forward_params=["input_ids","attention_mask","position_ids","audio_values","past_key_values"]}class Nh extends jh{_merge_input_ids_with_audio_features(O){const Z=O.audio_features.dims.at(-1),ge=O.audio_features.view(-1,Z);return R({audio_token_id:this.config.ignore_index??this.config.audio_token_id,...O,audio_features:ge})}}class lm extends Nh{}class xn extends J{main_input_name="input_values";forward_params=["input_values"]}class Gn extends be{constructor({audio_codes:O}){super(),this.audio_codes=O}}class ln extends be{constructor({audio_values:O}){super(),this.audio_values=O}}class pn extends xn{async encode(O){return new Gn(await ee(this.sessions.encoder_model,O))}async decode(O){return new ln(await ee(this.sessions.decoder_model,O))}}class In extends xn{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"encoder_model"})}}class ys extends xn{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"decoder_model"})}}class ca extends J{main_input_name="input_values";forward_params=["input_values"]}class ko extends be{constructor({audio_codes:O}){super(),this.audio_codes=O}}class Rd extends be{constructor({audio_values:O}){super(),this.audio_values=O}}class $a extends ca{async encode(O){return new ko(await ee(this.sessions.encoder_model,O))}async decode(O){return new Rd(await ee(this.sessions.decoder_model,O))}}class dr extends ca{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"encoder_model"})}}class ci extends ca{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"decoder_model"})}}class Da extends J{main_input_name="input_values";forward_params=["input_values"]}class Bd extends Da{async encode(O){return await ee(this.sessions.encoder_model,O)}async decode(O){return await ee(this.sessions.decoder_model,O)}}class Ls extends Da{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"encoder_model"})}}class Oo extends Da{static async from_pretrained(O,Z={}){return super.from_pretrained(O,{...Z,model_file_name:Z.model_file_name??"decoder_model"})}}class fn{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(O,{progress_callback:Z=null,config:ge=null,cache_dir:Se=null,local_files_only:Oe=!1,revision:Xe="main",model_file_name:it=null,subfolder:ht="onnx",device:St=null,dtype:Vt=null,use_external_data_format:Yt=null,session_options:Wt={}}={}){const bt={progress_callback:Z,config:ge,cache_dir:Se,local_files_only:Oe,revision:Xe,model_file_name:it,subfolder:ht,device:St,dtype:Vt,use_external_data_format:Yt,session_options:Wt};if(bt.config=await a.AutoConfig.from_pretrained(O,bt),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);const yn=bt.config.model_type;for(const Ct of this.MODEL_CLASS_MAPPINGS){let Lt=Ct.get(yn);if(!Lt){for(const cn of Ct.values())if(cn[0]===yn){Lt=cn;break}if(!Lt)continue}return await Lt[1].from_pretrained(O,bt)}if(this.BASE_IF_FAIL)return ep.has(yn)||console.warn(`Unknown model class "${yn}", attempting to construct from base class.`),await J.from_pretrained(O,bt);throw Error(`Unsupported model type: ${yn}`)}}const vs=new Map([["bert",["BertModel",De]],["neobert",["NeoBertModel",_t]],["modernbert",["ModernBertModel",pt]],["nomic_bert",["NomicBertModel",Br]],["roformer",["RoFormerModel",er]],["electra",["ElectraModel",ce]],["esm",["EsmModel",Gs]],["convbert",["ConvBertModel",zt]],["camembert",["CamembertModel",Tt]],["deberta",["DebertaModel",wn]],["deberta-v2",["DebertaV2Model",lr]],["mpnet",["MPNetModel",Gr]],["albert",["AlbertModel",gt]],["distilbert",["DistilBertModel",ur]],["roberta",["RobertaModel",Va]],["xlm",["XLMModel",Qo]],["xlm-roberta",["XLMRobertaModel",Xl]],["clap",["ClapModel",oi]],["clip",["CLIPModel",Wa]],["clipseg",["CLIPSegModel",Hr]],["chinese_clip",["ChineseCLIPModel",cu]],["siglip",["SiglipModel",io]],["jina_clip",["JinaCLIPModel",du]],["mobilebert",["MobileBertModel",Et]],["squeezebert",["SqueezeBertModel",se]],["wav2vec2",["Wav2Vec2Model",Aa]],["wav2vec2-bert",["Wav2Vec2BertModel",Nr]],["unispeech",["UniSpeechModel",fh]],["unispeech-sat",["UniSpeechSatModel",Md]],["hubert",["HubertModel",gh]],["wavlm",["WavLMModel",xd]],["audio-spectrogram-transformer",["ASTModel",eu]],["vits",["VitsModel",Ks]],["pyannote",["PyAnnoteModel",ch]],["wespeaker-resnet",["WeSpeakerResNetModel",Wu]],["detr",["DetrModel",xo]],["rt_detr",["RTDetrModel",yr]],["rt_detr_v2",["RTDetrV2Model",Cf]],["rf_detr",["RFDetrModel",ud]],["d_fine",["DFineModel",vl]],["table-transformer",["TableTransformerModel",Pa]],["vit",["ViTModel",Yp]],["ijepa",["IJepaModel",Jc]],["pvt",["PvtModel",Mu]],["vit_msn",["ViTMSNModel",ml]],["vit_mae",["ViTMAEModel",xu]],["groupvit",["GroupViTModel",ei]],["fastvit",["FastViTModel",rd]],["mobilevit",["MobileViTModel",sd]],["mobilevitv2",["MobileViTV2Model",xf]],["owlvit",["OwlViTModel",Su]],["owlv2",["Owlv2Model",ad]],["beit",["BeitModel",Fn]],["deit",["DeiTModel",Pf]],["hiera",["HieraModel",kf]],["convnext",["ConvNextModel",Xf]],["convnextv2",["ConvNextV2Model",Zf]],["dinov2",["Dinov2Model",tm]],["dinov2_with_registers",["Dinov2WithRegistersModel",bd]],["dinov3_vit",["DINOv3ViTModel",rh]],["dinov3_convnext",["DINOv3ConvNextModel",sh]],["resnet",["ResNetModel",hd]],["swin",["SwinModel",Df]],["swin2sr",["Swin2SRModel",zf]],["donut-swin",["DonutSwinModel",em]],["yolos",["YolosModel",wl]],["dpt",["DPTModel",Rf]],["glpn",["GLPNModel",vd]],["hifigan",["SpeechT5HifiGan",Th]],["efficientnet",["EfficientNetModel",vr]],["decision_transformer",["DecisionTransformerModel",Fd]],["patchtst",["PatchTSTForPrediction",Fh]],["patchtsmixer",["PatchTSMixerForPrediction",Bh]],["mobilenet_v1",["MobileNetV1Model",Zn]],["mobilenet_v2",["MobileNetV2Model",Ih]],["mobilenet_v3",["MobileNetV3Model",qs]],["mobilenet_v4",["MobileNetV4Model",li]],["maskformer",["MaskFormerModel",gd]],["mgp-str",["MgpstrForSceneTextRecognition",Pl]],["style_text_to_speech_2",["StyleTextToSpeech2Model",Sd]]]),Uh=new Map([["t5",["T5Model",Ut]],["longt5",["LongT5Model",jn]],["mt5",["MT5Model",Wr]],["bart",["BartModel",us]],["mbart",["MBartModel",ps]],["marian",["MarianModel",lh]],["whisper",["WhisperModel",nu]],["m2m_100",["M2M100Model",ai]],["blenderbot",["BlenderbotModel",Mn]],["blenderbot-small",["BlenderbotSmallModel",cs]]]),Vh=new Map([["mimi",["MimiModel",pn]],["dac",["DacModel",$a]],["snac",["SnacModel",Bd]]]),jd=new Map([["bloom",["BloomModel",Lr]],["jais",["JAISModel",po]],["gpt2",["GPT2Model",al]],["gptj",["GPTJModel",mo]],["gpt_bigcode",["GPTBigCodeModel",N]],["gpt_neo",["GPTNeoModel",Li]],["gpt_neox",["GPTNeoXModel",il]],["codegen",["CodeGenModel",ye]],["llama",["LlamaModel",yt]],["arcee",["ArceeModel",Pn]],["lfm2",["Lfm2Model",Fc]],["smollm3",["SmolLM3Model",Rc]],["exaone",["ExaoneModel",pf]],["olmo",["OlmoModel",yo]],["olmo2",["Olmo2Model",$s]],["mobilellm",["MobileLLMModel",Nc]],["granite",["GraniteModel",Ea]],["cohere",["CohereModel",mf]],["gemma",["GemmaModel",rs]],["gemma2",["Gemma2Model",Ri]],["vaultgemma",["VaultGemmaModel",Bi]],["gemma3_text",["Gemma3Model",ul]],["helium",["HeliumModel",pu]],["glm",["GlmModel",_s]],["openelm",["OpenELMModel",dl]],["qwen2",["Qwen2Model",Ca]],["qwen3",["Qwen3Model",Kc]],["phi",["PhiModel",Jr]],["phi3",["Phi3Model",qp]],["mpt",["MptModel",hl]],["opt",["OPTModel",bo]],["mistral",["MistralModel",Ad]],["ernie4_5",["Ernie4_5_Model",ka]],["starcoder2",["Starcoder2Model",El]],["falcon",["FalconModel",im]],["stablelm",["StableLmModel",Ju]],["modernbert-decoder",["ModernBertDecoderModel",Ft]]]),Al=new Map([["speecht5",["SpeechT5ForSpeechToText",Xu]],["whisper",["WhisperForConditionalGeneration",Xo]],["lite-whisper",["LiteWhisperForConditionalGeneration",Ic]],["moonshine",["MoonshineForConditionalGeneration",Yo]]]),di=new Map([["speecht5",["SpeechT5ForTextToSpeech",Cd]]]),Qr=new Map([["vits",["VitsModel",Ks]],["musicgen",["MusicgenForConditionalGeneration",Id]]]),fi=new Map([["bert",["BertForSequenceClassification",Ve]],["neobert",["NeoBertForSequenceClassification",xt]],["modernbert",["ModernBertForSequenceClassification",Mt]],["roformer",["RoFormerForSequenceClassification",ja]],["electra",["ElectraForSequenceClassification",ue]],["esm",["EsmForSequenceClassification",Zr]],["convbert",["ConvBertForSequenceClassification",En]],["camembert",["CamembertForSequenceClassification",mt]],["deberta",["DebertaForSequenceClassification",Sn]],["deberta-v2",["DebertaV2ForSequenceClassification",Vs]],["mpnet",["MPNetForSequenceClassification",Ei]],["albert",["AlbertForSequenceClassification",vt]],["distilbert",["DistilBertForSequenceClassification",mr]],["roberta",["RobertaForSequenceClassification",Ql]],["xlm",["XLMForSequenceClassification",kc]],["xlm-roberta",["XLMRobertaForSequenceClassification",Zl]],["bart",["BartForSequenceClassification",nr]],["mbart",["MBartForSequenceClassification",rr]],["mobilebert",["MobileBertForSequenceClassification",va]],["squeezebert",["SqueezeBertForSequenceClassification",me]]]),$o=new Map([["bert",["BertForTokenClassification",Ee]],["neobert",["NeoBertForTokenClassification",st]],["modernbert",["ModernBertForTokenClassification",tn]],["roformer",["RoFormerForTokenClassification",ga]],["electra",["ElectraForTokenClassification",pe]],["esm",["EsmForTokenClassification",et]],["convbert",["ConvBertForTokenClassification",Kt]],["camembert",["CamembertForTokenClassification",Zt]],["deberta",["DebertaForTokenClassification",Bn]],["deberta-v2",["DebertaV2ForTokenClassification",Xr]],["mpnet",["MPNetForTokenClassification",Si]],["distilbert",["DistilBertForTokenClassification",tr]],["roberta",["RobertaForTokenClassification",Cc]],["xlm",["XLMForTokenClassification",Oc]],["xlm-roberta",["XLMRobertaForTokenClassification",Jl]]]),Qi=new Map([["t5",["T5ForConditionalGeneration",Dn]],["longt5",["LongT5ForConditionalGeneration",Vn]],["mt5",["MT5ForConditionalGeneration",Dr]],["bart",["BartForConditionalGeneration",vn]],["mbart",["MBartForConditionalGeneration",ms]],["marian",["MarianMTModel",Is]],["m2m_100",["M2M100ForConditionalGeneration",uh]],["blenderbot",["BlenderbotForConditionalGeneration",Yn]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",ba]]]),sc=new Map([["bloom",["BloomForCausalLM",Xc]],["gpt2",["GPT2LMHeadModel",fo]],["jais",["JAISLMHeadModel",fu]],["gptj",["GPTJForCausalLM",b]],["gpt_bigcode",["GPTBigCodeForCausalLM",K]],["gpt_neo",["GPTNeoForCausalLM",xa]],["gpt_neox",["GPTNeoXForCausalLM",na]],["codegen",["CodeGenForCausalLM",He]],["llama",["LlamaForCausalLM",Pt]],["llama4_text",["Llama4ForCausalLM",Xt]],["arcee",["ArceeForCausalLM",Ir]],["lfm2",["Lfm2ForCausalLM",hu]],["smollm3",["SmolLM3ForCausalLM",_o]],["exaone",["ExaoneForCausalLM",mu]],["olmo",["OlmoForCausalLM",_u]],["olmo2",["Olmo2ForCausalLM",Ds]],["mobilellm",["MobileLLMForCausalLM",Uc]],["granite",["GraniteForCausalLM",Sa]],["cohere",["CohereForCausalLM",Vc]],["gemma",["GemmaForCausalLM",cr]],["gemma2",["Gemma2ForCausalLM",aa]],["vaultgemma",["VaultGemmaForCausalLM",_f]],["gemma3_text",["Gemma3ForCausalLM",cl]],["helium",["HeliumForCausalLM",go]],["glm",["GlmForCausalLM",jc]],["openelm",["OpenELMForCausalLM",Hc]],["qwen2",["Qwen2ForCausalLM",Ya]],["qwen3",["Qwen3ForCausalLM",qc]],["phi",["PhiForCausalLM",bu]],["phi3",["Phi3ForCausalLM",Qp]],["mpt",["MptForCausalLM",Yc]],["opt",["OPTForCausalLM",Xp]],["mbart",["MBartForCausalLM",As]],["mistral",["MistralForCausalLM",am]],["ernie4_5",["Ernie4_5_ForCausalLM",Sh]],["starcoder2",["Starcoder2ForCausalLM",sr]],["falcon",["FalconForCausalLM",Ph]],["trocr",["TrOCRForCausalLM",Eh]],["stablelm",["StableLmForCausalLM",Dh]],["modernbert-decoder",["ModernBertDecoderForCausalLM",or]],["phi3_v",["Phi3VForCausalLM",Oi]]]),Gh=new Map([["multi_modality",["MultiModalityCausalLM",zh]]]),Wh=new Map([["bert",["BertForMaskedLM",xe]],["neobert",["NeoBertForMaskedLM",Re]],["modernbert",["ModernBertForMaskedLM",lt]],["roformer",["RoFormerForMaskedLM",jr]],["electra",["ElectraForMaskedLM",X]],["esm",["EsmForMaskedLM",Na]],["convbert",["ConvBertForMaskedLM",Zs]],["camembert",["CamembertForMaskedLM",At]],["deberta",["DebertaForMaskedLM",Un]],["deberta-v2",["DebertaV2ForMaskedLM",ea]],["mpnet",["MPNetForMaskedLM",Ua]],["albert",["AlbertForMaskedLM",dt]],["distilbert",["DistilBertForMaskedLM",Yr]],["roberta",["RobertaForMaskedLM",ro]],["xlm",["XLMWithLMHeadModel",Ac]],["xlm-roberta",["XLMRobertaForMaskedLM",Yl]],["mobilebert",["MobileBertForMaskedLM",$n]],["squeezebert",["SqueezeBertForMaskedLM",de]]]),kl=new Map([["bert",["BertForQuestionAnswering",Ge]],["neobert",["NeoBertForQuestionAnswering",nt]],["roformer",["RoFormerForQuestionAnswering",Es]],["electra",["ElectraForQuestionAnswering",ke]],["convbert",["ConvBertForQuestionAnswering",Js]],["camembert",["CamembertForQuestionAnswering",qt]],["deberta",["DebertaForQuestionAnswering",hr]],["deberta-v2",["DebertaV2ForQuestionAnswering",ya]],["mpnet",["MPNetForQuestionAnswering",we]],["albert",["AlbertForQuestionAnswering",wt]],["distilbert",["DistilBertForQuestionAnswering",Er]],["roberta",["RobertaForQuestionAnswering",Pc]],["xlm",["XLMForQuestionAnswering",$c]],["xlm-roberta",["XLMRobertaForQuestionAnswering",Dc]],["mobilebert",["MobileBertForQuestionAnswering",Cs]],["squeezebert",["SqueezeBertForQuestionAnswering",Ie]]]),ac=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Zo]],["idefics3",["Idefics3ForConditionalGeneration",tl]],["smolvlm",["SmolVLMForConditionalGeneration",lu]]]),bs=new Map([["llava",["LlavaForConditionalGeneration",Jo]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",Lc]],["moondream1",["Moondream1ForConditionalGeneration",el]],["florence2",["Florence2ForConditionalGeneration",zc]],["qwen2-vl",["Qwen2VLForConditionalGeneration",vu]],["idefics3",["Idefics3ForConditionalGeneration",tl]],["smolvlm",["SmolVLMForConditionalGeneration",lu]],["paligemma",["PaliGemmaForConditionalGeneration",iu]],["llava_qwen2",["LlavaQwen2ForCausalLM",ou]],["gemma3n",["Gemma3nForConditionalGeneration",wa]]]),Hh=new Map([["ultravox",["UltravoxModel",Nh]],["voxtral",["VoxtralForConditionalGeneration",lm]]]),zs=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Zo]]]),Kh=new Map([["vit",["ViTForImageClassification",yf]],["ijepa",["IJepaForImageClassification",wu]],["pvt",["PvtForImageClassification",td]],["vit_msn",["ViTMSNForImageClassification",wf]],["fastvit",["FastViTForImageClassification",ti]],["mobilevit",["MobileViTForImageClassification",gl]],["mobilevitv2",["MobileViTV2ForImageClassification",Tf]],["beit",["BeitForImageClassification",Sr]],["deit",["DeiTForImageClassification",Af]],["hiera",["HieraForImageClassification",Of]],["convnext",["ConvNextForImageClassification",Yf]],["convnextv2",["ConvNextV2ForImageClassification",Jf]],["dinov2",["Dinov2ForImageClassification",th]],["dinov2_with_registers",["Dinov2WithRegistersForImageClassification",Bu]],["resnet",["ResNetForImageClassification",$f]],["swin",["SwinForImageClassification",If]],["segformer",["SegformerForImageClassification",$h]],["efficientnet",["EfficientNetForImageClassification",$d]],["mobilenet_v1",["MobileNetV1ForImageClassification",hs]],["mobilenet_v2",["MobileNetV2ForImageClassification",om]],["mobilenet_v3",["MobileNetV3ForImageClassification",Lh]],["mobilenet_v4",["MobileNetV4ForImageClassification",Ki]]]),qh=new Map([["detr",["DetrForObjectDetection",Ui]],["rt_detr",["RTDetrForObjectDetection",id]],["rt_detr_v2",["RTDetrV2ForObjectDetection",Zp]],["rf_detr",["RFDetrForObjectDetection",ds]],["d_fine",["DFineForObjectDetection",ku]],["table-transformer",["TableTransformerForObjectDetection",$u]],["yolos",["YolosForObjectDetection",Nu]]]),um=new Map([["owlvit",["OwlViTForObjectDetection",Ef]],["owlv2",["Owlv2ForObjectDetection",ri]],["grounding-dino",["GroundingDinoForObjectDetection",nm]]]),Fs=new Map([["detr",["DetrForSegmentation",yl]],["clipseg",["CLIPSegForImageSegmentation",Ha]]]),ic=new Map([["segformer",["SegformerForSemanticSegmentation",Od]],["sapiens",["SapiensForSemanticSegmentation",Lu]],["swin",["SwinForSemanticSegmentation",Lf]],["mobilenet_v1",["MobileNetV1ForSemanticSegmentation",Oa]],["mobilenet_v2",["MobileNetV2ForSemanticSegmentation",Ld]],["mobilenet_v3",["MobileNetV3ForSemanticSegmentation",gs]],["mobilenet_v4",["MobileNetV4ForSemanticSegmentation",ui]]]),Nd=new Map([["detr",["DetrForSegmentation",yl]],["maskformer",["MaskFormerForInstanceSegmentation",Kf]]]),Do=new Map([["sam",["SamModel",ih]]]),Qh=new Map([["wav2vec2",["Wav2Vec2ForCTC",zr]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Kr]],["unispeech",["UniSpeechForCTC",hh]],["unispeech-sat",["UniSpeechSatForCTC",ph]],["wavlm",["WavLMForCTC",bh]],["hubert",["HubertForCTC",yh]]]),Xh=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Vu]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",_h]],["unispeech",["UniSpeechForSequenceClassification",Ku]],["unispeech-sat",["UniSpeechSatForSequenceClassification",mh]],["wavlm",["WavLMForSequenceClassification",wh]],["hubert",["HubertForSequenceClassification",vh]],["audio-spectrogram-transformer",["ASTForAudioClassification",tu]]]),Yh=new Map([["wavlm",["WavLMForXVector",Mh]]]),Ud=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",rm]],["wavlm",["WavLMForAudioFrameClassification",Td]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",wd]],["pyannote",["PyAnnoteForAudioFrameClassification",dh]]]),Vd=new Map([["vitmatte",["VitMatteForImageMatting",_l]]]),V_=new Map([["patchtst",["PatchTSTForPrediction",Rh]],["patchtsmixer",["PatchTSMixerForPrediction",rc]]]),cm=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Ff]]]),dm=new Map([["dpt",["DPTForDepthEstimation",Bf]],["depth_anything",["DepthAnythingForDepthEstimation",jf]],["glpn",["GLPNForDepthEstimation",qf]],["sapiens",["SapiensForDepthEstimation",Nf]],["depth_pro",["DepthProForDepthEstimation",Uf]],["metric3d",["Metric3DForDepthEstimation",Gf]],["metric3dv2",["Metric3Dv2ForDepthEstimation",Hf]]]),Zh=new Map([["sapiens",["SapiensForNormalEstimation",zu]]]),Jh=new Map([["vitpose",["VitPoseForPoseEstimation",pl]]]),Io=new Map([["clip",["CLIPVisionModelWithProjection",rl]],["siglip",["SiglipVisionModel",Di]],["jina_clip",["JinaCLIPVisionModel",ks]]]),oc=[[vs,P.EncoderOnly],[Uh,P.EncoderDecoder],[jd,P.DecoderOnly],[Vh,P.AutoEncoder],[fi,P.EncoderOnly],[$o,P.EncoderOnly],[Qi,P.Seq2Seq],[Al,P.Seq2Seq],[sc,P.DecoderOnly],[Gh,P.MultiModality],[Wh,P.EncoderOnly],[kl,P.EncoderOnly],[ac,P.Vision2Seq],[bs,P.ImageTextToText],[Hh,P.AudioTextToText],[Kh,P.EncoderOnly],[Fs,P.EncoderOnly],[Nd,P.EncoderOnly],[ic,P.EncoderOnly],[Vd,P.EncoderOnly],[V_,P.EncoderOnly],[cm,P.EncoderOnly],[dm,P.EncoderOnly],[Zh,P.EncoderOnly],[Jh,P.EncoderOnly],[qh,P.EncoderOnly],[um,P.EncoderOnly],[Do,P.MaskGeneration],[Qh,P.EncoderOnly],[Xh,P.EncoderOnly],[di,P.Seq2Seq],[Qr,P.EncoderOnly],[Yh,P.EncoderOnly],[Ud,P.EncoderOnly],[Io,P.EncoderOnly]];for(const[A,O]of oc)for(const[Z,ge]of A.values())S.set(Z,O),C.set(ge,Z),k.set(Z,ge);const fm=[["MusicgenForConditionalGeneration",Id,P.Musicgen],["Phi3VForCausalLM",Oi,P.Phi3V],["CLIPTextModelWithProjection",uu,P.EncoderOnly],["SiglipTextModel",oo,P.EncoderOnly],["JinaCLIPTextModel",uo,P.EncoderOnly],["ClapTextModelWithProjection",Ah,P.EncoderOnly],["ClapAudioModelWithProjection",kh,P.EncoderOnly],["DacEncoderModel",dr,P.EncoderOnly],["DacDecoderModel",ci,P.EncoderOnly],["MimiEncoderModel",In,P.EncoderOnly],["MimiDecoderModel",ys,P.EncoderOnly],["SnacEncoderModel",Ls,P.EncoderOnly],["SnacDecoderModel",Oo,P.EncoderOnly],["Gemma3nForConditionalGeneration",wa,P.ImageAudioTextToText]];for(const[A,O,Z]of fm)S.set(A,Z),C.set(O,A),k.set(A,O);const ep=new Map([["modnet",Fs],["birefnet",Fs],["isnet",Fs],["ben",Fs]]);for(const[A,O]of ep.entries())O.set(A,["PreTrainedModel",J]),S.set(A,P.EncoderOnly),C.set(J,A),k.set(A,J);class hm extends fn{static MODEL_CLASS_MAPPINGS=oc.map(O=>O[0]);static BASE_IF_FAIL=!0}class pm extends fn{static MODEL_CLASS_MAPPINGS=[fi]}class mm extends fn{static MODEL_CLASS_MAPPINGS=[$o]}class _m extends fn{static MODEL_CLASS_MAPPINGS=[Qi]}class Gd extends fn{static MODEL_CLASS_MAPPINGS=[Al]}class gm extends fn{static MODEL_CLASS_MAPPINGS=[di]}class ym extends fn{static MODEL_CLASS_MAPPINGS=[Qr]}class Wn extends fn{static MODEL_CLASS_MAPPINGS=[sc]}class tp extends fn{static MODEL_CLASS_MAPPINGS=[Wh]}class G_ extends fn{static MODEL_CLASS_MAPPINGS=[kl]}class vm extends fn{static MODEL_CLASS_MAPPINGS=[ac]}class W_ extends fn{static MODEL_CLASS_MAPPINGS=[Kh]}class H_ extends fn{static MODEL_CLASS_MAPPINGS=[Fs]}class K_ extends fn{static MODEL_CLASS_MAPPINGS=[ic]}class Wd extends fn{static MODEL_CLASS_MAPPINGS=[Nd]}class Ol extends fn{static MODEL_CLASS_MAPPINGS=[qh]}class np extends fn{static MODEL_CLASS_MAPPINGS=[um]}class Hd extends fn{static MODEL_CLASS_MAPPINGS=[Do]}class rp extends fn{static MODEL_CLASS_MAPPINGS=[Qh]}class Lo extends fn{static MODEL_CLASS_MAPPINGS=[Xh]}class Ia extends fn{static MODEL_CLASS_MAPPINGS=[Yh]}class lc extends fn{static MODEL_CLASS_MAPPINGS=[Ud]}class q_ extends fn{static MODEL_CLASS_MAPPINGS=[zs]}class bm extends fn{static MODEL_CLASS_MAPPINGS=[Vd]}class wm extends fn{static MODEL_CLASS_MAPPINGS=[cm]}class Mm extends fn{static MODEL_CLASS_MAPPINGS=[dm]}class xm extends fn{static MODEL_CLASS_MAPPINGS=[Zh]}class Q_ extends fn{static MODEL_CLASS_MAPPINGS=[Jh]}class sp extends fn{static MODEL_CLASS_MAPPINGS=[Io]}class Tm extends fn{static MODEL_CLASS_MAPPINGS=[bs]}class Em extends fn{static MODEL_CLASS_MAPPINGS=[Hh]}class X_ extends be{constructor({logits:O,past_key_values:Z,encoder_outputs:ge,decoder_attentions:Se=null,cross_attentions:Oe=null}){super(),this.logits=O,this.past_key_values=Z,this.encoder_outputs=ge,this.decoder_attentions=Se,this.cross_attentions=Oe}}class Nt extends be{constructor({logits:O,...Z}){super(),this.logits=O;const ge=Object.values(Z);ge.length>0&&(this.attentions=ge)}}class Kd extends be{constructor({logits:O,embeddings:Z}){super(),this.logits=O,this.embeddings=Z}}class Fr extends be{constructor({logits:O}){super(),this.logits=O}}class Ur extends be{constructor({logits:O}){super(),this.logits=O}}class Pr extends be{constructor({start_logits:O,end_logits:Z}){super(),this.start_logits=O,this.end_logits=Z}}class zo extends be{constructor({logits:O}){super(),this.logits=O}}class Sm extends be{constructor({logits:O,past_key_values:Z}){super(),this.logits=O,this.past_key_values=Z}}class un extends be{constructor({alphas:O}){super(),this.alphas=O}}class qd extends be{constructor({waveform:O,spectrogram:Z}){super(),this.waveform=O,this.spectrogram=Z}}}),"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js":((e,n,t)=>{t.r(n),t.d(n,{ASTFeatureExtractor:()=>l});var a=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var i=t("./src/utils/audio.js");class l extends a.FeatureExtractor{constructor(d){super(d);const f=this.config.sampling_rate,h=(0,i.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(f/2),f,null,"kaldi",!0);this.mel_filters=h,this.window=(0,i.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(d,f){return(0,i.spectrogram)(d,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:f,transpose:!0})}async _call(d){(0,a.validate_audio_inputs)(d,"ASTFeatureExtractor");const f=await this._extract_fbank_features(d,this.config.max_length);if(this.config.do_normalize){const h=this.std*2,_=f.data;for(let m=0;m<_.length;++m)_[m]=(_[m]-this.mean)/h}return{input_values:f.unsqueeze_(0)}}}}),"./src/models/auto/feature_extraction_auto.js":((e,n,t)=>{t.r(n),t.d(n,{AutoFeatureExtractor:()=>u});var a=t("./src/utils/constants.js"),i=t("./src/utils/hub.js");t("./src/base/feature_extraction_utils.js");var l=t("./src/models/feature_extractors.js");class u{static async from_pretrained(f,h={}){const _=await(0,i.getModelJSON)(f,a.FEATURE_EXTRACTOR_NAME,!0,h),m=_.feature_extractor_type,p=l[m];if(!p)throw new Error(`Unknown feature_extractor_type: '${m}'. Please report this at ${a.GITHUB_ISSUE_URL}.`);return new p(_)}}}),"./src/models/auto/image_processing_auto.js":((e,n,t)=>{t.r(n),t.d(n,{AutoImageProcessor:()=>d});var a=t("./src/utils/constants.js"),i=t("./src/utils/hub.js"),l=t("./src/base/image_processors_utils.js"),u=t("./src/models/image_processors.js");class d{static async from_pretrained(h,_={}){const m=await(0,i.getModelJSON)(h,a.IMAGE_PROCESSOR_NAME,!0,_),p=m.image_processor_type??m.feature_extractor_type;let y=u[p?.replace(/Fast$/,"")];return y||(p!==void 0&&console.warn(`Image processor type '${p}' not found, assuming base ImageProcessor. Please report this at ${a.GITHUB_ISSUE_URL}.`),y=l.ImageProcessor),new y(m)}}}),"./src/models/auto/processing_auto.js":((e,n,t)=>{t.r(n),t.d(n,{AutoProcessor:()=>h});var a=t("./src/utils/constants.js"),i=t("./src/utils/hub.js"),l=t("./src/base/processing_utils.js"),u=t("./src/models/processors.js"),d=t("./src/models/image_processors.js"),f=t("./src/models/feature_extractors.js");class h{static async from_pretrained(m,p={}){const y=await(0,i.getModelJSON)(m,a.IMAGE_PROCESSOR_NAME,!0,p),{image_processor_type:v,feature_extractor_type:x,processor_class:L}=y;if(L&&u[L])return u[L].from_pretrained(m,p);if(!v&&!x)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const T={};if(v){const I=d[v.replace(/Fast$/,"")];if(!I)throw new Error(`Unknown image_processor_type: '${v}'.`);T.image_processor=new I(y)}if(x){const I=d[x];if(I)T.image_processor=new I(y);else{const P=f[x];if(!P)throw new Error(`Unknown feature_extractor_type: '${x}'.`);T.feature_extractor=new P(y)}}const E={};return new l.Processor(E,T,null)}}}),"./src/models/beit/image_processing_beit.js":((e,n,t)=>{t.r(n),t.d(n,{BeitFeatureExtractor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}}),"./src/models/bit/image_processing_bit.js":((e,n,t)=>{t.r(n),t.d(n,{BitImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}}),"./src/models/chinese_clip/image_processing_chinese_clip.js":((e,n,t)=>{t.r(n),t.d(n,{ChineseCLIPFeatureExtractor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}}),"./src/models/clap/feature_extraction_clap.js":((e,n,t)=>{t.r(n),t.d(n,{ClapFeatureExtractor:()=>l});var a=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var i=t("./src/utils/audio.js");class l extends a.FeatureExtractor{constructor(d){super(d),this.mel_filters=(0,i.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,i.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,i.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(d,f,h,_){let m;const p=d.length-f;if(p>0)if(h==="rand_trunc"){const y=Math.floor(Math.random()*(p+1));d=d.subarray(y,y+f),m=await this._extract_fbank_features(d,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${h}" not implemented`);else{if(p<0){let y=new Float64Array(f);if(y.set(d),_==="repeat")for(let v=d.length;v<f;v+=d.length)y.set(d.subarray(0,Math.min(d.length,f-v)),v);else if(_==="repeatpad")for(let v=d.length;v<-p;v+=d.length)y.set(d,v);d=y}if(h==="fusion")throw new Error(`Truncation strategy "${h}" not implemented`);m=await this._extract_fbank_features(d,this.mel_filters_slaney,this.config.nb_max_samples)}return m.unsqueeze_(0)}async _extract_fbank_features(d,f,h=null){return(0,i.spectrogram)(d,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:f,log_mel:"dB",max_num_frames:h,do_pad:!1,transpose:!0})}async _call(d,{max_length:f=null}={}){return(0,a.validate_audio_inputs)(d,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(d,f??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}}),"./src/models/clip/image_processing_clip.js":((e,n,t)=>{t.r(n),t.d(n,{CLIPFeatureExtractor:()=>l,CLIPImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}class l extends i{}}),"./src/models/convnext/image_processing_convnext.js":((e,n,t)=>{t.r(n),t.d(n,{ConvNextFeatureExtractor:()=>l,ConvNextImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{constructor(d){super(d),this.crop_pct=this.config.crop_pct??224/256}async resize(d){const f=this.size?.shortest_edge;if(f===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(f<384){const h=Math.floor(f/this.crop_pct),[_,m]=this.get_resize_output_image_size(d,{shortest_edge:h});d=await d.resize(_,m,{resample:this.resample}),d=await d.center_crop(f,f)}else d=await d.resize(f,f,{resample:this.resample});return d}}class l extends i{}}),"./src/models/dac/feature_extraction_dac.js":((e,n,t)=>{t.r(n),t.d(n,{DacFeatureExtractor:()=>i});var a=t("./src/models/encodec/feature_extraction_encodec.js");class i extends a.EncodecFeatureExtractor{}}),"./src/models/deit/image_processing_deit.js":((e,n,t)=>{t.r(n),t.d(n,{DeiTFeatureExtractor:()=>l,DeiTImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}class l extends i{}}),"./src/models/detr/image_processing_detr.js":((e,n,t)=>{t.r(n),t.d(n,{DetrFeatureExtractor:()=>u,DetrImageProcessor:()=>l});var a=t("./src/base/image_processors_utils.js"),i=t("./src/utils/tensor.js");class l extends a.ImageProcessor{async _call(f){const h=await super._call(f),_=[h.pixel_values.dims[0],64,64],m=(0,i.full)(_,1n);return{...h,pixel_mask:m}}post_process_object_detection(...f){return(0,a.post_process_object_detection)(...f)}post_process_panoptic_segmentation(...f){return(0,a.post_process_panoptic_segmentation)(...f)}post_process_instance_segmentation(...f){return(0,a.post_process_instance_segmentation)(...f)}}class u extends l{}}),"./src/models/dinov3_vit/image_processing_dinov3_vit.js":((e,n,t)=>{t.r(n),t.d(n,{DINOv3ViTImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}}),"./src/models/donut/image_processing_donut.js":((e,n,t)=>{t.r(n),t.d(n,{DonutFeatureExtractor:()=>l,DonutImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{pad_image(d,f,h,_={}){const[m,p,y]=f;let v=this.image_mean;Array.isArray(this.image_mean)||(v=new Array(y).fill(v));let x=this.image_std;Array.isArray(x)||(x=new Array(y).fill(v));const L=v.map((T,E)=>-T/x[E]);return super.pad_image(d,f,h,{center:!0,constant_values:L,..._})}}class l extends i{}}),"./src/models/dpt/image_processing_dpt.js":((e,n,t)=>{t.r(n),t.d(n,{DPTFeatureExtractor:()=>l,DPTImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}class l extends i{}}),"./src/models/efficientnet/image_processing_efficientnet.js":((e,n,t)=>{t.r(n),t.d(n,{EfficientNetImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{constructor(u){super(u),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(d=>d*d))}}}),"./src/models/encodec/feature_extraction_encodec.js":((e,n,t)=>{t.r(n),t.d(n,{EncodecFeatureExtractor:()=>l});var a=t("./src/base/feature_extraction_utils.js"),i=t("./src/utils/tensor.js");class l extends a.FeatureExtractor{async _call(d){(0,a.validate_audio_inputs)(d,"EncodecFeatureExtractor"),d instanceof Float64Array&&(d=new Float32Array(d));const f=this.config.feature_size;if(d.length%f!==0)throw new Error(`The length of the audio data must be a multiple of the number of channels (${f}).`);const h=[1,f,d.length/f];return{input_values:new i.Tensor("float32",d,h)}}}}),"./src/models/feature_extractors.js":((e,n,t)=>{t.r(n),t.d(n,{ASTFeatureExtractor:()=>a.ASTFeatureExtractor,ClapFeatureExtractor:()=>l.ClapFeatureExtractor,DacFeatureExtractor:()=>u.DacFeatureExtractor,EncodecFeatureExtractor:()=>i.EncodecFeatureExtractor,Gemma3nAudioFeatureExtractor:()=>d.Gemma3nAudioFeatureExtractor,ImageFeatureExtractor:()=>L.ImageProcessor,MoonshineFeatureExtractor:()=>f.MoonshineFeatureExtractor,PyAnnoteFeatureExtractor:()=>h.PyAnnoteFeatureExtractor,SeamlessM4TFeatureExtractor:()=>_.SeamlessM4TFeatureExtractor,SnacFeatureExtractor:()=>m.SnacFeatureExtractor,SpeechT5FeatureExtractor:()=>p.SpeechT5FeatureExtractor,Wav2Vec2FeatureExtractor:()=>y.Wav2Vec2FeatureExtractor,WeSpeakerFeatureExtractor:()=>v.WeSpeakerFeatureExtractor,WhisperFeatureExtractor:()=>x.WhisperFeatureExtractor});var a=t("./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js"),i=t("./src/models/encodec/feature_extraction_encodec.js"),l=t("./src/models/clap/feature_extraction_clap.js"),u=t("./src/models/dac/feature_extraction_dac.js"),d=t("./src/models/gemma3n/feature_extraction_gemma3n.js"),f=t("./src/models/moonshine/feature_extraction_moonshine.js"),h=t("./src/models/pyannote/feature_extraction_pyannote.js"),_=t("./src/models/seamless_m4t/feature_extraction_seamless_m4t.js"),m=t("./src/models/snac/feature_extraction_snac.js"),p=t("./src/models/speecht5/feature_extraction_speecht5.js"),y=t("./src/models/wav2vec2/feature_extraction_wav2vec2.js"),v=t("./src/models/wespeaker/feature_extraction_wespeaker.js"),x=t("./src/models/whisper/feature_extraction_whisper.js"),L=t("./src/base/image_processors_utils.js")}),"./src/models/florence2/processing_florence2.js":((e,n,t)=>{t.r(n),t.d(n,{Florence2Processor:()=>u});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js"),l=t("./src/tokenizers.js");class u extends a.Processor{static tokenizer_class=l.AutoTokenizer;static image_processor_class=i.AutoImageProcessor;constructor(f,h,_){super(f,h,_);const{tasks_answer_post_processing_type:m,task_prompts_without_inputs:p,task_prompts_with_input:y}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(m??{})),this.task_prompts_without_inputs=new Map(Object.entries(p??{})),this.task_prompts_with_input=new Map(Object.entries(y??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(f){typeof f=="string"&&(f=[f]);const h=[];for(const _ of f)if(this.task_prompts_without_inputs.has(_))h.push(this.task_prompts_without_inputs.get(_));else{for(const[m,p]of this.task_prompts_with_input)if(_.includes(m)){h.push(p.replaceAll("{input}",_).replaceAll(m,""));break}h.length!==f.length&&h.push(_)}return h}post_process_generation(f,h,_){const m=this.tasks_answer_post_processing_type.get(h)??"pure_text";f=f.replaceAll("<s>","").replaceAll("</s>","");let p;switch(m){case"pure_text":p=f;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const y=m==="ocr"?"quad_boxes":"bboxes",v=f.matchAll(this.regexes[y]),x=[],L=[];for(const[T,E,...I]of v)x.push(E?E.trim():x.at(-1)??""),L.push(I.map((P,S)=>(Number(P)+.5)/this.size_per_bin*_[S%2]));p={labels:x,[y]:L};break;default:throw new Error(`Task "${h}" (of type "${m}") not yet implemented.`)}return{[h]:p}}async _call(f,h=null,_={}){if(!f&&!h)throw new Error("Either text or images must be provided");const m=await this.image_processor(f,_),p=h?this.tokenizer(this.construct_prompts(h),_):{};return{...m,...p}}}}),"./src/models/gemma3n/feature_extraction_gemma3n.js":((e,n,t)=>{t.r(n),t.d(n,{Gemma3nAudioFeatureExtractor:()=>u});var a=t("./src/base/feature_extraction_utils.js"),i=t("./src/utils/tensor.js"),l=t("./src/utils/audio.js");class u extends a.FeatureExtractor{constructor(f){super(f);const{fft_length:h,feature_size:_,min_frequency:m,max_frequency:p,sampling_rate:y,frame_length:v}=this.config,x=(0,l.mel_filter_bank)(Math.floor(1+h/2),_,m,p,y,null,"htk",!1);this.mel_filters=x,this.window=(0,l.window_function)(v,"hann")}async _extract_fbank_features(f,h){return(0,l.spectrogram)(f,this.window,this.config.frame_length,this.config.hop_length,{fft_length:this.config.fft_length,center:!1,onesided:!0,preemphasis:this.config.preemphasis,preemphasis_htk_flavor:this.config.preemphasis_htk_flavor,mel_filters:this.mel_filters,log_mel:"log",mel_floor:this.config.mel_floor,remove_dc_offset:!1,transpose:!0})}async _call(f,{max_length:h=48e4,truncation:_=!0,padding:m=!0,pad_to_multiple_of:p=128}={}){if((0,a.validate_audio_inputs)(f,"Gemma3nAudioFeatureExtractor"),_&&f.length>h&&(f=f.slice(0,h)),m&&f.length%p!==0){const x=p-f.length%p,L=new Float64Array(f.length+x);L.set(f),this.config.padding_value!==0&&L.fill(this.config.padding_value,f.length),f=L}const y=await this._extract_fbank_features(f,this.config.max_length),v=(0,i.full)([1,y.dims[0]],!0);return{input_features:y.unsqueeze_(0),input_features_mask:v}}}}),"./src/models/gemma3n/processing_gemma3n.js":((e,n,t)=>{t.r(n),t.d(n,{Gemma3nProcessor:()=>d});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js"),l=t("./src/models/auto/feature_extraction_auto.js"),u=t("./src/tokenizers.js");t("./src/utils/image.js"),t("./src/utils/audio.js");class d extends a.Processor{static image_processor_class=i.AutoImageProcessor;static feature_extractor_class=l.AutoFeatureExtractor;static tokenizer_class=u.AutoTokenizer;static uses_processor_config=!0;static uses_chat_template_file=!0;constructor(h,_,m){super(h,_,m),this.audio_seq_length=this.config.audio_seq_length,this.image_seq_length=this.config.image_seq_length;const{audio_token_id:p,boa_token:y,audio_token:v,eoa_token:x,image_token_id:L,boi_token:T,image_token:E,eoi_token:I}=this.tokenizer.config;this.audio_token_id=p,this.boa_token=y,this.audio_token=v;const P=v.repeat(this.audio_seq_length);this.full_audio_sequence=`

${y}${P}${x}

`,this.image_token_id=L,this.boi_token=T,this.image_token=E;const S=E.repeat(this.image_seq_length);this.full_image_sequence=`

${T}${S}${I}

`}async _call(h,_=null,m=null,p={}){typeof h=="string"&&(h=[h]);let y;m&&(y=await this.feature_extractor(m,p),h=h.map(L=>L.replaceAll(this.audio_token,this.full_audio_sequence)));let v;return _&&(v=await this.image_processor(_,p),h=h.map(L=>L.replaceAll(this.image_token,this.full_image_sequence))),{...this.tokenizer(h,p),...v,...y}}}}),"./src/models/glpn/image_processing_glpn.js":((e,n,t)=>{t.r(n),t.d(n,{GLPNFeatureExtractor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}}),"./src/models/grounding_dino/image_processing_grounding_dino.js":((e,n,t)=>{t.r(n),t.d(n,{GroundingDinoImageProcessor:()=>l});var a=t("./src/base/image_processors_utils.js"),i=t("./src/utils/tensor.js");class l extends a.ImageProcessor{async _call(d){const f=await super._call(d),h=f.pixel_values.dims,_=(0,i.ones)([h[0],h[2],h[3]]);return{...f,pixel_mask:_}}}}),"./src/models/grounding_dino/processing_grounding_dino.js":((e,n,t)=>{t.r(n),t.d(n,{GroundingDinoProcessor:()=>f});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js"),l=t("./src/tokenizers.js"),u=t("./src/base/image_processors_utils.js");function d(h,_){const p=h.dims.at(-1)-1,y=h.tolist();y.fill(!1,0,1),y.fill(!1,p);const v=_.tolist();return y.map((x,L)=>x?L:null).filter(x=>x!==null).map(x=>v[x])}class f extends a.Processor{static tokenizer_class=l.AutoTokenizer;static image_processor_class=i.AutoImageProcessor;async _call(_,m,p={}){const y=_?await this.image_processor(_,p):{};return{...m?this.tokenizer(m,p):{},...y}}post_process_grounded_object_detection(_,m,{box_threshold:p=.25,text_threshold:y=.25,target_sizes:v=null}={}){const{logits:x,pred_boxes:L}=_,T=x.dims[0];if(v!==null&&v.length!==T)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const E=x.dims.at(1),I=x.sigmoid(),P=I.max(-1).tolist(),S=L.tolist().map(C=>C.map(D=>(0,u.center_to_corners_format)(D))),k=[];for(let C=0;C<T;++C){const D=v!==null?v[C]:null;D!==null&&(S[C]=S[C].map(H=>H.map((oe,ae)=>oe*D[(ae+1)%2])));const V=P[C],U=[],ne=[],ee=[];for(let H=0;H<E;++H){const oe=V[H];if(oe<=p)continue;const ae=S[C][H],W=I[C][H];U.push(oe),ee.push(ae);const te=d(W.gt(y),m[C]);ne.push(te)}k.push({scores:U,boxes:ee,labels:this.batch_decode(ne)})}return k}}}),"./src/models/idefics3/image_processing_idefics3.js":((e,n,t)=>{t.r(n),t.d(n,{Idefics3ImageProcessor:()=>l});var a=t("./src/base/image_processors_utils.js"),i=t("./src/utils/tensor.js");class l extends a.ImageProcessor{constructor(d){super(d),this.do_image_splitting=d.do_image_splitting??!0,this.max_image_size=d.max_image_size}get_resize_for_vision_encoder(d,f){let[h,_]=d.dims.slice(-2);const m=_/h;return _>=h?(_=Math.ceil(_/f)*f,h=Math.floor(_/m),h=Math.ceil(h/f)*f):(h=Math.ceil(h/f)*f,_=Math.floor(h*m),_=Math.ceil(_/f)*f),{height:h,width:_}}async _call(d,{do_image_splitting:f=null,return_row_col_info:h=!1}={}){let _;if(!Array.isArray(d))_=[[d]];else{if(d.length===0||!d[0])throw new Error("No images provided.");Array.isArray(d[0])?_=d:_=[d]}let m=[],p=[],y=[];const v=[],x=[];for(const C of _){let D=await Promise.all(C.map(ne=>this.preprocess(ne)));v.push(...D.map(ne=>ne.original_size)),x.push(...D.map(ne=>ne.reshaped_input_size)),D.forEach(ne=>ne.pixel_values.unsqueeze_(0));const{longest_edge:V}=this.max_image_size;let U;if(f??this.do_image_splitting){let ne=new Array(D.length),ee=new Array(D.length);U=await Promise.all(D.map(async(H,oe)=>{const ae=this.get_resize_for_vision_encoder(H.pixel_values,V),W=await(0,i.interpolate_4d)(H.pixel_values,{size:[ae.height,ae.width]}),{frames:te,num_splits_h:ie,num_splits_w:_e}=await this.split_image(W,this.max_image_size);return ne[oe]=ie,ee[oe]=_e,(0,i.cat)(te,0)})),p.push(ne),y.push(ee)}else{const ne=[V,V];U=await Promise.all(D.map(ee=>(0,i.interpolate_4d)(ee.pixel_values,{size:ne}))),p.push(new Array(D.length).fill(0)),y.push(new Array(D.length).fill(0))}m.push((0,i.cat)(U,0))}const L=m.length,[T,E,I,P]=m[0].dims;let S,k;if(L===1)S=m[0].unsqueeze_(0),k=(0,i.full)([L,T,I,P],!0);else{const C=Math.max(...m.map(U=>U.dims.at(0)));k=(0,i.full)([L,C,I,P],!0);const D=k.data,V=C*I*P;for(let U=0;U<L;++U){const ne=m[U].dims[0];if(ne<C){m[U]=(0,i.cat)([m[U],(0,i.full)([C-ne,E,I,P],0)],0);const ee=U*V+ne*I*P,H=(U+1)*V;D.fill(!1,ee,H)}}S=(0,i.stack)(m,0)}return{pixel_values:S,pixel_attention_mask:k,original_sizes:v,reshaped_input_sizes:x,...h?{rows:p,cols:y}:{}}}async split_image(d,{longest_edge:f}){const h=f,_=f,m=[],[p,y]=d.dims.slice(-2);let v=0,x=0;if(p>h||y>_){v=Math.ceil(p/h),x=Math.ceil(y/_);const L=Math.ceil(p/v),T=Math.ceil(y/x);for(let P=0;P<v;++P)for(let S=0;S<x;++S){let k,C,D,V;P===v-1?(C=p-L,V=p):(C=P*L,V=(P+1)*L),S===x-1?(k=y-T,D=y):(k=S*T,D=(S+1)*T);const U=[C,k],ne=[V,D],ee=await(0,i.slice)(d,U,ne,[2,3]);m.push(ee)}const E=h,I=_;(p!==E||y!==I)&&(d=await(0,i.interpolate_4d)(d,{size:[E,I]}))}return m.push(d),{frames:m,num_splits_h:v,num_splits_w:x}}}}),"./src/models/idefics3/processing_idefics3.js":((e,n,t)=>{t.r(n),t.d(n,{Idefics3Processor:()=>_});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js"),l=t("./src/tokenizers.js");t("./src/utils/image.js");var u=t("./src/utils/core.js");function d(m,p,y,v,x,L){let T="";for(let E=0;E<p;++E){for(let I=0;I<y;++I)T+=v+`<row_${E+1}_col_${I+1}>`+x.repeat(m);T+=`
`}return T+=`
${v}${L}`+x.repeat(m)+`${v}`,T}function f(m,p,y,v){return`${p}${v}`+y.repeat(m)+`${p}`}function h(m,p,y,v,x,L){return m===0&&p===0?f(y,v,x,L):d(y,m,p,v,x,L)}class _ extends a.Processor{static image_processor_class=i.AutoImageProcessor;static tokenizer_class=l.AutoTokenizer;static uses_processor_config=!0;fake_image_token="<fake_token_around_image>";image_token="<image>";global_img_token="<global-img>";async _call(p,y=null,v={}){v.return_row_col_info??=!0;let x;y&&(x=await this.image_processor(y,v)),Array.isArray(p)||(p=[p]);const L=x.rows??[new Array(p.length).fill(0)],T=x.cols??[new Array(p.length).fill(0)],E=this.config.image_seq_len,I=[],P=[];for(let k=0;k<p.length;++k){const C=p[k],D=L[k],V=T[k];I.push((0,u.count)(C,this.image_token));const U=D.map((H,oe)=>h(H,V[oe],E,this.fake_image_token,this.image_token,this.global_img_token)),ne=C.split(this.image_token);if(ne.length===0)throw new Error("The image token should be present in the text.");let ee=ne[0];for(let H=0;H<U.length;++H)ee+=U[H]+ne[H+1];P.push(ee)}return{...this.tokenizer(P),...x}}}}),"./src/models/image_processors.js":((e,n,t)=>{t.r(n),t.d(n,{BeitFeatureExtractor:()=>a.BeitFeatureExtractor,BitImageProcessor:()=>i.BitImageProcessor,CLIPFeatureExtractor:()=>u.CLIPFeatureExtractor,CLIPImageProcessor:()=>u.CLIPImageProcessor,ChineseCLIPFeatureExtractor:()=>l.ChineseCLIPFeatureExtractor,ConvNextFeatureExtractor:()=>d.ConvNextFeatureExtractor,ConvNextImageProcessor:()=>d.ConvNextImageProcessor,DINOv3ViTImageProcessor:()=>_.DINOv3ViTImageProcessor,DPTFeatureExtractor:()=>p.DPTFeatureExtractor,DPTImageProcessor:()=>p.DPTImageProcessor,DeiTFeatureExtractor:()=>f.DeiTFeatureExtractor,DeiTImageProcessor:()=>f.DeiTImageProcessor,DetrFeatureExtractor:()=>h.DetrFeatureExtractor,DetrImageProcessor:()=>h.DetrImageProcessor,DonutFeatureExtractor:()=>m.DonutFeatureExtractor,DonutImageProcessor:()=>m.DonutImageProcessor,EfficientNetImageProcessor:()=>y.EfficientNetImageProcessor,GLPNFeatureExtractor:()=>v.GLPNFeatureExtractor,GroundingDinoImageProcessor:()=>x.GroundingDinoImageProcessor,Idefics3ImageProcessor:()=>L.Idefics3ImageProcessor,JinaCLIPImageProcessor:()=>E.JinaCLIPImageProcessor,LlavaOnevisionImageProcessor:()=>I.LlavaOnevisionImageProcessor,Mask2FormerImageProcessor:()=>P.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>S.MaskFormerFeatureExtractor,MaskFormerImageProcessor:()=>S.MaskFormerImageProcessor,MobileNetV1FeatureExtractor:()=>k.MobileNetV1FeatureExtractor,MobileNetV1ImageProcessor:()=>k.MobileNetV1ImageProcessor,MobileNetV2FeatureExtractor:()=>C.MobileNetV2FeatureExtractor,MobileNetV2ImageProcessor:()=>C.MobileNetV2ImageProcessor,MobileNetV3FeatureExtractor:()=>D.MobileNetV3FeatureExtractor,MobileNetV3ImageProcessor:()=>D.MobileNetV3ImageProcessor,MobileNetV4FeatureExtractor:()=>V.MobileNetV4FeatureExtractor,MobileNetV4ImageProcessor:()=>V.MobileNetV4ImageProcessor,MobileViTFeatureExtractor:()=>U.MobileViTFeatureExtractor,MobileViTImageProcessor:()=>U.MobileViTImageProcessor,NougatImageProcessor:()=>ne.NougatImageProcessor,OwlViTFeatureExtractor:()=>H.OwlViTFeatureExtractor,OwlViTImageProcessor:()=>H.OwlViTImageProcessor,Owlv2ImageProcessor:()=>ee.Owlv2ImageProcessor,Phi3VImageProcessor:()=>oe.Phi3VImageProcessor,PvtImageProcessor:()=>ae.PvtImageProcessor,Qwen2VLImageProcessor:()=>W.Qwen2VLImageProcessor,RTDetrImageProcessor:()=>te.RTDetrImageProcessor,SamImageProcessor:()=>ie.SamImageProcessor,SegformerFeatureExtractor:()=>_e.SegformerFeatureExtractor,SegformerImageProcessor:()=>_e.SegformerImageProcessor,SiglipImageProcessor:()=>q.SiglipImageProcessor,SmolVLMImageProcessor:()=>B.SmolVLMImageProcessor,Swin2SRImageProcessor:()=>R.Swin2SRImageProcessor,VLMImageProcessor:()=>T.VLMImageProcessor,ViTFeatureExtractor:()=>Q.ViTFeatureExtractor,ViTImageProcessor:()=>Q.ViTImageProcessor,VitMatteImageProcessor:()=>G.VitMatteImageProcessor,VitPoseImageProcessor:()=>fe.VitPoseImageProcessor,YolosFeatureExtractor:()=>Te.YolosFeatureExtractor,YolosImageProcessor:()=>Te.YolosImageProcessor});var a=t("./src/models/beit/image_processing_beit.js"),i=t("./src/models/bit/image_processing_bit.js"),l=t("./src/models/chinese_clip/image_processing_chinese_clip.js"),u=t("./src/models/clip/image_processing_clip.js"),d=t("./src/models/convnext/image_processing_convnext.js"),f=t("./src/models/deit/image_processing_deit.js"),h=t("./src/models/detr/image_processing_detr.js"),_=t("./src/models/dinov3_vit/image_processing_dinov3_vit.js"),m=t("./src/models/donut/image_processing_donut.js"),p=t("./src/models/dpt/image_processing_dpt.js"),y=t("./src/models/efficientnet/image_processing_efficientnet.js"),v=t("./src/models/glpn/image_processing_glpn.js"),x=t("./src/models/grounding_dino/image_processing_grounding_dino.js"),L=t("./src/models/idefics3/image_processing_idefics3.js"),T=t("./src/models/janus/image_processing_janus.js"),E=t("./src/models/jina_clip/image_processing_jina_clip.js"),I=t("./src/models/llava_onevision/image_processing_llava_onevision.js"),P=t("./src/models/mask2former/image_processing_mask2former.js"),S=t("./src/models/maskformer/image_processing_maskformer.js"),k=t("./src/models/mobilenet_v1/image_processing_mobilenet_v1.js"),C=t("./src/models/mobilenet_v2/image_processing_mobilenet_v2.js"),D=t("./src/models/mobilenet_v3/image_processing_mobilenet_v3.js"),V=t("./src/models/mobilenet_v4/image_processing_mobilenet_v4.js"),U=t("./src/models/mobilevit/image_processing_mobilevit.js"),ne=t("./src/models/nougat/image_processing_nougat.js"),ee=t("./src/models/owlv2/image_processing_owlv2.js"),H=t("./src/models/owlvit/image_processing_owlvit.js"),oe=t("./src/models/phi3_v/image_processing_phi3_v.js"),ae=t("./src/models/pvt/image_processing_pvt.js"),W=t("./src/models/qwen2_vl/image_processing_qwen2_vl.js"),te=t("./src/models/rt_detr/image_processing_rt_detr.js"),ie=t("./src/models/sam/image_processing_sam.js"),_e=t("./src/models/segformer/image_processing_segformer.js"),q=t("./src/models/siglip/image_processing_siglip.js"),B=t("./src/models/smolvlm/image_processing_smolvlm.js"),R=t("./src/models/swin2sr/image_processing_swin2sr.js"),Q=t("./src/models/vit/image_processing_vit.js"),G=t("./src/models/vitmatte/image_processing_vitmatte.js"),fe=t("./src/models/vitpose/image_processing_vitpose.js"),Te=t("./src/models/yolos/image_processing_yolos.js")}),"./src/models/janus/image_processing_janus.js":((e,n,t)=>{t.r(n),t.d(n,{VLMImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{constructor(u){super({do_pad:!0,pad_size:{width:u.image_size,height:u.image_size},...u}),this.constant_values=this.config.background_color.map(d=>d*this.rescale_factor)}pad_image(u,d,f,h){return super.pad_image(u,d,f,{constant_values:this.constant_values,center:!0,...h})}}}),"./src/models/janus/processing_janus.js":((e,n,t)=>{t.r(n),t.d(n,{VLChatProcessor:()=>h});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js"),l=t("./src/tokenizers.js"),u=t("./src/utils/core.js"),d=t("./src/utils/tensor.js"),f=t("./src/utils/image.js");class h extends a.Processor{static image_processor_class=i.AutoImageProcessor;static tokenizer_class=l.AutoTokenizer;static uses_processor_config=!0;constructor(m,p,y){super(m,p,y),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(m,{images:p=null,chat_template:y="default"}={}){p?Array.isArray(p)||(p=[p]):p=await Promise.all(m.filter(U=>U.images).flatMap(U=>U.images).map(U=>f.RawImage.read(U)));const v=this.tokenizer,x=v.apply_chat_template(m,{tokenize:!1,add_generation_prompt:!0,chat_template:y}),L=U=>v.encode(U,{add_special_tokens:!1}),T=x.split(this.image_tag),E=T.length-1;if(p.length!==E)throw new Error(`Number of images provided (${p.length}) does not match number of "${this.image_tag}" image tags (${E})`);const[I,P,S]=v.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let k=L(T[0]),C=new Array(k.length).fill(!1);for(let U=1;U<T.length;++U){const ne=new Array(this.num_image_tokens).fill(I),ee=L(T[U]);k=(0,u.mergeArrays)(k,[P],ne,[S],ee);const H=new Array(this.num_image_tokens).fill(!0);C=(0,u.mergeArrays)(C,[!1],H,[!1],new Array(ee.length).fill(!1))}const D=[1,k.length],V={input_ids:new d.Tensor("int64",k,D),attention_mask:new d.Tensor("int64",new Array(k.length).fill(1),D),images_seq_mask:new d.Tensor("bool",C,D),images_emb_mask:new d.Tensor("bool",new Array(E*this.num_image_tokens).fill(!0),[1,E,this.num_image_tokens])};if(p&&p.length>0){const U=await this.image_processor(p);return U.pixel_values.unsqueeze_(0),{...V,...U}}return V}}}),"./src/models/jina_clip/image_processing_jina_clip.js":((e,n,t)=>{t.r(n),t.d(n,{JinaCLIPImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{constructor(u){const{resize_mode:d,fill_color:f,interpolation:h,size:_,...m}=u,p=d==="squash"?{width:_,height:_}:d==="shortest"?{shortest_edge:_}:{longest_edge:_},y=h==="bicubic"?3:2;super({...m,size:p,resample:y,do_center_crop:!0,crop_size:_,do_normalize:!0})}}}),"./src/models/jina_clip/processing_jina_clip.js":((e,n,t)=>{t.r(n),t.d(n,{JinaCLIPProcessor:()=>u});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js"),l=t("./src/tokenizers.js");class u extends a.Processor{static tokenizer_class=l.AutoTokenizer;static image_processor_class=i.AutoImageProcessor;async _call(f=null,h=null,_={}){if(!f&&!h)throw new Error("Either text or images must be provided");const m=f?this.tokenizer(f,_):{},p=h?await this.image_processor(h,_):{};return{...m,...p}}}}),"./src/models/llava/processing_llava.js":((e,n,t)=>{t.r(n),t.d(n,{LlavaProcessor:()=>u});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js"),l=t("./src/tokenizers.js");class u extends a.Processor{static tokenizer_class=l.AutoTokenizer;static image_processor_class=i.AutoImageProcessor;static uses_processor_config=!0;async _call(f,h=null,_={}){const m=await this.image_processor(f,_);if(h){const[y,v]=m.pixel_values.dims.slice(-2),{image_token:x,patch_size:L,num_additional_image_tokens:T}=this.config,E=Math.floor(y/L)*Math.floor(v/L)+T;h=structuredClone(h),Array.isArray(h)||(h=[h]);for(let I=0;I<h.length;++I)h[I]=h[I].replace(x,x.repeat(E))}const p=h?this.tokenizer(h,_):{};return{...m,...p}}}}),"./src/models/llava_onevision/image_processing_llava_onevision.js":((e,n,t)=>{t.r(n),t.d(n,{LlavaOnevisionImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}}),"./src/models/mask2former/image_processing_mask2former.js":((e,n,t)=>{t.r(n),t.d(n,{Mask2FormerImageProcessor:()=>i});var a=t("./src/models/maskformer/image_processing_maskformer.js");class i extends a.MaskFormerImageProcessor{}}),"./src/models/maskformer/image_processing_maskformer.js":((e,n,t)=>{t.r(n),t.d(n,{MaskFormerFeatureExtractor:()=>l,MaskFormerImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{post_process_panoptic_segmentation(...d){return(0,a.post_process_panoptic_segmentation)(...d)}post_process_instance_segmentation(...d){return(0,a.post_process_instance_segmentation)(...d)}}class l extends i{}}),"./src/models/mgp_str/processing_mgp_str.js":((e,n,t)=>{t.r(n),t.d(n,{MgpstrProcessor:()=>f});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js"),l=t("./src/tokenizers.js"),u=t("./src/utils/maths.js");const d={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class f extends a.Processor{static tokenizer_class=l.AutoTokenizer;static image_processor_class=i.AutoImageProcessor;get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(_,m){if(!d.hasOwnProperty(m))throw new Error(`Format ${m} is not supported.`);const[p,y]=d[m],v=this[p].bind(this),[x,L]=_.dims,T=[],E=[],I=_.tolist();for(let S=0;S<x;++S){const k=I[S],C=[],D=[];for(let U=1;U<L;++U){const[ne,ee]=(0,u.max)((0,u.softmax)(k[U]));if(D.push(ne),ee==y)break;C.push(ee)}const V=D.length>0?D.reduce((U,ne)=>U*ne,1):0;E.push(C),T.push(V)}return[v(E),T]}char_decode(_){return this.char_tokenizer.batch_decode(_).map(m=>m.replaceAll(" ",""))}bpe_decode(_){return this.bpe_tokenizer.batch_decode(_)}wp_decode(_){return this.wp_tokenizer.batch_decode(_).map(m=>m.replaceAll(" ",""))}batch_decode([_,m,p]){const[y,v]=this._decode_helper(_,"char"),[x,L]=this._decode_helper(m,"bpe"),[T,E]=this._decode_helper(p,"wp"),I=[],P=[];for(let S=0;S<y.length;++S){const[k,C]=(0,u.max)([v[S],L[S],E[S]]);I.push([y[S],x[S],T[S]][C]),P.push(k)}return{generated_text:I,scores:P,char_preds:y,bpe_preds:x,wp_preds:T}}static async from_pretrained(..._){const m=await super.from_pretrained(..._),p=await l.AutoTokenizer.from_pretrained("Xenova/gpt2"),y=await l.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");return m.components={image_processor:m.image_processor,char_tokenizer:m.tokenizer,bpe_tokenizer:p,wp_tokenizer:y},m}async _call(_,m=null){const p=await this.image_processor(_);return m&&(p.labels=this.tokenizer(m).input_ids),p}}}),"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js":((e,n,t)=>{t.r(n),t.d(n,{MobileNetV1FeatureExtractor:()=>l,MobileNetV1ImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}class l extends i{}}),"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js":((e,n,t)=>{t.r(n),t.d(n,{MobileNetV2FeatureExtractor:()=>l,MobileNetV2ImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}class l extends i{}}),"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js":((e,n,t)=>{t.r(n),t.d(n,{MobileNetV3FeatureExtractor:()=>l,MobileNetV3ImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}class l extends i{}}),"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js":((e,n,t)=>{t.r(n),t.d(n,{MobileNetV4FeatureExtractor:()=>l,MobileNetV4ImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}class l extends i{}}),"./src/models/mobilevit/image_processing_mobilevit.js":((e,n,t)=>{t.r(n),t.d(n,{MobileViTFeatureExtractor:()=>l,MobileViTImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}class l extends i{}}),"./src/models/moonshine/feature_extraction_moonshine.js":((e,n,t)=>{t.r(n),t.d(n,{MoonshineFeatureExtractor:()=>l});var a=t("./src/base/feature_extraction_utils.js"),i=t("./src/utils/tensor.js");class l extends a.FeatureExtractor{async _call(d){(0,a.validate_audio_inputs)(d,"MoonshineFeatureExtractor"),d instanceof Float64Array&&(d=new Float32Array(d));const f=[1,d.length];return{input_values:new i.Tensor("float32",d,f)}}}}),"./src/models/moonshine/processing_moonshine.js":((e,n,t)=>{t.r(n),t.d(n,{MoonshineProcessor:()=>u});var a=t("./src/models/auto/feature_extraction_auto.js"),i=t("./src/tokenizers.js"),l=t("./src/base/processing_utils.js");class u extends l.Processor{static tokenizer_class=i.AutoTokenizer;static feature_extractor_class=a.AutoFeatureExtractor;async _call(f){return await this.feature_extractor(f)}}}),"./src/models/nougat/image_processing_nougat.js":((e,n,t)=>{t.r(n),t.d(n,{NougatImageProcessor:()=>i});var a=t("./src/models/donut/image_processing_donut.js");class i extends a.DonutImageProcessor{}}),"./src/models/owlv2/image_processing_owlv2.js":((e,n,t)=>{t.r(n),t.d(n,{Owlv2ImageProcessor:()=>i});var a=t("./src/models/owlvit/image_processing_owlvit.js");class i extends a.OwlViTImageProcessor{}}),"./src/models/owlvit/image_processing_owlvit.js":((e,n,t)=>{t.r(n),t.d(n,{OwlViTFeatureExtractor:()=>l,OwlViTImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{post_process_object_detection(...d){return(0,a.post_process_object_detection)(...d)}}class l extends i{}}),"./src/models/owlvit/processing_owlvit.js":((e,n,t)=>{t.r(n),t.d(n,{OwlViTProcessor:()=>u});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js"),l=t("./src/tokenizers.js");class u extends a.Processor{static tokenizer_class=l.AutoTokenizer;static image_processor_class=i.AutoImageProcessor}}),"./src/models/paligemma/processing_paligemma.js":((e,n,t)=>{t.r(n),t.d(n,{PaliGemmaProcessor:()=>f});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js"),l=t("./src/tokenizers.js");const u="<image>";function d(h,_,m,p,y){return`${p.repeat(m*y)}${_}${h}
`}class f extends a.Processor{static tokenizer_class=l.AutoTokenizer;static image_processor_class=i.AutoImageProcessor;static uses_processor_config=!1;async _call(_,m=null,p={}){m||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),m=""),Array.isArray(_)||(_=[_]),Array.isArray(m)||(m=[m]);const y=this.tokenizer.bos_token,v=this.image_processor.config.image_seq_length;let x;m.some(E=>E.includes(u))?x=m.map(E=>{const I=E.replaceAll(u,u.repeat(v)),P=I.lastIndexOf(u),S=P===-1?0:P+u.length;return I.slice(0,S)+y+I.slice(S)+`
`}):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),x=m.map(E=>d(E,y,v,u,_.length)));const L=this.tokenizer(x,p);return{...await this.image_processor(_,p),...L}}}}),"./src/models/phi3_v/image_processing_phi3_v.js":((e,n,t)=>{t.r(n),t.d(n,{Phi3VImageProcessor:()=>_});var a=t("./src/base/image_processors_utils.js"),i=t("./src/utils/tensor.js");const l=336,u=[2,3],{ceil:d,floor:f,sqrt:h}=Math;class _ extends a.ImageProcessor{constructor(p){super({...p,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=p.num_crops}calc_num_image_tokens_from_image_size(p,y){const{num_img_tokens:v}=this.config;return f((f(y/l)*f(p/l)+1)*v+1+(f(y/l)+1)*h(v))}get_resize_output_image_size(p,y){const v=this._num_crops,[x,L]=p.size;let T=x/L,E=1;for(;E*Math.ceil(E/T)<=v;)E+=1;E-=1;const I=Math.floor(E*336),P=Math.floor(I/T);return[I,P]}pad_image(p,y,v,x={}){const[L,T]=y,E=l*d(L/l),I=l*d(T/l),P=[1,1,1].map((S,k)=>(S-this.image_mean[k])/this.image_std[k]);return super.pad_image(p,y,{width:I,height:E},{center:!0,constant_values:P,...x})}async _call(p,{num_crops:y=null}={}){if(this._num_crops=y??=this.config.num_crops,y<4||h(y)%1!==0)throw new Error("num_crops must be a square number >= 4");Array.isArray(p)||(p=[p]);const v=p.length,x=await Promise.all(p.map(C=>this.preprocess(C))),L=x.map(C=>C.original_size),T=x.map(C=>C.reshaped_input_size),E=[];for(const{pixel_values:C}of x){C.unsqueeze_(0);const[D,V]=C.dims.slice(-2),U=await(0,i.interpolate_4d)(C,{size:[l,l],mode:"bicubic"});if(y>0){const ne=[],ee=h(y),H=f(V/ee),oe=f(D/ee);for(let W=0;W<ee;++W)for(let te=0;te<ee;++te){let ie,_e,q,B;W===ee-1?(_e=D-oe,B=D):(_e=W*oe,B=(W+1)*oe),te===ee-1?(ie=V-H,q=V):(ie=te*H,q=(te+1)*H);const R=[_e,ie],Q=[B,q],G=await(0,i.slice)(C,R,Q,u);ne.push(G)}const ae=await(0,i.interpolate_4d)((0,i.cat)(ne,0),{size:[l,l],mode:"bicubic"});E.push((0,i.cat)([U,ae],0))}else E.push(U)}const I=(0,i.stack)(E,0),P=T.map(C=>C.map(D=>l*d(D/l))),S=new i.Tensor("int64",P.flat(),[v,2]),k=P.map(([C,D])=>this.calc_num_image_tokens_from_image_size(D,C));return{pixel_values:I,original_sizes:L,reshaped_input_sizes:T,image_sizes:S,num_img_tokens:k}}}}),"./src/models/phi3_v/processing_phi3_v.js":((e,n,t)=>{t.r(n),t.d(n,{Phi3VProcessor:()=>f});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js"),l=t("./src/tokenizers.js");t("./src/utils/image.js");const u="<|image|>",d=/<\|image_\d+\|>/g;class f extends a.Processor{static image_processor_class=i.AutoImageProcessor;static tokenizer_class=l.AutoTokenizer;async _call(_,m=null,{padding:p=!0,truncation:y=!0,num_crops:v=null}={}){Array.isArray(_)||(_=[_]);let x,L;if(m){L=await this.image_processor(m,{num_crops:v});const{num_img_tokens:T}=L,E=_.map((P,S)=>P.split(d).join(u.repeat(T[S])));x=this.tokenizer(E,{padding:p,truncation:y});const I=this.tokenizer.model.convert_tokens_to_ids([u])[0];x.input_ids.map_(P=>P==I?-P:P)}else x=this.tokenizer(_);return{...x,...L}}}}),"./src/models/processors.js":((e,n,t)=>{t.r(n),t.d(n,{Florence2Processor:()=>a.Florence2Processor,Gemma3nProcessor:()=>i.Gemma3nProcessor,GroundingDinoProcessor:()=>l.GroundingDinoProcessor,Idefics3Processor:()=>u.Idefics3Processor,JinaCLIPProcessor:()=>f.JinaCLIPProcessor,LlavaProcessor:()=>h.LlavaProcessor,MgpstrProcessor:()=>_.MgpstrProcessor,MoonshineProcessor:()=>m.MoonshineProcessor,OwlViTProcessor:()=>p.OwlViTProcessor,PaliGemmaProcessor:()=>v.PaliGemmaProcessor,Phi3VProcessor:()=>y.Phi3VProcessor,PyAnnoteProcessor:()=>x.PyAnnoteProcessor,Qwen2VLProcessor:()=>L.Qwen2VLProcessor,SamProcessor:()=>T.SamProcessor,SmolVLMProcessor:()=>E.SmolVLMProcessor,SpeechT5Processor:()=>I.SpeechT5Processor,UltravoxProcessor:()=>P.UltravoxProcessor,VLChatProcessor:()=>d.VLChatProcessor,VoxtralProcessor:()=>S.VoxtralProcessor,Wav2Vec2Processor:()=>k.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>C.Wav2Vec2ProcessorWithLM,WhisperProcessor:()=>D.WhisperProcessor});var a=t("./src/models/florence2/processing_florence2.js"),i=t("./src/models/gemma3n/processing_gemma3n.js"),l=t("./src/models/grounding_dino/processing_grounding_dino.js"),u=t("./src/models/idefics3/processing_idefics3.js"),d=t("./src/models/janus/processing_janus.js"),f=t("./src/models/jina_clip/processing_jina_clip.js"),h=t("./src/models/llava/processing_llava.js"),_=t("./src/models/mgp_str/processing_mgp_str.js"),m=t("./src/models/moonshine/processing_moonshine.js"),p=t("./src/models/owlvit/processing_owlvit.js"),y=t("./src/models/phi3_v/processing_phi3_v.js"),v=t("./src/models/paligemma/processing_paligemma.js"),x=t("./src/models/pyannote/processing_pyannote.js"),L=t("./src/models/qwen2_vl/processing_qwen2_vl.js"),T=t("./src/models/sam/processing_sam.js"),E=t("./src/models/smolvlm/processing_smolvlm.js"),I=t("./src/models/speecht5/processing_speecht5.js"),P=t("./src/models/ultravox/processing_ultravox.js"),S=t("./src/models/voxtral/processing_voxtral.js"),k=t("./src/models/wav2vec2/processing_wav2vec2.js"),C=t("./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js"),D=t("./src/models/whisper/processing_whisper.js")}),"./src/models/pvt/image_processing_pvt.js":((e,n,t)=>{t.r(n),t.d(n,{PvtImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}}),"./src/models/pyannote/feature_extraction_pyannote.js":((e,n,t)=>{t.r(n),t.d(n,{PyAnnoteFeatureExtractor:()=>u});var a=t("./src/base/feature_extraction_utils.js"),i=t("./src/utils/tensor.js"),l=t("./src/utils/maths.js");class u extends a.FeatureExtractor{async _call(f){(0,a.validate_audio_inputs)(f,"PyAnnoteFeatureExtractor"),f instanceof Float64Array&&(f=new Float32Array(f));const h=[1,1,f.length];return{input_values:new i.Tensor("float32",f,h)}}samples_to_frames(f){return(f-this.config.offset)/this.config.step}post_process_speaker_diarization(f,h){const _=h/this.samples_to_frames(h)/this.config.sampling_rate,m=[];for(const p of f.tolist()){const y=[];let v=-1;for(let x=0;x<p.length;++x){const L=(0,l.softmax)(p[x]),[T,E]=(0,l.max)(L),[I,P]=[x,x+1];E!==v?(v=E,y.push({id:E,start:I,end:P,score:T})):(y.at(-1).end=P,y.at(-1).score+=T)}m.push(y.map(({id:x,start:L,end:T,score:E})=>({id:x,start:L*_,end:T*_,confidence:E/(T-L)})))}return m}}}),"./src/models/pyannote/processing_pyannote.js":((e,n,t)=>{t.r(n),t.d(n,{PyAnnoteProcessor:()=>l});var a=t("./src/base/processing_utils.js"),i=t("./src/models/pyannote/feature_extraction_pyannote.js");class l extends a.Processor{static feature_extractor_class=i.PyAnnoteFeatureExtractor;async _call(d){return await this.feature_extractor(d)}post_process_speaker_diarization(...d){return this.feature_extractor.post_process_speaker_diarization(...d)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}}),"./src/models/qwen2_vl/image_processing_qwen2_vl.js":((e,n,t)=>{t.r(n),t.d(n,{Qwen2VLImageProcessor:()=>l});var a=t("./src/base/image_processors_utils.js"),i=t("./src/utils/tensor.js");class l extends a.ImageProcessor{async _call(d,...f){const{pixel_values:h,original_sizes:_,reshaped_input_sizes:m}=await super._call(d,...f);let p=h;const{temporal_patch_size:y,merge_size:v,patch_size:x}=this.config;p.dims[0]===1&&(p=(0,i.cat)(Array.from({length:y},()=>p),0));const L=p.dims[0]/y,T=p.dims[1],E=Math.floor(p.dims[2]/x),I=Math.floor(p.dims[3]/x),P=p.view(L,y,T,Math.floor(E/v),v,x,Math.floor(I/v),v,x).permute(0,3,6,4,7,2,1,5,8).view(L*E*I,T*y*x*x),S=new i.Tensor("int64",[L,E,I],[1,3]);return{pixel_values:P,image_grid_thw:S,original_sizes:_,reshaped_input_sizes:m}}}}),"./src/models/qwen2_vl/processing_qwen2_vl.js":((e,n,t)=>{t.r(n),t.d(n,{Qwen2VLProcessor:()=>u});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js"),l=t("./src/tokenizers.js");t("./src/utils/image.js");class u extends a.Processor{static image_processor_class=i.AutoImageProcessor;static tokenizer_class=l.AutoTokenizer;async _call(f,h=null,..._){Array.isArray(f)||(f=[f]);let m,p;if(h&&(m=await this.image_processor(h),p=m.image_grid_thw),p){let v=this.image_processor.config.merge_size**2,x=0;const L=p.tolist();f=f.map(T=>{for(;T.includes("<|image_pad|>");){const E=Number(L[x++].reduce((I,P)=>I*P,1n));T=T.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(E/v)))}return T.replaceAll("<|placeholder|>","<|image_pad|>")})}return{...this.tokenizer(f),...m}}}}),"./src/models/rt_detr/image_processing_rt_detr.js":((e,n,t)=>{t.r(n),t.d(n,{RTDetrImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{post_process_object_detection(...u){return(0,a.post_process_object_detection)(...u)}}}),"./src/models/sam/image_processing_sam.js":((e,n,t)=>{t.r(n),t.d(n,{SamImageProcessor:()=>u});var a=t("./src/base/image_processors_utils.js"),i=t("./src/utils/core.js"),l=t("./src/utils/tensor.js");class u extends a.ImageProcessor{reshape_input_points(f,h,_,m=!1){f=structuredClone(f);let p=(0,i.calculateDimensions)(f);if(p.length===3)m||(p=[1,...p]),f=[f];else if(p.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let y=0;y<f.length;++y){let v=h[y],x=_[y],L=[x[0]/v[0],x[1]/v[1]];for(let T=0;T<f[y].length;++T)for(let E=0;E<f[y][T].length;++E)for(let I=0;I<f[y][T][E].length;++I)f[y][T][E][I]*=L[I%2]}return new l.Tensor("float32",Float32Array.from(f.flat(1/0)),p)}add_input_labels(f,h){let _=(0,i.calculateDimensions)(f);if(_.length===2)_=[1,..._],f=[f];else if(_.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(_.some((m,p)=>m!==h.dims[p]))throw Error(`The first ${_.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new l.Tensor("int64",f.flat(1/0).map(BigInt),_)}async _call(f,{input_points:h=null,input_labels:_=null,input_boxes:m=null}={}){const p=await super._call(f);if(h&&(p.input_points=this.reshape_input_points(h,p.original_sizes,p.reshaped_input_sizes)),_){if(!p.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");p.input_labels=this.add_input_labels(_,p.input_points)}return m&&(p.input_boxes=this.reshape_input_points(m,p.original_sizes,p.reshaped_input_sizes,!0)),p}async post_process_masks(f,h,_,{mask_threshold:m=0,binarize:p=!0,pad_size:y=null}={}){const v=[];y=y??this.pad_size;const x=[y.height,y.width];for(let L=0;L<h.length;++L){const T=h[L],E=_[L];let I=await(0,l.interpolate_4d)(f[L],{mode:"bilinear",size:x});if(I=I.slice(null,null,[0,E[0]],[0,E[1]]),I=await(0,l.interpolate_4d)(I,{mode:"bilinear",size:T}),p){const P=I.data,S=new Uint8Array(P.length);for(let k=0;k<P.length;++k)P[k]>m&&(S[k]=1);I=new l.Tensor("bool",S,I.dims)}v.push(I)}return v}generate_crop_boxes(f,h,{crop_n_layers:_=0,overlap_ratio:m=512/1500,points_per_crop:p=32,crop_n_points_downscale_factor:y=1}={}){}}}),"./src/models/sam/processing_sam.js":((e,n,t)=>{t.r(n),t.d(n,{SamProcessor:()=>l});var a=t("./src/base/processing_utils.js"),i=t("./src/models/auto/image_processing_auto.js");class l extends a.Processor{static image_processor_class=i.AutoImageProcessor;async _call(...d){return await this.image_processor(...d)}post_process_masks(...d){return this.image_processor.post_process_masks(...d)}reshape_input_points(...d){return this.image_processor.reshape_input_points(...d)}}}),"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js":((e,n,t)=>{t.r(n),t.d(n,{SeamlessM4TFeatureExtractor:()=>u});var a=t("./src/base/feature_extraction_utils.js"),i=t("./src/utils/tensor.js"),l=t("./src/utils/audio.js");class u extends a.FeatureExtractor{constructor(f){super(f);const h=this.config.sampling_rate,_=(0,l.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(h/2),h,null,"kaldi",!0);this.mel_filters=_,this.window=(0,l.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(f,h){return f=f.map(_=>_*32768),(0,l.spectrogram)(f,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:h,transpose:!0})}async _call(f,{padding:h=!0,pad_to_multiple_of:_=2,do_normalize_per_mel_bins:m=!0,return_attention_mask:p=!0}={}){(0,a.validate_audio_inputs)(f,"SeamlessM4TFeatureExtractor");let y=await this._extract_fbank_features(f,this.config.max_length);if(m){const[S,k]=y.dims,C=y.data;for(let D=0;D<k;++D){let V=0;for(let H=0;H<S;++H)V+=C[H*k+D];const U=V/S;let ne=0;for(let H=0;H<S;++H)ne+=(C[H*k+D]-U)**2;ne/=S-1;const ee=Math.sqrt(ne+1e-7);for(let H=0;H<S;++H){const oe=H*k+D;C[oe]=(C[oe]-U)/ee}}}let v;if(h){const[S,k]=y.dims,C=y.data,D=S%_;if(D>0){const V=new Float32Array(k*(S+D));V.set(C),V.fill(this.config.padding_value,C.length);const U=S+D;y=new i.Tensor(y.type,V,[U,k]),p&&(v=new i.Tensor("int64",new BigInt64Array(U),[1,U]),v.data.fill(1n,0,S))}}const[x,L]=y.dims,T=this.config.stride;if(x%T!==0)throw new Error(`The number of frames (${x}) must be a multiple of the stride (${T}).`);const I=y.view(1,Math.floor(x/T),L*T),P={input_features:I};if(p){const S=I.dims[1],k=new BigInt64Array(S);if(v){const C=v.data;for(let D=1,V=0;D<x;D+=T,++V)k[V]=C[D]}else k.fill(1n);P.attention_mask=new i.Tensor("int64",k,[1,S])}return P}}}),"./src/models/segformer/image_processing_segformer.js":((e,n,t)=>{t.r(n),t.d(n,{SegformerFeatureExtractor:()=>l,SegformerImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{post_process_semantic_segmentation(...d){return(0,a.post_process_semantic_segmentation)(...d)}}class l extends i{}}),"./src/models/siglip/image_processing_siglip.js":((e,n,t)=>{t.r(n),t.d(n,{SiglipImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}}),"./src/models/smolvlm/image_processing_smolvlm.js":((e,n,t)=>{t.r(n),t.d(n,{SmolVLMImageProcessor:()=>a.Idefics3ImageProcessor});var a=t("./src/models/idefics3/image_processing_idefics3.js")}),"./src/models/smolvlm/processing_smolvlm.js":((e,n,t)=>{t.r(n),t.d(n,{SmolVLMProcessor:()=>a.Idefics3Processor});var a=t("./src/models/idefics3/processing_idefics3.js")}),"./src/models/snac/feature_extraction_snac.js":((e,n,t)=>{t.r(n),t.d(n,{SnacFeatureExtractor:()=>i});var a=t("./src/models/dac/feature_extraction_dac.js");class i extends a.DacFeatureExtractor{}}),"./src/models/speecht5/feature_extraction_speecht5.js":((e,n,t)=>{t.r(n),t.d(n,{SpeechT5FeatureExtractor:()=>i});var a=t("./src/base/feature_extraction_utils.js");class i extends a.FeatureExtractor{}}),"./src/models/speecht5/processing_speecht5.js":((e,n,t)=>{t.r(n),t.d(n,{SpeechT5Processor:()=>u});var a=t("./src/base/processing_utils.js"),i=t("./src/tokenizers.js"),l=t("./src/models/auto/feature_extraction_auto.js");class u extends a.Processor{static tokenizer_class=i.AutoTokenizer;static feature_extractor_class=l.AutoFeatureExtractor;async _call(f){return await this.feature_extractor(f)}}}),"./src/models/swin2sr/image_processing_swin2sr.js":((e,n,t)=>{t.r(n),t.d(n,{Swin2SRImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{pad_image(u,d,f,h={}){const[_,m,p]=d;return super.pad_image(u,d,{width:m+(f-m%f)%f,height:_+(f-_%f)%f},{mode:"symmetric",center:!1,constant_values:-1,...h})}}}),"./src/models/ultravox/processing_ultravox.js":((e,n,t)=>{t.r(n),t.d(n,{UltravoxProcessor:()=>u});var a=t("./src/models/auto/feature_extraction_auto.js"),i=t("./src/tokenizers.js"),l=t("./src/base/processing_utils.js");class u extends l.Processor{static tokenizer_class=i.AutoTokenizer;static feature_extractor_class=a.AutoFeatureExtractor;static uses_processor_config=!0;async _call(f,h=null,_={}){if(Array.isArray(f))throw new Error("Batched inputs are not supported yet.");let m={};if(h){const y=h.length,{input_features:v}=await this.feature_extractor(h,{..._,max_length:y}),x=Math.round(y/this.config.encoder_ds_factor+1e-4),L=1+Math.ceil(x/this.config.stack_factor);m.audio_token_len=[L],m.audio_values=v;const T=this.config.audio_placeholder;if(!f.includes(T))throw new Error(`The input text does not contain the image token ${T}.`);f=f.replaceAll(T,T.repeat(L))}return{...this.tokenizer(f,{add_special_tokens:!1,..._}),...m}}}}),"./src/models/vit/image_processing_vit.js":((e,n,t)=>{t.r(n),t.d(n,{ViTFeatureExtractor:()=>l,ViTImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{}class l extends i{}}),"./src/models/vitmatte/image_processing_vitmatte.js":((e,n,t)=>{t.r(n),t.d(n,{VitMatteImageProcessor:()=>l});var a=t("./src/base/image_processors_utils.js"),i=t("./src/utils/tensor.js");class l extends a.ImageProcessor{async _call(d,f){Array.isArray(d)||(d=[d]),Array.isArray(f)||(f=[f]);const h=await Promise.all(d.map(p=>this.preprocess(p))),_=await Promise.all(f.map(p=>this.preprocess(p,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,i.stack)(h.map((p,y)=>(0,i.cat)([p.pixel_values,_[y].pixel_values],0)),0),original_sizes:h.map(p=>p.original_size),reshaped_input_sizes:h.map(p=>p.reshaped_input_size)}}}}),"./src/models/vitpose/image_processing_vitpose.js":((e,n,t)=>{t.r(n),t.d(n,{VitPoseImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{post_process_pose_estimation(u,d,{threshold:f=null}={}){const h=u.tolist(),[_,m,p,y]=u.dims,v=[];for(let x=0;x<_;++x){const L=h[x],T=d[x],E=[];for(let I=0;I<T.length;++I){const P=T[I],S=[],k=[],C=[],D=P.at(-2)/y,V=P.at(-1)/p;for(let U=0;U<L.length;++U){let[ne,ee]=[0,0],H=0,oe=-1/0;const ae=L[U];for(let te=0;te<ae.length;++te){const ie=ae[te];for(let _e=0;_e<ie.length;++_e){const q=ie[_e];H+=q,oe=Math.max(oe,q),ne+=(_e+.5)*q,ee+=te*q}}if(f!=null&&oe<f)continue;const W=[D*ne/H,V*ee/H];S.push(W),C.push(U),k.push(oe)}E.push({bbox:P,scores:k,labels:C,keypoints:S})}v.push(E)}return v}}}),"./src/models/voxtral/processing_voxtral.js":((e,n,t)=>{t.r(n),t.d(n,{VoxtralProcessor:()=>m});var a=t("./src/models/auto/feature_extraction_auto.js"),i=t("./src/tokenizers.js"),l=t("./src/base/processing_utils.js"),u=t("./src/utils/tensor.js");const d="[AUDIO]",f="[BEGIN_AUDIO]",h=375;function _(p,y){const v=[];for(let x=0;x<p.length;x+=y)v.push(p.subarray(x,Math.min(x+y,p.length)));return v}class m extends l.Processor{static tokenizer_class=i.AutoTokenizer;static feature_extractor_class=a.AutoFeatureExtractor;static uses_processor_config=!1;async _call(y,v=null,x={}){if(Array.isArray(y))throw new Error("Batched inputs are not supported yet.");const L={};if(v){if(!y.includes(d))throw new Error(`The input text does not contain the audio token ${d}.`);Array.isArray(v)||(v=[v]);const E=y.split(d),I=E.length-1;if(I!==v.length)throw new Error(`The number of audio inputs (${v.length}) does not match the number of audio tokens in the text (${I}).`);const P=this.feature_extractor.config.n_samples,S=v.map(U=>_(U,P)),k=S.map(U=>U.length),C=S.flat(),D=(await Promise.all(C.map(U=>this.feature_extractor(U,x)))).map(U=>U.input_features);L.audio_values=D.length>1?(0,u.cat)(D,0):D[0];let V=E[0];for(let U=0;U<k.length;++U){V+=f;for(let ne=0;ne<k[U];++ne)V+=d.repeat(h);V+=E[U+1]}y=V}return{...this.tokenizer(y,{add_special_tokens:!1,...x}),...L}}}}),"./src/models/wav2vec2/feature_extraction_wav2vec2.js":((e,n,t)=>{t.r(n),t.d(n,{Wav2Vec2FeatureExtractor:()=>l});var a=t("./src/base/feature_extraction_utils.js"),i=t("./src/utils/tensor.js");class l extends a.FeatureExtractor{_zero_mean_unit_var_norm(d){const h=d.reduce((m,p)=>m+p,0)/d.length,_=d.reduce((m,p)=>m+(p-h)**2,0)/d.length;return d.map(m=>(m-h)/Math.sqrt(_+1e-7))}async _call(d){(0,a.validate_audio_inputs)(d,"Wav2Vec2FeatureExtractor"),d instanceof Float64Array&&(d=new Float32Array(d));let f=d;this.config.do_normalize&&(f=this._zero_mean_unit_var_norm(f));const h=[1,f.length];return{input_values:new i.Tensor("float32",f,h),attention_mask:new i.Tensor("int64",new BigInt64Array(f.length).fill(1n),h)}}}}),"./src/models/wav2vec2/processing_wav2vec2.js":((e,n,t)=>{t.r(n),t.d(n,{Wav2Vec2Processor:()=>u});var a=t("./src/tokenizers.js"),i=t("./src/models/auto/feature_extraction_auto.js"),l=t("./src/base/processing_utils.js");class u extends l.Processor{static tokenizer_class=a.AutoTokenizer;static feature_extractor_class=i.AutoFeatureExtractor;async _call(f){return await this.feature_extractor(f)}}}),"./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js":((e,n,t)=>{t.r(n),t.d(n,{Wav2Vec2ProcessorWithLM:()=>u});var a=t("./src/tokenizers.js"),i=t("./src/models/auto/feature_extraction_auto.js"),l=t("./src/base/processing_utils.js");class u extends l.Processor{static tokenizer_class=a.AutoTokenizer;static feature_extractor_class=i.AutoFeatureExtractor;async _call(f){return await this.feature_extractor(f)}}}),"./src/models/wespeaker/feature_extraction_wespeaker.js":((e,n,t)=>{t.r(n),t.d(n,{WeSpeakerFeatureExtractor:()=>l});var a=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var i=t("./src/utils/audio.js");class l extends a.FeatureExtractor{constructor(d){super(d);const f=this.config.sampling_rate,h=(0,i.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(f/2),f,null,"kaldi",!0);this.mel_filters=h,this.window=(0,i.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(d){return d=d.map(f=>f*32768),(0,i.spectrogram)(d,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(d){(0,a.validate_audio_inputs)(d,"WeSpeakerFeatureExtractor");const f=(await this._extract_fbank_features(d)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const h=f.mean(1).data,_=f.data,[m,p,y]=f.dims;for(let v=0;v<m;++v){const x=v*p*y,L=v*y;for(let T=0;T<p;++T){const E=x+T*y;for(let I=0;I<y;++I)_[E+I]-=h[L+I]}}}return{input_features:f}}}}),"./src/models/whisper/common_whisper.js":((e,n,t)=>{t.r(n),t.d(n,{WHISPER_LANGUAGE_MAPPING:()=>i,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>l,whisper_language_to_code:()=>u});const a=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],i=new Map(a),l=new Map([...a.map(([d,f])=>[f,d]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function u(d){d=d.toLowerCase();let f=l.get(d);if(f===void 0){const h=d.match(/^<\|([a-z]{2})\|>$/);if(h&&(d=h[1]),i.has(d))f=d;else{const m=d.length===2?i.keys():i.values();throw new Error(`Language "${d}" is not supported. Must be one of: ${JSON.stringify(Array.from(m))}`)}}return f}}),"./src/models/whisper/feature_extraction_whisper.js":((e,n,t)=>{t.r(n),t.d(n,{WhisperFeatureExtractor:()=>u});var a=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var i=t("./src/utils/audio.js"),l=t("./src/utils/maths.js");class u extends a.FeatureExtractor{constructor(f){super(f),this.config.mel_filters??=(0,i.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=(0,i.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(f){const h=await(0,i.spectrogram)(f,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:Math.min(Math.floor(f.length/this.config.hop_length),this.config.nb_max_frames)}),_=h.data,m=(0,l.max)(_)[0];for(let p=0;p<_.length;++p)_[p]=(Math.max(_[p],m-8)+4)/4;return h}async _call(f,{max_length:h=null}={}){(0,a.validate_audio_inputs)(f,"WhisperFeatureExtractor");let _;const m=h??this.config.n_samples;return f.length>m?(f.length>this.config.n_samples&&console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),_=f.slice(0,m)):(_=new Float32Array(m),_.set(f)),{input_features:(await this._extract_fbank_features(_)).unsqueeze_(0)}}}}),"./src/models/whisper/generation_whisper.js":((e,n,t)=>{t.r(n),t.d(n,{WhisperGenerationConfig:()=>i});var a=t("./src/generation/configuration_utils.js");class i extends a.GenerationConfig{return_timestamps=null;return_token_timestamps=null;num_frames=null;alignment_heads=null;task=null;language=null;no_timestamps_token_id=null;prompt_ids=null;is_multilingual=null;lang_to_id=null;task_to_id=null;max_initial_timestamp_index=1}}),"./src/models/whisper/processing_whisper.js":((e,n,t)=>{t.r(n),t.d(n,{WhisperProcessor:()=>u});var a=t("./src/models/auto/feature_extraction_auto.js"),i=t("./src/tokenizers.js"),l=t("./src/base/processing_utils.js");class u extends l.Processor{static tokenizer_class=i.AutoTokenizer;static feature_extractor_class=a.AutoFeatureExtractor;async _call(f){return await this.feature_extractor(f)}}}),"./src/models/yolos/image_processing_yolos.js":((e,n,t)=>{t.r(n),t.d(n,{YolosFeatureExtractor:()=>l,YolosImageProcessor:()=>i});var a=t("./src/base/image_processors_utils.js");class i extends a.ImageProcessor{post_process_object_detection(...d){return(0,a.post_process_object_detection)(...d)}}class l extends i{}}),"./src/ops/registry.js":((e,n,t)=>{t.r(n),t.d(n,{TensorOpRegistry:()=>u});var a=t("./src/backends/onnx.js"),i=t("./src/utils/tensor.js");const l=async(d,f,h)=>{const _=await(0,a.createInferenceSession)(new Uint8Array(d),f);return(async m=>{const p=(0,a.isONNXProxy)(),y=Object.fromEntries(Object.entries(m).map(([x,L])=>[x,(p?L.clone():L).ort_tensor])),v=await(0,a.runInferenceSession)(_,y);return Array.isArray(h)?h.map(x=>new i.Tensor(v[x])):new i.Tensor(v[h])})};class u{static session_options={};static get nearest_interpolate_4d(){return this._nearest_interpolate_4d||(this._nearest_interpolate_4d=l([8,10,18,0,58,129,1,10,41,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,18,10,4,109,111,100,101,34,7,110,101,97,114,101,115,116,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,21],this.session_options,"y")),this._nearest_interpolate_4d}static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=l([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=l([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=l([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=l([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=l([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=l([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=l([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}}),"./src/pipelines.js":((e,n,t)=>{t.r(n),t.d(n,{AudioClassificationPipeline:()=>ee,AutomaticSpeechRecognitionPipeline:()=>oe,BackgroundRemovalPipeline:()=>ie,DepthEstimationPipeline:()=>fe,DocumentQuestionAnsweringPipeline:()=>R,FeatureExtractionPipeline:()=>U,FillMaskPipeline:()=>I,ImageClassificationPipeline:()=>W,ImageFeatureExtractionPipeline:()=>ne,ImageSegmentationPipeline:()=>te,ImageToImagePipeline:()=>G,ImageToTextPipeline:()=>ae,ObjectDetectionPipeline:()=>q,Pipeline:()=>x,QuestionAnsweringPipeline:()=>E,SummarizationPipeline:()=>S,Text2TextGenerationPipeline:()=>P,TextClassificationPipeline:()=>L,TextGenerationPipeline:()=>D,TextToAudioPipeline:()=>Q,TokenClassificationPipeline:()=>T,TranslationPipeline:()=>k,ZeroShotAudioClassificationPipeline:()=>H,ZeroShotClassificationPipeline:()=>V,ZeroShotImageClassificationPipeline:()=>_e,ZeroShotObjectDetectionPipeline:()=>B,pipeline:()=>Ue});var a=t("./src/tokenizers.js"),i=t("./src/models.js"),l=t("./src/models/auto/processing_auto.js");t("./src/base/processing_utils.js");var u=t("./src/utils/generic.js"),d=t("./src/utils/core.js"),f=t("./src/utils/maths.js"),h=t("./src/utils/audio.js"),_=t("./src/utils/tensor.js"),m=t("./src/utils/image.js");async function p(je){return Array.isArray(je)||(je=[je]),await Promise.all(je.map(le=>m.RawImage.read(le)))}async function y(je,le){return Array.isArray(je)||(je=[je]),await Promise.all(je.map(J=>typeof J=="string"||J instanceof URL?(0,h.read_audio)(J,le):J instanceof Float64Array?new Float32Array(J):J))}function v(je,le){le&&(je=je.map(De=>De|0));const[J,be,Ae,Ne]=je;return{xmin:J,ymin:be,xmax:Ae,ymax:Ne}}class x extends u.Callable{constructor({task:le,model:J,tokenizer:be=null,processor:Ae=null}){super(),this.task=le,this.model=J,this.tokenizer=be,this.processor=Ae}async dispose(){await this.model.dispose()}}class L extends x{constructor(le){super(le)}async _call(le,{top_k:J=1}={}){const be=this.tokenizer(le,{padding:!0,truncation:!0}),Ae=await this.model(be),Ne=this.model.config.problem_type==="multi_label_classification"?Ve=>Ve.sigmoid():Ve=>new _.Tensor("float32",(0,f.softmax)(Ve.data),Ve.dims),De=this.model.config.id2label,xe=[];for(const Ve of Ae.logits){const Ee=Ne(Ve),Ge=await(0,_.topk)(Ee,J),Ye=Ge[0].tolist(),Re=Ge[1].tolist().map((xt,st)=>({label:De?De[xt]:`LABEL_${xt}`,score:Ye[st]}));J===1?xe.push(...Re):xe.push(Re)}return Array.isArray(le)||J===1?xe:xe[0]}}class T extends x{constructor(le){super(le)}async _call(le,{ignore_labels:J=["O"]}={}){const be=Array.isArray(le),Ae=this.tokenizer(be?le:[le],{padding:!0,truncation:!0}),De=(await this.model(Ae)).logits,xe=this.model.config.id2label,Ve=[];for(let Ee=0;Ee<De.dims[0];++Ee){const Ge=Ae.input_ids[Ee],Ye=De[Ee],_t=[];for(let Re=0;Re<Ye.dims[0];++Re){const xt=Ye[Re],st=(0,f.max)(xt.data)[1],nt=xe?xe[st]:`LABEL_${st}`;if(J.includes(nt))continue;const ct=this.tokenizer.decode([Ge[Re].item()],{skip_special_tokens:!0});if(ct==="")continue;const pt=(0,f.softmax)(xt.data);_t.push({entity:nt,score:pt[st],index:Re,word:ct})}Ve.push(_t)}return be?Ve:Ve[0]}}class E extends x{constructor(le){super(le)}async _call(le,J,{top_k:be=1}={}){const Ae=this.tokenizer(le,{text_pair:J,padding:!0,truncation:!0}),{start_logits:Ne,end_logits:De}=await this.model(Ae),xe=Ae.input_ids.tolist(),Ve=Ae.attention_mask.tolist(),Ee=this.tokenizer.all_special_ids,Ge=[];for(let Ye=0;Ye<Ne.dims[0];++Ye){const _t=xe[Ye],Re=_t.findIndex(lt=>lt==this.tokenizer.sep_token_id);Ve[Ye].map((lt,Mt)=>lt==1&&(Mt===0||Mt>Re&&Ee.findIndex(tn=>tn==_t[Mt])===-1));const xt=Ne[Ye].tolist(),st=De[Ye].tolist();for(let lt=1;lt<xt.length;++lt)(Ve[Ye]==0||lt<=Re||Ee.findIndex(Mt=>Mt==_t[lt])!==-1)&&(xt[lt]=-1/0,st[lt]=-1/0);const nt=(0,f.softmax)(xt).map((lt,Mt)=>[lt,Mt]),ct=(0,f.softmax)(st).map((lt,Mt)=>[lt,Mt]);nt[0][0]=0,ct[0][0]=0;const pt=(0,d.product)(nt,ct).filter(lt=>lt[0][1]<=lt[1][1]).map(lt=>[lt[0][1],lt[1][1],lt[0][0]*lt[1][0]]).sort((lt,Mt)=>Mt[2]-lt[2]);for(let lt=0;lt<Math.min(pt.length,be);++lt){const[Mt,tn,an]=pt[lt],Ft=_t.slice(Mt,tn+1),or=this.tokenizer.decode(Ft,{skip_special_tokens:!0});Ge.push({answer:or,score:an})}}return be===1?Ge[0]:Ge}}class I extends x{constructor(le){super(le)}async _call(le,{top_k:J=5}={}){const be=this.tokenizer(le,{padding:!0,truncation:!0}),{logits:Ae}=await this.model(be),Ne=[],De=be.input_ids.tolist();for(let xe=0;xe<De.length;++xe){const Ve=De[xe],Ee=Ve.findIndex(xt=>xt==this.tokenizer.mask_token_id);if(Ee===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const Ge=Ae[xe][Ee],Ye=await(0,_.topk)(new _.Tensor("float32",(0,f.softmax)(Ge.data),Ge.dims),J),_t=Ye[0].tolist(),Re=Ye[1].tolist();Ne.push(Re.map((xt,st)=>{const nt=Ve.slice();return nt[Ee]=xt,{score:_t[st],token:Number(xt),token_str:this.tokenizer.decode([xt]),sequence:this.tokenizer.decode(nt,{skip_special_tokens:!0})}}))}return Array.isArray(le)?Ne:Ne[0]}}class P extends x{_key="generated_text";constructor(le){super(le)}async _call(le,J={}){Array.isArray(le)||(le=[le]),this.model.config.prefix&&(le=le.map(Ve=>this.model.config.prefix+Ve));const be=this.model.config.task_specific_params;be&&be[this.task]&&be[this.task].prefix&&(le=le.map(Ve=>be[this.task].prefix+Ve));const Ae=this.tokenizer,Ne={padding:!0,truncation:!0};let De;this instanceof k&&"_build_translation_inputs"in Ae?De=Ae._build_translation_inputs(le,Ne,J):De=Ae(le,Ne);const xe=await this.model.generate({...De,...J});return Ae.batch_decode(xe,{skip_special_tokens:!0}).map(Ve=>({[this._key]:Ve}))}}class S extends P{_key="summary_text";constructor(le){super(le)}}class k extends P{_key="translation_text";constructor(le){super(le)}}function C(je){return Array.isArray(je)&&je.every(le=>"role"in le&&"content"in le)}class D extends x{constructor(le){super(le)}async _call(le,J={}){let be=!1,Ae=!1,Ne=J.add_special_tokens??(this.tokenizer.add_bos_token||this.tokenizer.add_eos_token)??!1,De;if(typeof le=="string")De=le=[le];else if(Array.isArray(le)&&le.every(Re=>typeof Re=="string"))be=!0,De=le;else{if(C(le))le=[le];else if(Array.isArray(le)&&le.every(C))be=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");Ae=!0,De=le.map(Re=>this.tokenizer.apply_chat_template(Re,{tokenize:!1,add_generation_prompt:!0})),Ne=!1}const xe=Ae?!1:J.return_full_text??!0;this.tokenizer.padding_side="left";const Ve=this.tokenizer(De,{add_special_tokens:Ne,padding:!0,truncation:!0}),Ee=await this.model.generate({...Ve,...J}),Ge=this.tokenizer.batch_decode(Ee,{skip_special_tokens:!0});let Ye;!xe&&Ve.input_ids.dims.at(-1)>0&&(Ye=this.tokenizer.batch_decode(Ve.input_ids,{skip_special_tokens:!0}).map(Re=>Re.length));const _t=Array.from({length:le.length},Re=>[]);for(let Re=0;Re<Ge.length;++Re){const xt=Math.floor(Re/Ee.dims[0]*le.length);Ye&&(Ge[Re]=Ge[Re].slice(Ye[xt])),_t[xt].push({generated_text:Ae?[...le[xt],{role:"assistant",content:Ge[Re]}]:Ge[Re]})}return!be&&_t.length===1?_t[0]:_t}}class V extends x{constructor(le){super(le),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([J,be])=>[J.toLowerCase(),be])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(le,J,{hypothesis_template:be="This example is {}.",multi_label:Ae=!1}={}){const Ne=Array.isArray(le);Ne||(le=[le]),Array.isArray(J)||(J=[J]);const De=J.map(Ee=>be.replace("{}",Ee)),xe=Ae||J.length===1,Ve=[];for(const Ee of le){const Ge=[];for(const Re of De){const xt=this.tokenizer(Ee,{text_pair:Re,padding:!0,truncation:!0}),st=await this.model(xt);xe?Ge.push([st.logits.data[this.contradiction_id],st.logits.data[this.entailment_id]]):Ge.push(st.logits.data[this.entailment_id])}const _t=(xe?Ge.map(Re=>(0,f.softmax)(Re)[1]):(0,f.softmax)(Ge)).map((Re,xt)=>[Re,xt]).sort((Re,xt)=>xt[0]-Re[0]);Ve.push({sequence:Ee,labels:_t.map(Re=>J[Re[1]]),scores:_t.map(Re=>Re[0])})}return Ne?Ve:Ve[0]}}class U extends x{constructor(le){super(le)}async _call(le,{pooling:J="none",normalize:be=!1,quantize:Ae=!1,precision:Ne="binary"}={}){const De=this.tokenizer(le,{padding:!0,truncation:!0}),xe=await this.model(De);let Ve=xe.last_hidden_state??xe.logits??xe.token_embeddings;switch(J){case"none":break;case"mean":Ve=(0,_.mean_pooling)(Ve,De.attention_mask);break;case"first_token":case"cls":Ve=Ve.slice(null,0);break;case"last_token":case"eos":Ve=Ve.slice(null,-1);break;default:throw Error(`Pooling method '${J}' not supported.`)}return be&&(Ve=Ve.normalize(2,-1)),Ae&&(Ve=(0,_.quantize_embeddings)(Ve,Ne)),Ve}}class ne extends x{constructor(le){super(le)}async _call(le,{pool:J=null}={}){const be=await p(le),{pixel_values:Ae}=await this.processor(be),Ne=await this.model({pixel_values:Ae});let De;if(J){if(!("pooler_output"in Ne))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");De=Ne.pooler_output}else De=Ne.last_hidden_state??Ne.logits??Ne.image_embeds;return De}}class ee extends x{constructor(le){super(le)}async _call(le,{top_k:J=5}={}){const be=this.processor.feature_extractor.config.sampling_rate,Ae=await y(le,be),Ne=this.model.config.id2label,De=[];for(const xe of Ae){const Ve=await this.processor(xe),Ge=(await this.model(Ve)).logits[0],Ye=await(0,_.topk)(new _.Tensor("float32",(0,f.softmax)(Ge.data),Ge.dims),J),_t=Ye[0].tolist(),xt=Ye[1].tolist().map((st,nt)=>({label:Ne?Ne[st]:`LABEL_${st}`,score:_t[nt]}));De.push(xt)}return Array.isArray(le)?De:De[0]}}class H extends x{constructor(le){super(le)}async _call(le,J,{hypothesis_template:be="This is a sound of {}."}={}){const Ae=!Array.isArray(le);Ae&&(le=[le]);const Ne=J.map(Ge=>be.replace("{}",Ge)),De=this.tokenizer(Ne,{padding:!0,truncation:!0}),xe=this.processor.feature_extractor.config.sampling_rate,Ve=await y(le,xe),Ee=[];for(const Ge of Ve){const Ye=await this.processor(Ge),_t=await this.model({...De,...Ye}),Re=(0,f.softmax)(_t.logits_per_audio.data);Ee.push([...Re].map((xt,st)=>({score:xt,label:J[st]})))}return Ae?Ee[0]:Ee}}class oe extends x{constructor(le){super(le)}async _call(le,J={}){switch(this.model.config.model_type){case"whisper":case"lite-whisper":return this._call_whisper(le,J);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(le,J);case"moonshine":return this._call_moonshine(le,J);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(le,J){J.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),J.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const be=!Array.isArray(le);be&&(le=[le]);const Ae=this.processor.feature_extractor.config.sampling_rate,Ne=await y(le,Ae),De=[];for(const xe of Ne){const Ve=await this.processor(xe),Ge=(await this.model(Ve)).logits[0],Ye=[];for(const Re of Ge)Ye.push((0,f.max)(Re.data)[1]);const _t=this.tokenizer.decode(Ye);De.push({text:_t})}return be?De[0]:De}async _call_whisper(le,J){const be=J.return_timestamps??!1,Ae=J.chunk_length_s??0,Ne=J.force_full_sequences??!1;let De=J.stride_length_s??null;const xe={...J};be==="word"&&(xe.return_token_timestamps=!0,xe.return_timestamps=!1);const Ve=!Array.isArray(le);Ve&&(le=[le]);const Ee=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,Ge=this.processor.feature_extractor.config.hop_length,Ye=this.processor.feature_extractor.config.sampling_rate,_t=await y(le,Ye),Re=[];for(const xt of _t){let st=[];if(Ae>0){if(De===null)De=Ae/6;else if(Ae<=De)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const pt=Ye*Ae,lt=Ye*De,Mt=pt-2*lt;let tn=0;for(;;){const an=tn+pt,Ft=xt.subarray(tn,an),or=await this.processor(Ft),Or=tn===0,Br=an>=xt.length;if(st.push({stride:[Ft.length,Or?0:lt,Br?0:lt],input_features:or.input_features,is_last:Br}),Br)break;tn+=Mt}}else st=[{stride:[xt.length,0,0],input_features:(await this.processor(xt)).input_features,is_last:!0}];for(const pt of st){xe.num_frames=Math.floor(pt.stride[0]/Ge);const lt=await this.model.generate({inputs:pt.input_features,...xe});be==="word"?(pt.tokens=lt.sequences.tolist()[0],pt.token_timestamps=lt.token_timestamps.tolist()[0].map(Mt=>(0,f.round)(Mt,2))):pt.tokens=lt[0].tolist(),pt.stride=pt.stride.map(Mt=>Mt/Ye)}const[nt,ct]=this.tokenizer._decode_asr(st,{time_precision:Ee,return_timestamps:be,force_full_sequences:Ne});Re.push({text:nt,...ct})}return Ve?Re[0]:Re}async _call_moonshine(le,J){const be=!Array.isArray(le);be&&(le=[le]);const Ae=this.processor.feature_extractor.config.sampling_rate,Ne=await y(le,Ae),De=[];for(const xe of Ne){const Ve=await this.processor(xe),Ee=Math.floor(xe.length/Ae)*6,Ge=await this.model.generate({max_new_tokens:Ee,...J,...Ve}),Ye=this.processor.batch_decode(Ge,{skip_special_tokens:!0})[0];De.push({text:Ye})}return be?De[0]:De}}class ae extends x{constructor(le){super(le)}async _call(le,J={}){const be=Array.isArray(le),Ae=await p(le),{pixel_values:Ne}=await this.processor(Ae),De=[];for(const xe of Ne){xe.dims=[1,...xe.dims];const Ve=await this.model.generate({inputs:xe,...J}),Ee=this.tokenizer.batch_decode(Ve,{skip_special_tokens:!0}).map(Ge=>({generated_text:Ge.trim()}));De.push(Ee)}return be?De:De[0]}}class W extends x{constructor(le){super(le)}async _call(le,{top_k:J=5}={}){const be=await p(le),{pixel_values:Ae}=await this.processor(be),Ne=await this.model({pixel_values:Ae}),De=this.model.config.id2label,xe=[];for(const Ve of Ne.logits){const Ee=await(0,_.topk)(new _.Tensor("float32",(0,f.softmax)(Ve.data),Ve.dims),J),Ge=Ee[0].tolist(),_t=Ee[1].tolist().map((Re,xt)=>({label:De?De[Re]:`LABEL_${Re}`,score:Ge[xt]}));xe.push(_t)}return Array.isArray(le)?xe:xe[0]}}class te extends x{constructor(le){super(le),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(le,{threshold:J=.5,mask_threshold:be=.5,overlap_mask_area_threshold:Ae=.8,label_ids_to_fuse:Ne=null,target_sizes:De=null,subtask:xe=null}={}){if(Array.isArray(le)&&le.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const Ee=await p(le),Ge=Ee.map(pt=>[pt.height,pt.width]),Ye=await this.processor(Ee),{inputNames:_t,outputNames:Re}=this.model.sessions.model;if(!_t.includes("pixel_values")){if(_t.length!==1)throw Error(`Expected a single input name, but got ${_t.length} inputs: ${_t}.`);const pt=_t[0];if(pt in Ye)throw Error(`Input name ${pt} already exists in the inputs.`);Ye[pt]=Ye.pixel_values}const xt=await this.model(Ye);let st=null;if(xe!==null)st=this.subtasks_mapping[xe];else if(this.processor.image_processor){for(const[pt,lt]of Object.entries(this.subtasks_mapping))if(lt in this.processor.image_processor){st=this.processor.image_processor[lt].bind(this.processor.image_processor),xe=pt;break}}const nt=this.model.config.id2label,ct=[];if(xe)if(xe==="panoptic"||xe==="instance"){const pt=st(xt,J,be,Ae,Ne,De??Ge)[0],lt=pt.segmentation;for(const Mt of pt.segments_info){const tn=new Uint8ClampedArray(lt.data.length);for(let Ft=0;Ft<lt.data.length;++Ft)lt.data[Ft]===Mt.id&&(tn[Ft]=255);const an=new m.RawImage(tn,lt.dims[1],lt.dims[0],1);ct.push({score:Mt.score,label:nt[Mt.label_id],mask:an})}}else if(xe==="semantic"){const{segmentation:pt,labels:lt}=st(xt,De??Ge)[0];for(const Mt of lt){const tn=new Uint8ClampedArray(pt.data.length);for(let Ft=0;Ft<pt.data.length;++Ft)pt.data[Ft]===Mt&&(tn[Ft]=255);const an=new m.RawImage(tn,pt.dims[1],pt.dims[0],1);ct.push({score:null,label:nt[Mt],mask:an})}}else throw Error(`Subtask ${xe} not supported.`);else{const lt=xt[Re[0]];for(let Mt=0;Mt<Ge.length;++Mt){const tn=Ge[Mt],an=lt[Mt];an.data.some(or=>or<-1e-5||or>1+1e-5)&&an.sigmoid_();const Ft=await m.RawImage.fromTensor(an.mul_(255).to("uint8")).resize(tn[1],tn[0]);ct.push({label:null,score:null,mask:Ft})}}return ct}}class ie extends te{constructor(le){super(le)}async _call(le,J={}){if(Array.isArray(le)&&le.length!==1)throw Error("Background removal pipeline currently only supports a batch size of 1.");const Ae=await p(le),Ne=await super._call(le,J);return Ae.map((xe,Ve)=>{const Ee=xe.clone();return Ee.putAlpha(Ne[Ve].mask),Ee})}}class _e extends x{constructor(le){super(le)}async _call(le,J,{hypothesis_template:be="This is a photo of {}"}={}){const Ae=Array.isArray(le),Ne=await p(le),De=J.map(_t=>be.replace("{}",_t)),xe=this.tokenizer(De,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:Ve}=await this.processor(Ne),Ee=await this.model({...xe,pixel_values:Ve}),Ge=this.model.config.model_type==="siglip"?_t=>_t.sigmoid().data:_t=>(0,f.softmax)(_t.data),Ye=[];for(const _t of Ee.logits_per_image){const xt=[...Ge(_t)].map((st,nt)=>({score:st,label:J[nt]}));xt.sort((st,nt)=>nt.score-st.score),Ye.push(xt)}return Ae?Ye:Ye[0]}}class q extends x{constructor(le){super(le)}async _call(le,{threshold:J=.9,percentage:be=!1}={}){const Ae=Array.isArray(le);if(Ae&&le.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const Ne=await p(le),De=be?null:Ne.map(Re=>[Re.height,Re.width]),{pixel_values:xe,pixel_mask:Ve}=await this.processor(Ne),Ee=await this.model({pixel_values:xe,pixel_mask:Ve}),Ge=this.processor.image_processor.post_process_object_detection(Ee,J,De),Ye=this.model.config.id2label,_t=Ge.map(Re=>Re.boxes.map((xt,st)=>({score:Re.scores[st],label:Ye[Re.classes[st]],box:v(xt,!be)})));return Ae?_t:_t[0]}}class B extends x{constructor(le){super(le)}async _call(le,J,{threshold:be=.1,top_k:Ae=null,percentage:Ne=!1}={}){const De=Array.isArray(le),xe=await p(le),Ve=this.tokenizer(J,{padding:!0,truncation:!0}),Ee=await this.processor(xe),Ge=[];for(let Ye=0;Ye<xe.length;++Ye){const _t=xe[Ye],Re=Ne?null:[[_t.height,_t.width]],xt=Ee.pixel_values[Ye].unsqueeze_(0),st=await this.model({...Ve,pixel_values:xt});let nt;if("post_process_grounded_object_detection"in this.processor){const ct=this.processor.post_process_grounded_object_detection(st,Ve.input_ids,{box_threshold:be,text_threshold:be,target_sizes:Re})[0];nt=ct.boxes.map((pt,lt)=>({score:ct.scores[lt],label:ct.labels[lt],box:v(pt,!Ne)}))}else{const ct=this.processor.image_processor.post_process_object_detection(st,be,Re,!0)[0];nt=ct.boxes.map((pt,lt)=>({score:ct.scores[lt],label:J[ct.classes[lt]],box:v(pt,!Ne)}))}nt.sort((ct,pt)=>pt.score-ct.score),Ae!==null&&(nt=nt.slice(0,Ae)),Ge.push(nt)}return De?Ge:Ge[0]}}class R extends x{constructor(le){super(le)}async _call(le,J,be={}){const Ae=(await p(le))[0],{pixel_values:Ne}=await this.processor(Ae),De=`<s_docvqa><s_question>${J}</s_question><s_answer>`,xe=this.tokenizer(De,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,Ve=await this.model.generate({inputs:Ne,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:xe,...be}),Ge=this.tokenizer.batch_decode(Ve)[0].match(/<s_answer>(.*?)<\/s_answer>/);let Ye=null;return Ge&&Ge.length>=2&&(Ye=Ge[1].trim()),[{answer:Ye}]}}class Q extends x{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(le){super(le),this.vocoder=le.vocoder??null}async _call(le,{speaker_embeddings:J=null}={}){return this.processor?this._call_text_to_spectrogram(le,{speaker_embeddings:J}):this._call_text_to_waveform(le)}async _call_text_to_waveform(le){const J=this.tokenizer(le,{padding:!0,truncation:!0}),{waveform:be}=await this.model(J),Ae=this.model.config.sampling_rate;return new h.RawAudio(be.data,Ae)}async _call_text_to_spectrogram(le,{speaker_embeddings:J}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await i.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),(typeof J=="string"||J instanceof URL)&&(J=new Float32Array(await(await fetch(J)).arrayBuffer())),J instanceof Float32Array)J=new _.Tensor("float32",J,[1,J.length]);else if(!(J instanceof _.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:be}=this.tokenizer(le,{padding:!0,truncation:!0}),{waveform:Ae}=await this.model.generate_speech(be,J,{vocoder:this.vocoder}),Ne=this.processor.feature_extractor.config.sampling_rate;return new h.RawAudio(Ae.data,Ne)}}class G extends x{constructor(le){super(le)}async _call(le){const J=await p(le),be=await this.processor(J),Ae=await this.model(be),Ne=[];for(const De of Ae.reconstruction){const xe=De.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");Ne.push(m.RawImage.fromTensor(xe))}return Ne.length>1?Ne:Ne[0]}}class fe extends x{constructor(le){super(le)}async _call(le){const J=await p(le),be=await this.processor(J),{predicted_depth:Ae}=await this.model(be),Ne=[];for(let De=0;De<J.length;++De){const xe=Ae[De],[Ve,Ee]=xe.dims.slice(-2),[Ge,Ye]=J[De].size,_t=(await(0,_.interpolate_4d)(xe.view(1,1,Ve,Ee),{size:[Ye,Ge],mode:"bilinear"})).view(Ye,Ge),Re=_t.min().item(),xt=_t.max().item(),st=_t.sub(Re).div_(xt-Re).mul_(255).to("uint8").unsqueeze(0),nt=m.RawImage.fromTensor(st);Ne.push({predicted_depth:_t,depth:nt})}return Ne.length>1?Ne:Ne[0]}}const Te=Object.freeze({"text-classification":{tokenizer:a.AutoTokenizer,pipeline:L,model:i.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:a.AutoTokenizer,pipeline:T,model:i.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:a.AutoTokenizer,pipeline:E,model:i.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:a.AutoTokenizer,pipeline:I,model:i.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:a.AutoTokenizer,pipeline:S,model:i.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:a.AutoTokenizer,pipeline:k,model:i.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:a.AutoTokenizer,pipeline:P,model:i.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:a.AutoTokenizer,pipeline:D,model:i.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:a.AutoTokenizer,pipeline:V,model:i.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:ee,model:i.AutoModelForAudioClassification,processor:l.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:a.AutoTokenizer,pipeline:H,model:i.AutoModel,processor:l.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:a.AutoTokenizer,pipeline:oe,model:[i.AutoModelForSpeechSeq2Seq,i.AutoModelForCTC],processor:l.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:a.AutoTokenizer,pipeline:Q,model:[i.AutoModelForTextToWaveform,i.AutoModelForTextToSpectrogram],processor:[l.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:a.AutoTokenizer,pipeline:ae,model:i.AutoModelForVision2Seq,processor:l.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:W,model:i.AutoModelForImageClassification,processor:l.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:te,model:[i.AutoModelForImageSegmentation,i.AutoModelForSemanticSegmentation,i.AutoModelForUniversalSegmentation],processor:l.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"background-removal":{pipeline:ie,model:[i.AutoModelForImageSegmentation,i.AutoModelForSemanticSegmentation,i.AutoModelForUniversalSegmentation],processor:l.AutoProcessor,default:{model:"Xenova/modnet"},type:"image"},"zero-shot-image-classification":{tokenizer:a.AutoTokenizer,pipeline:_e,model:i.AutoModel,processor:l.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:q,model:i.AutoModelForObjectDetection,processor:l.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:a.AutoTokenizer,pipeline:B,model:i.AutoModelForZeroShotObjectDetection,processor:l.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:a.AutoTokenizer,pipeline:R,model:i.AutoModelForDocumentQuestionAnswering,processor:l.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:G,model:i.AutoModelForImageToImage,processor:l.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:fe,model:i.AutoModelForDepthEstimation,processor:l.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:a.AutoTokenizer,pipeline:U,model:i.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:l.AutoProcessor,pipeline:ne,model:[i.AutoModelForImageFeatureExtraction,i.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),ze=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function Ue(je,le=null,{progress_callback:J=null,config:be=null,cache_dir:Ae=null,local_files_only:Ne=!1,revision:De="main",device:xe=null,dtype:Ve=null,subfolder:Ee="onnx",use_external_data_format:Ge=null,model_file_name:Ye=null,session_options:_t={}}={}){je=ze[je]??je;const Re=Te[je.split("_",1)[0]];if(!Re)throw Error(`Unsupported pipeline: ${je}. Must be one of [${Object.keys(Te)}]`);le||(le=Re.default.model,console.log(`No model specified. Using default model: "${le}".`));const xt={progress_callback:J,config:be,cache_dir:Ae,local_files_only:Ne,revision:De,device:xe,dtype:Ve,subfolder:Ee,use_external_data_format:Ge,model_file_name:Ye,session_options:_t},st=new Map([["tokenizer",Re.tokenizer],["model",Re.model],["processor",Re.processor]]),nt=await ft(st,le,xt);nt.task=je,(0,d.dispatchCallback)(J,{status:"ready",task:je,model:le});const ct=Re.pipeline;return new ct(nt)}async function ft(je,le,J){const be=Object.create(null),Ae=[];for(const[Ne,De]of je.entries()){if(!De)continue;let xe;Array.isArray(De)?xe=new Promise(async(Ve,Ee)=>{let Ge;for(const Ye of De){if(Ye===null){Ve(null);return}try{Ve(await Ye.from_pretrained(le,J));return}catch(_t){if(_t.message?.includes("Unsupported model type"))Ge=_t;else if(_t.message?.includes("Could not locate file"))Ge=_t;else{Ee(_t);return}}}Ee(Ge)}):xe=De.from_pretrained(le,J),be[Ne]=xe,Ae.push(xe)}await Promise.all(Ae);for(const[Ne,De]of Object.entries(be))be[Ne]=await De;return be}}),"./src/tokenizers.js":((e,n,t)=>{t.r(n),t.d(n,{AlbertTokenizer:()=>En,AutoTokenizer:()=>Si,BartTokenizer:()=>qt,BertTokenizer:()=>Zs,BlenderbotSmallTokenizer:()=>$n,BlenderbotTokenizer:()=>Et,BloomTokenizer:()=>Sn,CLIPTokenizer:()=>Na,CamembertTokenizer:()=>Qe,CodeGenTokenizer:()=>Gs,CodeLlamaTokenizer:()=>pr,CohereTokenizer:()=>Gr,ConvBertTokenizer:()=>ue,DebertaTokenizer:()=>z,DebertaV2Tokenizer:()=>ce,DistilBertTokenizer:()=>ke,ElectraTokenizer:()=>At,Ernie4_5_Tokenizer:()=>Ei,EsmTokenizer:()=>ya,FalconTokenizer:()=>Vs,GPT2Tokenizer:()=>Zt,GPTNeoXTokenizer:()=>Xr,GemmaTokenizer:()=>ur,Grok1Tokenizer:()=>mr,HerbertTokenizer:()=>X,LlamaTokenizer:()=>hr,M2M100Tokenizer:()=>Yr,MBart50Tokenizer:()=>wn,MBartTokenizer:()=>On,MPNetTokenizer:()=>ea,MarianTokenizer:()=>et,MgpstrTokenizer:()=>Ua,MobileBertTokenizer:()=>Kt,NllbTokenizer:()=>Er,NougatTokenizer:()=>Cs,PreTrainedTokenizer:()=>zt,Qwen2Tokenizer:()=>Vr,RoFormerTokenizer:()=>pe,RobertaTokenizer:()=>Un,SiglipTokenizer:()=>Zr,SpeechT5Tokenizer:()=>va,SqueezeBertTokenizer:()=>Js,T5Tokenizer:()=>mt,TokenizerModel:()=>ne,VitsTokenizer:()=>Ps,Wav2Vec2CTCTokenizer:()=>ot,WhisperTokenizer:()=>ls,XLMRobertaTokenizer:()=>lr,XLMTokenizer:()=>Tt,is_chinese_char:()=>I});var a=t("./src/utils/generic.js"),i=t("./src/utils/core.js"),l=t("./src/utils/hub.js"),u=t("./src/utils/maths.js"),d=t("./src/utils/tensor.js"),f=t("./src/utils/data-structures.js"),h=t("./node_modules/@huggingface/jinja/dist/index.js"),_=t("./src/models/whisper/common_whisper.js");async function m(we,F){const se=await Promise.all([(0,l.getModelJSON)(we,"tokenizer.json",!0,F),(0,l.getModelJSON)(we,"tokenizer_config.json",!0,F)]);return F.legacy!==null&&(se[1].legacy=F.legacy),se}function p(we,F){const se=[];let de=0;for(const me of we.matchAll(F)){const Ie=me[0];de<me.index&&se.push(we.slice(de,me.index)),Ie.length>0&&se.push(Ie),de=me.index+Ie.length}return de<we.length&&se.push(we.slice(de)),se}function y(we,F=!0){if(we.Regex!==void 0){let se=we.Regex.replace(/\\([#&~])/g,"$1");for(const[de,me]of V)se=se.replaceAll(de,me);return new RegExp(se,"gu")}else if(we.String!==void 0){const se=(0,i.escapeRegExp)(we.String);return new RegExp(F?se:`(${se})`,"gu")}else return console.warn("Unknown pattern type:",we),null}function v(we){return new Map(Object.entries(we))}function x(we){const F=we.dims;switch(F.length){case 1:return we.tolist();case 2:if(F[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return we.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${F.length}.`)}}function L(we){return we.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function T(we){return we.replace(new RegExp("\\p{M}","gu"),"")}function E(we){return T(we.toLowerCase())}function I(we){return we>=19968&&we<=40959||we>=13312&&we<=19903||we>=131072&&we<=173791||we>=173824&&we<=177983||we>=177984&&we<=178207||we>=178208&&we<=183983||we>=63744&&we<=64255||we>=194560&&we<=195103}function P(we,F,se){const de=[];let me=0;for(;me<we.length;){if(de.push(we[me]),(F.get(we[me])??se)!==se){++me;continue}for(;++me<we.length&&(F.get(we[me])??se)===se;)F.get(de.at(-1))!==se&&(de[de.length-1]+=we[me])}return de}function S(we){return we.match(/\S+/g)||[]}const k="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",C=new RegExp(`^[${k}]+$`,"gu"),D=".,!?",V=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\s|[${D}])]+`,` ?[^\\s${D}]+`]]);class U{constructor(F){this.content=F.content,this.id=F.id,this.single_word=F.single_word??!1,this.lstrip=F.lstrip??!1,this.rstrip=F.rstrip??!1,this.special=F.special??!1,this.normalized=F.normalized??null}}class ne extends a.Callable{constructor(F){super(),this.config=F,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(F,...se){switch(F.type){case"WordPiece":return new ee(F);case"Unigram":return new H(F,...se);case"BPE":return new W(F);default:if(F.vocab)return Array.isArray(F.vocab)?new H(F,...se):Object.hasOwn(F,"continuing_subword_prefix")&&Object.hasOwn(F,"unk_token")?Object.hasOwn(F,"merges")?new W(F):new ee(F):new te(F,...se);throw new Error(`Unknown TokenizerModel type: ${F.type}`)}}_call(F){return F=this.encode(F),this.fuse_unk&&(F=P(F,this.tokens_to_ids,this.unk_token_id)),F}encode(F){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(F){return F.map(se=>this.tokens_to_ids.get(se)??this.unk_token_id)}convert_ids_to_tokens(F){return F.map(se=>this.vocab[se]??this.unk_token)}}class ee extends ne{constructor(F){super(F),this.tokens_to_ids=v(F.vocab),this.unk_token_id=this.tokens_to_ids.get(F.unk_token),this.unk_token=F.unk_token,this.max_input_chars_per_word=F.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[se,de]of this.tokens_to_ids)this.vocab[de]=se}encode(F){const se=[];for(const de of F){const me=[...de];if(me.length>this.max_input_chars_per_word){se.push(this.unk_token);continue}let Ie=!1,Ke=0;const gt=[];for(;Ke<me.length;){let vt=me.length,wt=null;for(;Ke<vt;){let dt=me.slice(Ke,vt).join("");if(Ke>0&&(dt=this.config.continuing_subword_prefix+dt),this.tokens_to_ids.has(dt)){wt=dt;break}--vt}if(wt===null){Ie=!0;break}gt.push(wt),Ke=vt}Ie?se.push(this.unk_token):se.push(...gt)}return se}}class H extends ne{constructor(F,se){super(F);const de=F.vocab.length;this.vocab=new Array(de),this.scores=new Array(de);for(let me=0;me<de;++me)[this.vocab[me],this.scores[me]]=F.vocab[me];this.unk_token_id=F.unk_id,this.unk_token=this.vocab[F.unk_id],this.tokens_to_ids=new Map(this.vocab.map((me,Ie)=>[me,Ie])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=se.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,u.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new f.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(F){const se=F.chars,de=1;let me=0;for(;me<se.length;){let Ie=!1;const Ke=se.slice(me).join(""),gt=this.trie.commonPrefixSearch(Ke);for(const vt of gt){const wt=this.tokens_to_ids.get(vt),dt=this.scores[wt],Qt=(0,i.len)(vt);F.insert(me,Qt,dt,wt),!Ie&&Qt===de&&(Ie=!0)}Ie||F.insert(me,de,this.unk_score,this.unk_token_id),me+=de}}tokenize(F){const se=new f.TokenLattice(F,this.bos_token_id,this.eos_token_id);return this.populateNodes(se),se.tokens()}encode(F){const se=[];for(const de of F){const me=this.tokenize(de);se.push(...me)}return se}}const oe=(()=>{const we=[...Array.from({length:94},(me,Ie)=>Ie+33),...Array.from({length:12},(me,Ie)=>Ie+161),...Array.from({length:82},(me,Ie)=>Ie+174)],F=we.slice();let se=0;for(let me=0;me<256;++me)we.includes(me)||(we.push(me),F.push(256+se),se+=1);const de=F.map(me=>String.fromCharCode(me));return Object.fromEntries(we.map((me,Ie)=>[me,de[Ie]]))})(),ae=(0,i.reverseDictionary)(oe);class W extends ne{constructor(F){super(F),this.tokens_to_ids=v(F.vocab),this.unk_token_id=this.tokens_to_ids.get(F.unk_token),this.unk_token=F.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[de,me]of this.tokens_to_ids)this.vocab[me]=de;const se=Array.isArray(F.merges[0]);this.merges=se?F.merges:F.merges.map(de=>de.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((de,me)=>[JSON.stringify(de),me])),this.end_of_word_suffix=F.end_of_word_suffix,this.continuing_subword_suffix=F.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.max_length_to_cache=256,this.cache_capacity=1e4,this.cache=new f.LRUCache(this.cache_capacity)}clear_cache(){this.cache.clear()}bpe(F){if(F.length===0)return[];const se=this.cache.get(F);if(se!==void 0)return se;const de=Array.from(F);this.end_of_word_suffix&&(de[de.length-1]+=this.end_of_word_suffix);let me=[];if(de.length>1){const Ie=new f.PriorityQueue((vt,wt)=>vt.score<wt.score);let Ke={token:de[0],bias:0,prev:null,next:null},gt=Ke;for(let vt=1;vt<de.length;++vt){const wt={bias:vt/de.length,token:de[vt],prev:gt,next:null};gt.next=wt,this._add_node(Ie,gt),gt=wt}for(;!Ie.isEmpty();){const vt=Ie.pop();if(vt.deleted||!vt.next||vt.next.deleted)continue;if(vt.deleted=!0,vt.next.deleted=!0,vt.prev){const dt={...vt.prev};vt.prev.deleted=!0,vt.prev=dt,dt.prev?dt.prev.next=dt:Ke=dt}const wt={token:vt.token+vt.next.token,bias:vt.bias,prev:vt.prev,next:vt.next.next};wt.prev?(wt.prev.next=wt,this._add_node(Ie,wt.prev)):Ke=wt,wt.next&&(wt.next.prev=wt,this._add_node(Ie,wt))}for(let vt=Ke;vt!==null;vt=vt.next)me.push(vt.token)}else me=de;if(this.continuing_subword_suffix)for(let Ie=0;Ie<me.length-1;++Ie)me[Ie]+=this.continuing_subword_suffix;return F.length<this.max_length_to_cache&&this.cache.put(F,me),me}_add_node(F,se){const de=this.bpe_ranks.get(JSON.stringify([se.token,se.next.token]));de!==void 0&&(se.score=de+se.bias,F.push(se))}encode(F){const se=[];for(const de of F){if(this.ignore_merges&&this.tokens_to_ids.has(de)){se.push(de);continue}const me=this.bpe(de);for(const Ie of me)if(this.tokens_to_ids.has(Ie))se.push(Ie);else if(this.byte_fallback){const Ke=Array.from(this.text_encoder.encode(Ie)).map(gt=>`<0x${gt.toString(16).toUpperCase().padStart(2,"0")}>`);Ke.every(gt=>this.tokens_to_ids.has(gt))?se.push(...Ke):se.push(this.unk_token)}else se.push(this.unk_token)}return se}}class te extends ne{constructor(F,se){super(F),this.tokens_to_ids=v(se.target_lang?F.vocab[se.target_lang]:F.vocab),this.bos_token=se.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=se.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=se.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=se.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[de,me]of this.tokens_to_ids)this.vocab[me]=de}encode(F){return F}}class ie extends a.Callable{constructor(F){super(),this.config=F}static fromConfig(F){if(F===null)return null;switch(F.type){case"BertNormalizer":return new je(F);case"Precompiled":return new Br(F);case"Sequence":return new ft(F);case"Replace":return new _e(F);case"NFC":return new B(F);case"NFD":return new R(F);case"NFKC":return new Q(F);case"NFKD":return new G(F);case"Strip":return new fe(F);case"StripAccents":return new Te(F);case"Lowercase":return new ze(F);case"Prepend":return new Ue(F);default:throw new Error(`Unknown Normalizer type: ${F.type}`)}}normalize(F){throw Error("normalize should be implemented in subclass.")}_call(F){return this.normalize(F)}}class _e extends ie{normalize(F){const se=y(this.config.pattern);return se===null?F:F.replaceAll(se,this.config.content)}}class q extends ie{form=void 0;normalize(F){return F=F.normalize(this.form),F}}class B extends q{form="NFC"}class R extends q{form="NFD"}class Q extends q{form="NFKC"}class G extends q{form="NFKD"}class fe extends ie{normalize(F){return this.config.strip_left&&this.config.strip_right?F=F.trim():(this.config.strip_left&&(F=F.trimStart()),this.config.strip_right&&(F=F.trimEnd())),F}}class Te extends ie{normalize(F){return F=T(F),F}}class ze extends ie{normalize(F){return F=F.toLowerCase(),F}}class Ue extends ie{normalize(F){return F=this.config.prepend+F,F}}class ft extends ie{constructor(F){super(F),this.normalizers=F.normalizers.map(se=>ie.fromConfig(se))}normalize(F){return this.normalizers.reduce((se,de)=>de.normalize(se),F)}}class je extends ie{_tokenize_chinese_chars(F){const se=[];for(let de=0;de<F.length;++de){const me=F[de],Ie=me.charCodeAt(0);I(Ie)?(se.push(" "),se.push(me),se.push(" ")):se.push(me)}return se.join("")}stripAccents(F){return F.normalize("NFD").replace(new RegExp("\\p{Mn}","gu"),"")}_is_control(F){switch(F){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(F)}}_clean_text(F){const se=[];for(const de of F){const me=de.charCodeAt(0);me===0||me===65533||this._is_control(de)||(/^\s$/.test(de)?se.push(" "):se.push(de))}return se.join("")}normalize(F){return this.config.clean_text&&(F=this._clean_text(F)),this.config.handle_chinese_chars&&(F=this._tokenize_chinese_chars(F)),this.config.lowercase?(F=F.toLowerCase(),this.config.strip_accents!==!1&&(F=this.stripAccents(F))):this.config.strip_accents&&(F=this.stripAccents(F)),F}}class le extends a.Callable{static fromConfig(F){if(F===null)return null;switch(F.type){case"BertPreTokenizer":return new J(F);case"Sequence":return new $r(F);case"Whitespace":return new er(F);case"WhitespaceSplit":return new jr(F);case"Metaspace":return new or(F);case"ByteLevel":return new be(F);case"Split":return new Ae(F);case"Punctuation":return new Ne(F);case"Digits":return new De(F);case"Replace":return new ja(F);default:throw new Error(`Unknown PreTokenizer type: ${F.type}`)}}pre_tokenize_text(F,se){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(F,se){return(Array.isArray(F)?F.map(de=>this.pre_tokenize_text(de,se)):this.pre_tokenize_text(F,se)).flat()}_call(F,se){return this.pre_tokenize(F,se)}}class J extends le{constructor(F){super(),this.pattern=new RegExp(`[^\\s${k}]+|[${k}]`,"gu")}pre_tokenize_text(F,se){return F.trim().match(this.pattern)||[]}}class be extends le{constructor(F){super(),this.config=F,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=oe,this.text_encoder=new TextEncoder}pre_tokenize_text(F,se){return this.add_prefix_space&&!F.startsWith(" ")&&(F=" "+F),(this.use_regex?F.match(this.pattern)||[]:[F]).map(me=>Array.from(this.text_encoder.encode(me),Ie=>this.byte_encoder[Ie]).join(""))}}class Ae extends le{constructor(F){super(),this.config=F,this.pattern=y(this.config.pattern,this.config.invert)}pre_tokenize_text(F,se){return this.pattern===null?[]:this.config.invert?F.match(this.pattern)||[]:this.config.behavior?.toLowerCase()==="removed"?F.split(this.pattern).filter(de=>de):p(F,this.pattern)}}class Ne extends le{constructor(F){super(),this.config=F,this.pattern=new RegExp(`[^${k}]+|[${k}]+`,"gu")}pre_tokenize_text(F,se){return F.match(this.pattern)||[]}}class De extends le{constructor(F){super(),this.config=F;const se=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(se,"gu")}pre_tokenize_text(F,se){return F.match(this.pattern)||[]}}class xe extends a.Callable{constructor(F){super(),this.config=F}static fromConfig(F){if(F===null)return null;switch(F.type){case"TemplateProcessing":return new Ge(F);case"ByteLevel":return new Ye(F);case"RobertaProcessing":return new Ee(F);case"BertProcessing":return new Ve(F);case"Sequence":return new _t(F);default:throw new Error(`Unknown PostProcessor type: ${F.type}`)}}post_process(F,...se){throw Error("post_process should be implemented in subclass.")}_call(F,...se){return this.post_process(F,...se)}}class Ve extends xe{constructor(F){super(F),this.cls=F.cls[0],this.sep=F.sep[0]}post_process(F,se=null,{add_special_tokens:de=!0}={}){de&&(F=(0,i.mergeArrays)([this.cls],F,[this.sep]));let me=new Array(F.length).fill(0);if(se!==null){const Ie=de&&this instanceof Ee?[this.sep]:[],Ke=de?[this.sep]:[];F=(0,i.mergeArrays)(F,Ie,se,Ke),me=(0,i.mergeArrays)(me,new Array(se.length+Ie.length+Ke.length).fill(1))}return{tokens:F,token_type_ids:me}}}class Ee extends Ve{}class Ge extends xe{constructor(F){super(F),this.single=F.single,this.pair=F.pair}post_process(F,se=null,{add_special_tokens:de=!0}={}){const me=se===null?this.single:this.pair;let Ie=[],Ke=[];for(const gt of me)"SpecialToken"in gt?de&&(Ie.push(gt.SpecialToken.id),Ke.push(gt.SpecialToken.type_id)):"Sequence"in gt&&(gt.Sequence.id==="A"?(Ie=(0,i.mergeArrays)(Ie,F),Ke=(0,i.mergeArrays)(Ke,new Array(F.length).fill(gt.Sequence.type_id))):gt.Sequence.id==="B"&&(Ie=(0,i.mergeArrays)(Ie,se),Ke=(0,i.mergeArrays)(Ke,new Array(se.length).fill(gt.Sequence.type_id))));return{tokens:Ie,token_type_ids:Ke}}}class Ye extends xe{post_process(F,se=null){return se&&(F=(0,i.mergeArrays)(F,se)),{tokens:F}}}class _t extends xe{constructor(F){super(F),this.processors=F.processors.map(se=>xe.fromConfig(se))}post_process(F,se=null,de={}){let me;for(const Ie of this.processors)if(Ie instanceof Ye)F=Ie.post_process(F).tokens,se&&(se=Ie.post_process(se).tokens);else{const Ke=Ie.post_process(F,se,de);F=Ke.tokens,me=Ke.token_type_ids}return{tokens:F,token_type_ids:me}}}class Re extends a.Callable{constructor(F){super(),this.config=F,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=F.trim_offsets}static fromConfig(F){if(F===null)return null;switch(F.type){case"WordPiece":return new pt(F);case"Metaspace":return new Or(F);case"ByteLevel":return new lt(F);case"Replace":return new xt(F);case"ByteFallback":return new st(F);case"Fuse":return new nt(F);case"Strip":return new ct(F);case"Sequence":return new tn(F);case"CTC":return new Mt(F);case"BPEDecoder":return new an(F);default:throw new Error(`Unknown Decoder type: ${F.type}`)}}_call(F){return this.decode(F)}decode(F){return this.decode_chain(F).join("")}decode_chain(F){throw Error("`decode_chain` should be implemented in subclass.")}}class xt extends Re{decode_chain(F){const se=y(this.config.pattern);return se===null?F:F.map(de=>de.replaceAll(se,this.config.content))}}class st extends Re{constructor(F){super(F),this.text_decoder=new TextDecoder}decode_chain(F){const se=[];let de=[];for(const me of F){let Ie=null;if(me.length===6&&me.startsWith("<0x")&&me.endsWith(">")){const Ke=parseInt(me.slice(3,5),16);isNaN(Ke)||(Ie=Ke)}if(Ie!==null)de.push(Ie);else{if(de.length>0){const Ke=this.text_decoder.decode(Uint8Array.from(de));se.push(Ke),de=[]}se.push(me)}}if(de.length>0){const me=this.text_decoder.decode(Uint8Array.from(de));se.push(me),de=[]}return se}}class nt extends Re{decode_chain(F){return[F.join("")]}}class ct extends Re{constructor(F){super(F),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(F){return F.map(se=>{let de=0;for(let Ie=0;Ie<this.start&&se[Ie]===this.content;++Ie){de=Ie+1;continue}let me=se.length;for(let Ie=0;Ie<this.stop;++Ie){const Ke=se.length-Ie-1;if(se[Ke]===this.content){me=Ke;continue}else break}return se.slice(de,me)})}}class pt extends Re{constructor(F){super(F),this.cleanup=F.cleanup}decode_chain(F){return F.map((se,de)=>(de!==0&&(se.startsWith(this.config.prefix)?se=se.replace(this.config.prefix,""):se=" "+se),this.cleanup&&(se=L(se)),se))}}class lt extends Re{constructor(F){super(F),this.byte_decoder=ae,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(F){const se=F.join(""),de=new Uint8Array([...se].map(Ie=>this.byte_decoder[Ie]));return this.text_decoder.decode(de)}decode_chain(F){const se=[];let de=[];for(const me of F)this.added_tokens.find(Ie=>Ie.content===me)!==void 0?(de.length>0&&(se.push(this.convert_tokens_to_string(de)),de=[]),se.push(me)):de.push(me);return de.length>0&&se.push(this.convert_tokens_to_string(de)),se}}class Mt extends Re{constructor(F){super(F),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(F){if(F.length===0)return"";const se=[F[0]];for(let Ie=1;Ie<F.length;++Ie)F[Ie]!==se.at(-1)&&se.push(F[Ie]);let me=se.filter(Ie=>Ie!==this.pad_token).join("");return this.cleanup&&(me=L(me).replaceAll(this.word_delimiter_token," ").trim()),me}decode_chain(F){return[this.convert_tokens_to_string(F)]}}class tn extends Re{constructor(F){super(F),this.decoders=F.decoders.map(se=>Re.fromConfig(se))}decode_chain(F){return this.decoders.reduce((se,de)=>de.decode_chain(se),F)}}class an extends Re{constructor(F){super(F),this.suffix=this.config.suffix}decode_chain(F){return F.map((se,de)=>se.replaceAll(this.suffix,de===F.length-1?"":" "))}}class Ft extends Re{decode_chain(F){let se="";for(let de=1;de<F.length;de+=2)se+=F[de];return[se]}}class or extends le{constructor(F){super(),this.addPrefixSpace=F.add_prefix_space,this.replacement=F.replacement,this.strRep=F.str_rep||this.replacement,this.prepend_scheme=F.prepend_scheme??"always"}pre_tokenize_text(F,{section_index:se=void 0}={}){let de=F.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!de.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&se===0)&&(de=this.strRep+de),[de]}}class Or extends Re{constructor(F){super(F),this.addPrefixSpace=F.add_prefix_space,this.replacement=F.replacement}decode_chain(F){const se=[];for(let de=0;de<F.length;++de){let me=F[de].replaceAll(this.replacement," ");this.addPrefixSpace&&de==0&&me.startsWith(" ")&&(me=me.substring(1)),se.push(me)}return se}}class Br extends ie{constructor(F){super(F),this.charsmap=F.precompiled_charsmap}normalize(F){return F=F.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),F=F.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," "),F.includes("")?F=F.split("").map(de=>de.normalize("NFKC")).join(""):F=F.normalize("NFKC"),F}}class $r extends le{constructor(F){super(),this.tokenizers=F.pretokenizers.map(se=>le.fromConfig(se))}pre_tokenize_text(F,se){return this.tokenizers.reduce((de,me)=>me.pre_tokenize(de,se),[F])}}class er extends le{constructor(F){super()}pre_tokenize_text(F,se){return F.match(/\w+|[^\w\s]+/g)||[]}}class jr extends le{constructor(F){super()}pre_tokenize_text(F,se){return S(F)}}class ja extends le{constructor(F){super(),this.config=F,this.pattern=y(this.config.pattern),this.content=this.config.content}pre_tokenize_text(F,se){return this.pattern===null?[F]:[F.replaceAll(this.pattern,this.config.content)]}}const ga=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function Es(we,F,se,de){for(const me of Object.keys(we)){const Ie=F-we[me].length,Ke=se(me),gt=new Array(Ie).fill(Ke);we[me]=de==="right"?(0,i.mergeArrays)(we[me],gt):(0,i.mergeArrays)(gt,we[me])}}function Ss(we,F){for(const se of Object.keys(we))we[se].length=F}class zt extends a.Callable{return_token_type_ids=!1;padding_side="right";constructor(F,se){super(),this.config=se,this.normalizer=ie.fromConfig(F.normalizer),this.pre_tokenizer=le.fromConfig(F.pre_tokenizer),this.model=ne.fromConfig(F.model,se),this.post_processor=xe.fromConfig(F.post_processor),this.decoder=Re.fromConfig(F.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const de of F.added_tokens){const me=new U(de);this.added_tokens.push(me),this.model.tokens_to_ids.set(me.content,me.id),this.model.vocab[me.id]=me.content,me.special&&(this.special_tokens.push(me.content),this.all_special_ids.push(me.id))}if(this.additional_special_tokens=se.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_splitter=new f.DictionarySplitter(this.added_tokens.map(de=>de.content)),this.added_tokens_map=new Map(this.added_tokens.map(de=>[de.content,de])),this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=se.model_max_length,this.remove_space=se.remove_space,this.clean_up_tokenization_spaces=se.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=se.do_lowercase_and_remove_accent??!1,se.padding_side&&(this.padding_side=se.padding_side),this.add_bos_token=se.add_bos_token,this.add_eos_token=se.add_eos_token,this.legacy=!1,this.chat_template=se.chat_template??null,Array.isArray(this.chat_template)){const de=Object.create(null);for(const{name:me,template:Ie}of this.chat_template){if(typeof me!="string"||typeof Ie!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');de[me]=Ie}this.chat_template=de}this._compiled_template_cache=new Map}getToken(...F){for(const se of F){const de=this.config[se];if(de)if(typeof de=="object"){if(de.__type==="AddedToken")return de.content;throw Error(`Unknown token: ${de}`)}else return de}return null}static async from_pretrained(F,{progress_callback:se=null,config:de=null,cache_dir:me=null,local_files_only:Ie=!1,revision:Ke="main",legacy:gt=null}={}){const vt=await m(F,{progress_callback:se,config:de,cache_dir:me,local_files_only:Ie,revision:Ke,legacy:gt});return new this(...vt)}_call(F,{text_pair:se=null,add_special_tokens:de=!0,padding:me=!1,truncation:Ie=null,max_length:Ke=null,return_tensor:gt=!0,return_token_type_ids:vt=null}={}){const wt=Array.isArray(F);let dt;if(wt){if(F.length===0)throw Error("text array must be non-empty");if(se!==null){if(Array.isArray(se)){if(F.length!==se.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");dt=F.map((Ut,Dn)=>this._encode_plus(Ut,{text_pair:se[Dn],add_special_tokens:de,return_token_type_ids:vt}))}else dt=F.map(Ut=>this._encode_plus(Ut,{add_special_tokens:de,return_token_type_ids:vt}))}else{if(F==null)throw Error("text may not be null or undefined");if(Array.isArray(se))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");dt=[this._encode_plus(F,{text_pair:se,add_special_tokens:de,return_token_type_ids:vt})]}if(Ke===null?Ke=this.model_max_length:Ie===null&&(me===!0?(console.warn("`max_length` is ignored when `padding: true` and there is no truncation strategy. To pad to max length, use `padding: 'max_length'`."),Ke=this.model_max_length):me===!1&&(console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation: true` to explicitly truncate examples to max length."),Ie=!0)),me===!0&&(Ke=Math.min((0,u.max)(dt.map(Ut=>Ut.input_ids.length))[0],Ke??1/0)),Ke=Math.min(Ke,this.model_max_length??1/0),me||Ie)for(let Ut=0;Ut<dt.length;++Ut)dt[Ut].input_ids.length!==Ke&&(dt[Ut].input_ids.length>Ke?Ie&&Ss(dt[Ut],Ke):me&&Es(dt[Ut],Ke,Dn=>Dn==="input_ids"?this.pad_token_id:0,this.padding_side));const Qt={};if(gt){if(!(me&&Ie)&&dt.some(Dn=>{for(const Kn of Object.keys(Dn))if(Dn[Kn].length!==dt[0][Kn]?.length)return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const Ut=[dt.length,dt[0].input_ids.length];for(const Dn of Object.keys(dt[0]))Qt[Dn]=new d.Tensor("int64",BigInt64Array.from(dt.flatMap(Kn=>Kn[Dn]).map(BigInt)),Ut)}else{for(const Ut of Object.keys(dt[0]))Qt[Ut]=dt.map(Dn=>Dn[Ut]);if(!wt)for(const Ut of Object.keys(Qt))Qt[Ut]=Qt[Ut][0]}return Qt}_encode_text(F){if(F===null)return null;const se=this.added_tokens_splitter.split(F);for(let me=0;me<se.length;++me){const Ie=this.added_tokens_map.get(se[me]);Ie&&(Ie.lstrip&&me>0&&(se[me-1]=se[me-1].trimEnd()),Ie.rstrip&&me<se.length-1&&(se[me+1]=se[me+1].trimStart()))}return se.flatMap((me,Ie)=>{if(me.length===0)return[];if(this.added_tokens_map.has(me))return[me];if(this.remove_space===!0&&(me=me.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(me=E(me)),this.normalizer!==null&&(me=this.normalizer(me)),me.length===0)return[];const Ke=this.pre_tokenizer!==null?this.pre_tokenizer(me,{section_index:Ie}):[me];return this.model(Ke)})}_encode_plus(F,{text_pair:se=null,add_special_tokens:de=!0,return_token_type_ids:me=null}={}){const{tokens:Ie,token_type_ids:Ke}=this._tokenize_helper(F,{pair:se,add_special_tokens:de}),gt=this.model.convert_tokens_to_ids(Ie),vt={input_ids:gt,attention_mask:new Array(gt.length).fill(1)};return(me??this.return_token_type_ids)&&Ke&&(vt.token_type_ids=Ke),vt}_tokenize_helper(F,{pair:se=null,add_special_tokens:de=!1}={}){const me=this._encode_text(F),Ie=this._encode_text(se);return this.post_processor?this.post_processor(me,Ie,{add_special_tokens:de}):{tokens:(0,i.mergeArrays)(me??[],Ie??[])}}tokenize(F,{pair:se=null,add_special_tokens:de=!1}={}){return this._tokenize_helper(F,{pair:se,add_special_tokens:de}).tokens}encode(F,{text_pair:se=null,add_special_tokens:de=!0,return_token_type_ids:me=null}={}){return this._encode_plus(F,{text_pair:se,add_special_tokens:de,return_token_type_ids:me}).input_ids}batch_decode(F,se={}){return F instanceof d.Tensor&&(F=F.tolist()),F.map(de=>this.decode(de,se))}decode(F,se={}){if(F instanceof d.Tensor&&(F=x(F)),!Array.isArray(F)||F.length===0||!(0,i.isIntegralNumber)(F[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(F,se)}decode_single(F,{skip_special_tokens:se=!1,clean_up_tokenization_spaces:de=null}){let me=this.model.convert_ids_to_tokens(F);se&&(me=me.filter(Ke=>!this.special_tokens.includes(Ke)));let Ie=this.decoder?this.decoder(me):me.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(Ie=Ie.replaceAll(this.decoder.end_of_word_suffix," "),se&&(Ie=Ie.trim())),(de??this.clean_up_tokenization_spaces)&&(Ie=L(Ie)),Ie}get_chat_template({chat_template:F=null,tools:se=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const de=this.chat_template;if(F!==null&&Object.hasOwn(de,F))F=de[F];else if(F===null)if(se!==null&&"tool_use"in de)F=de.tool_use;else if("default"in de)F=de.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(de).sort()}.`)}else if(F===null)if(this.chat_template)F=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return F}apply_chat_template(F,{tools:se=null,documents:de=null,chat_template:me=null,add_generation_prompt:Ie=!1,tokenize:Ke=!0,padding:gt=!1,truncation:vt=!1,max_length:wt=null,return_tensor:dt=!0,return_dict:Qt=!1,tokenizer_kwargs:Ut={},...Dn}={}){if(me=this.get_chat_template({chat_template:me,tools:se}),typeof me!="string")throw Error(`chat_template must be a string, but got ${typeof me}`);let Kn=this._compiled_template_cache.get(me);Kn===void 0&&(Kn=new h.Template(me),this._compiled_template_cache.set(me,Kn));const jn=Object.create(null);for(const Cn of ga){const Wr=this.getToken(Cn);Wr&&(jn[Cn]=Wr)}const Vn=Kn.render({messages:F,add_generation_prompt:Ie,tools:se,documents:de,...jn,...Dn});if(Ke){const Cn=this._call(Vn,{add_special_tokens:!1,padding:gt,truncation:vt,max_length:wt,return_tensor:dt,...Ut});return Qt?Cn:Cn.input_ids}return Vn}}class Zs extends zt{return_token_type_ids=!0}class En extends zt{return_token_type_ids=!0}class Kt extends zt{return_token_type_ids=!0}class Js extends zt{return_token_type_ids=!0}class z extends zt{return_token_type_ids=!0}class ce extends zt{return_token_type_ids=!0}class X extends zt{return_token_type_ids=!0}class ue extends zt{return_token_type_ids=!0}class pe extends zt{return_token_type_ids=!0}class ke extends zt{}class Qe extends zt{}class Tt extends zt{return_token_type_ids=!0;constructor(F,se){super(F,se),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class At extends zt{return_token_type_ids=!0}class mt extends zt{}class Zt extends zt{}class qt extends zt{}class On extends zt{constructor(F,se){super(F,se),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(de=>this.languageRegex.test(de)),this.lang_to_token=de=>de}_build_translation_inputs(F,se,de){return tr(this,F,se,de)}}class wn extends On{}class Un extends zt{}class Sn extends zt{}const Bn="";class hr extends zt{padding_side="left";constructor(F,se){super(F,se),this.legacy=se.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new or({replacement:Bn,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(F){if(F===null)return null;if(this.legacy||F.length===0)return super._encode_text(F);let se=super._encode_text(Bn+F.replaceAll(Bn," "));return se.length>1&&se[0]===Bn&&this.special_tokens.includes(se[1])&&(se=se.slice(1)),se}}class pr extends zt{}class lr extends zt{}class ea extends zt{}class Vs extends zt{}class Xr extends zt{}class ya extends zt{}class Vr extends zt{}class ur extends zt{}class mr extends zt{}function tr(we,F,se,de){if(!("language_codes"in we)||!Array.isArray(we.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in we)||!(we.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in we)||typeof we.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const me=de.src_lang,Ie=de.tgt_lang;if(!we.language_codes.includes(Ie))throw new Error(`Target language code "${Ie}" is not valid. Must be one of: {${we.language_codes.join(", ")}}`);if(me!==void 0){if(!we.language_codes.includes(me))throw new Error(`Source language code "${me}" is not valid. Must be one of: {${we.language_codes.join(", ")}}`);for(const Ke of we.post_processor.config.single)if("SpecialToken"in Ke&&we.languageRegex.test(Ke.SpecialToken.id)){Ke.SpecialToken.id=we.lang_to_token(me);break}}return de.forced_bos_token_id=we.model.convert_tokens_to_ids([we.lang_to_token(Ie)])[0],we._call(F,se)}class Er extends zt{constructor(F,se){super(F,se),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(de=>this.languageRegex.test(de)),this.lang_to_token=de=>de}_build_translation_inputs(F,se,de){return tr(this,F,se,de)}}class Yr extends zt{constructor(F,se){super(F,se),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(de=>this.languageRegex.test(de)).map(de=>de.slice(2,-2)),this.lang_to_token=de=>`__${de}__`}_build_translation_inputs(F,se,de){return tr(this,F,se,de)}}class ls extends zt{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(F,{return_timestamps:se=!1,return_language:de=!1,time_precision:me=null,force_full_sequences:Ie=!0}={}){if(me===null)throw Error("Must specify time_precision");let Ke=null;const gt=se==="word";function vt(){return{language:Ke,timestamp:[null,null],text:""}}const wt=[];let dt=vt(),Qt=0;const Ut=this.timestamp_begin,Kn=Ut+1500;let jn=[],Vn=[],Cn=!1,Wr=null;const Dr=new Set(this.all_special_ids);for(const vn of F){const nr=vn.tokens,gr=gt?vn.token_timestamps:null;let ps=null,ms=Ut;if("stride"in vn){const[_n,Mn,Yn]=vn.stride;if(Qt-=Mn,Wr=_n-Yn,Mn&&(ms=Mn/me+Ut),Yn)for(let Nn=nr.length-1;Nn>=0;--Nn){const cs=Number(nr[Nn]);if(cs>=Ut){if(ps!==null&&(cs-Ut)*me<Wr)break;ps=cs}}}let rr=[],As=[];for(let _n=0;_n<nr.length;++_n){const Mn=Number(nr[_n]);if(Dr.has(Mn)){const Yn=this.decode([Mn]),Nn=_.WHISPER_LANGUAGE_MAPPING.get(Yn.slice(2,-2));if(Nn!==void 0){if(Ke!==null&&Nn!==Ke&&!se){jn.push(rr);const cs=this.findLongestCommonSequence(jn)[0],ba=this.decode(cs);dt.text=ba,wt.push(dt),jn=[],rr=[],dt=vt()}Ke=dt.language=Nn}}else if(Mn>=Ut&&Mn<=Kn){const Yn=(Mn-Ut)*me+Qt,Nn=(0,u.round)(Yn,2);if(ps!==null&&Mn>=ps)Cn=!0;else if(Cn||jn.length>0&&Mn<ms)Cn=!1;else if(dt.timestamp[0]===null)dt.timestamp[0]=Nn;else if(Nn!==dt.timestamp[0]){dt.timestamp[1]=Nn,jn.push(rr),gt&&Vn.push(As);const[cs,ba]=this.findLongestCommonSequence(jn,Vn),Ws=this.decode(cs);dt.text=Ws,gt&&(dt.words=this.collateWordTimestamps(cs,ba,Ke)),wt.push(dt),jn=[],rr=[],Vn=[],As=[],dt=vt()}}else if(rr.push(Mn),gt){let Yn=(0,u.round)(gr[_n]+Qt,2),Nn;if(_n+1<gr.length){Nn=(0,u.round)(gr[_n+1]+Qt,2);const cs=this.decode([Mn]);C.test(cs)&&(Nn=(0,u.round)(Math.min(Yn+me,Nn),2))}else Nn=null;As.push([Yn,Nn])}}if("stride"in vn){const[_n,Mn,Yn]=vn.stride;Qt+=_n-Yn}rr.length>0?(jn.push(rr),gt&&Vn.push(As)):jn.every(_n=>_n.length===0)&&(dt=vt(),jn=[],rr=[],Vn=[],As=[])}if(jn.length>0){if(Ie&&se)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[vn,nr]=this.findLongestCommonSequence(jn,Vn),gr=this.decode(vn);dt.text=gr,gt&&(dt.words=this.collateWordTimestamps(vn,nr,Ke)),wt.push(dt)}let _r=Object.create(null);const us=wt.map(vn=>vn.text).join("");if(se||de){for(let vn=0;vn<wt.length;++vn){const nr=wt[vn];se||delete nr.timestamp,de||delete nr.language}if(gt){const vn=[];for(const nr of wt)for(const gr of nr.words)vn.push(gr);_r={chunks:vn}}else _r={chunks:wt}}return[us,_r]}findLongestCommonSequence(F,se=null){let de=F[0],me=de.length,Ie=[];const Ke=Array.isArray(se)&&se.length>0;let gt=Ke?[]:null,vt=Ke?se[0]:null;for(let wt=1;wt<F.length;++wt){const dt=F[wt];let Qt=0,Ut=[me,me,0,0];const Dn=dt.length;for(let _r=1;_r<me+Dn;++_r){const us=Math.max(0,me-_r),vn=Math.min(me,me+Dn-_r),nr=de.slice(us,vn),gr=Math.max(0,_r-me),ps=Math.min(Dn,_r),ms=dt.slice(gr,ps);if(nr.length!==ms.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let rr;Ke?rr=nr.filter((Mn,Yn)=>Mn===ms[Yn]&&vt[us+Yn]<=se[wt][gr+Yn]).length:rr=nr.filter((Mn,Yn)=>Mn===ms[Yn]).length;const As=_r/1e4,_n=rr/_r+As;rr>1&&_n>Qt&&(Qt=_n,Ut=[us,vn,gr,ps])}const[Kn,jn,Vn,Cn]=Ut,Wr=Math.floor((jn+Kn)/2),Dr=Math.floor((Cn+Vn)/2);Ie.push(...de.slice(0,Wr)),de=dt.slice(Dr),me=de.length,Ke&&(gt.push(...vt.slice(0,Wr)),vt=se[wt].slice(Dr))}return Ie.push(...de),Ke?(gt.push(...vt),[Ie,gt]):[Ie,[]]}collateWordTimestamps(F,se,de){const[me,Ie,Ke]=this.combineTokensIntoWords(F,de),gt=[];for(let vt=0;vt<me.length;++vt){const wt=Ke[vt];gt.push({text:me[vt],timestamp:[se[wt.at(0)][0],se[wt.at(-1)][1]]})}return gt}combineTokensIntoWords(F,se,de=`"'([{-`,me=`"'.,!?:)]}`){se=se??"english";let Ie,Ke,gt;return["chinese","japanese","thai","lao","myanmar"].includes(se)?[Ie,Ke,gt]=this.splitTokensOnUnicode(F):[Ie,Ke,gt]=this.splitTokensOnSpaces(F),this.mergePunctuations(Ie,Ke,gt,de,me)}decode(F,se){let de;return se?.decode_with_timestamps?(F instanceof d.Tensor&&(F=x(F)),de=this.decodeWithTimestamps(F,se)):de=super.decode(F,se),de}decodeWithTimestamps(F,se){const de=se?.time_precision??.02,me=Array.from(this.all_special_ids).at(-1)+1;let Ie=[[]];for(let Ke of F)if(Ke=Number(Ke),Ke>=me){const gt=((Ke-me)*de).toFixed(2);Ie.push(`<|${gt}|>`),Ie.push([])}else Ie[Ie.length-1].push(Ke);return Ie=Ie.map(Ke=>typeof Ke=="string"?Ke:super.decode(Ke,se)),Ie.join("")}splitTokensOnUnicode(F){const se=this.decode(F,{decode_with_timestamps:!0}),de="",me=[],Ie=[],Ke=[];let gt=[],vt=[],wt=0;for(let dt=0;dt<F.length;++dt){const Qt=F[dt];gt.push(Qt),vt.push(dt);const Ut=this.decode(gt,{decode_with_timestamps:!0});(!Ut.includes(de)||se[wt+Ut.indexOf(de)]===de)&&(me.push(Ut),Ie.push(gt),Ke.push(vt),gt=[],vt=[],wt+=Ut.length)}return[me,Ie,Ke]}splitTokensOnSpaces(F){const[se,de,me]=this.splitTokensOnUnicode(F),Ie=[],Ke=[],gt=[],vt=new RegExp(`^[${k}]$`,"gu");for(let wt=0;wt<se.length;++wt){const dt=se[wt],Qt=de[wt],Ut=me[wt],Dn=Qt[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),Kn=dt.startsWith(" "),jn=dt.trim(),Vn=vt.test(jn);if(Dn||Kn||Vn||Ie.length===0)Ie.push(dt),Ke.push(Qt),gt.push(Ut);else{const Cn=Ie.length-1;Ie[Cn]+=dt,Ke[Cn].push(...Qt),gt[Cn].push(...Ut)}}return[Ie,Ke,gt]}mergePunctuations(F,se,de,me,Ie){const Ke=structuredClone(F),gt=structuredClone(se),vt=structuredClone(de);let wt=Ke.length-2,dt=Ke.length-1;for(;wt>=0;)Ke[wt].startsWith(" ")&&me.includes(Ke[wt].trim())?(Ke[dt]=Ke[wt]+Ke[dt],gt[dt]=(0,i.mergeArrays)(gt[wt],gt[dt]),vt[dt]=(0,i.mergeArrays)(vt[wt],vt[dt]),Ke[wt]="",gt[wt]=[],vt[wt]=[]):dt=wt,--wt;for(wt=0,dt=1;dt<Ke.length;)!Ke[wt].endsWith(" ")&&Ie.includes(Ke[dt])?(Ke[wt]+=Ke[dt],gt[wt]=(0,i.mergeArrays)(gt[wt],gt[dt]),vt[wt]=(0,i.mergeArrays)(vt[wt],vt[dt]),Ke[dt]="",gt[dt]=[],vt[dt]=[]):wt=dt,++dt;return[Ke.filter(Qt=>Qt),gt.filter(Qt=>Qt.length>0),vt.filter(Qt=>Qt.length>0)]}}class Gs extends zt{}class Na extends zt{}class Zr extends zt{}class et extends zt{constructor(F,se){super(F,se),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(de=>this.languageRegex.test(de)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(F){if(F===null)return null;const[se,...de]=F.trim().split(this.languageRegex);if(de.length===0)return super._encode_text(se);if(de.length===2){const[me,Ie]=de;return this.supported_language_codes.includes(me)||console.warn(`Unsupported language code "${me}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,i.mergeArrays)([me],super._encode_text(Ie))}}}class ot extends zt{}class Et extends zt{}class $n extends zt{}class va extends zt{}class Cs extends zt{}class Ps extends zt{constructor(F,se){super(F,se),this.decoder=new Ft({})}}class Gr extends zt{}class Ua extends zt{}class Ei extends zt{}class Si{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:mt,DistilBertTokenizer:ke,CamembertTokenizer:Qe,DebertaTokenizer:z,DebertaV2Tokenizer:ce,BertTokenizer:Zs,HerbertTokenizer:X,ConvBertTokenizer:ue,RoFormerTokenizer:pe,XLMTokenizer:Tt,ElectraTokenizer:At,MobileBertTokenizer:Kt,SqueezeBertTokenizer:Js,AlbertTokenizer:En,GPT2Tokenizer:Zt,BartTokenizer:qt,MBartTokenizer:On,MBart50Tokenizer:wn,RobertaTokenizer:Un,WhisperTokenizer:ls,CodeGenTokenizer:Gs,CLIPTokenizer:Na,SiglipTokenizer:Zr,MarianTokenizer:et,BloomTokenizer:Sn,NllbTokenizer:Er,M2M100Tokenizer:Yr,LlamaTokenizer:hr,CodeLlamaTokenizer:pr,XLMRobertaTokenizer:lr,MPNetTokenizer:ea,FalconTokenizer:Vs,GPTNeoXTokenizer:Xr,EsmTokenizer:ya,Wav2Vec2CTCTokenizer:ot,BlenderbotTokenizer:Et,BlenderbotSmallTokenizer:$n,SpeechT5Tokenizer:va,NougatTokenizer:Cs,VitsTokenizer:Ps,Qwen2Tokenizer:Vr,GemmaTokenizer:ur,Grok1Tokenizer:mr,CohereTokenizer:Gr,MgpstrTokenizer:Ua,Ernie4_5_Tokenizer:Ei,PreTrainedTokenizer:zt};static async from_pretrained(F,{progress_callback:se=null,config:de=null,cache_dir:me=null,local_files_only:Ie=!1,revision:Ke="main",legacy:gt=null}={}){const[vt,wt]=await m(F,{progress_callback:se,config:de,cache_dir:me,local_files_only:Ie,revision:Ke,legacy:gt}),dt=wt.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let Qt=this.TOKENIZER_CLASS_MAPPING[dt];return Qt||(console.warn(`Unknown tokenizer class "${dt}", attempting to construct from base class.`),Qt=zt),new Qt(vt,wt)}}}),"./src/utils/audio.js":((e,n,t)=>{t.r(n),t.d(n,{RawAudio:()=>ee,hamming:()=>p,hanning:()=>m,mel_filter_bank:()=>I,read_audio:()=>h,spectrogram:()=>D,window_function:()=>V});var a=t("./src/utils/hub.js"),i=t("./src/utils/maths.js"),l=t("./src/utils/core.js"),u=t("./src/env.js"),d=t("./src/utils/tensor.js"),f=t("?7992");async function h(H,oe){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const ae=await(await(0,a.getFile)(H)).arrayBuffer(),W=new AudioContext({sampleRate:oe});typeof oe>"u"&&console.warn(`No sampling rate provided, using default of ${W.sampleRate}Hz.`);const te=await W.decodeAudioData(ae);let ie;if(te.numberOfChannels===2){const _e=Math.sqrt(2),q=te.getChannelData(0),B=te.getChannelData(1);ie=new Float32Array(q.length);for(let R=0;R<te.length;++R)ie[R]=_e*(q[R]+B[R])/2}else ie=te.getChannelData(0);return ie}function _(H,oe){if(H<1)return new Float64Array;if(H===1)return new Float64Array([1]);const ae=1-oe,W=2*Math.PI/(H-1),te=new Float64Array(H);for(let ie=0;ie<H;++ie)te[ie]=oe-ae*Math.cos(ie*W);return te}function m(H){return _(H,.5)}function p(H){return _(H,.54)}const y={htk:H=>2595*Math.log10(1+H/700),kaldi:H=>1127*Math.log(1+H/700),slaney:(H,oe=1e3,ae=15,W=27/Math.log(6.4))=>H>=oe?ae+Math.log(H/oe)*W:3*H/200};function v(H,oe="htk"){const ae=y[oe];if(!ae)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof H=="number"?ae(H):H.map(W=>ae(W))}const x={htk:H=>700*(10**(H/2595)-1),kaldi:H=>700*(Math.exp(H/1127)-1),slaney:(H,oe=1e3,ae=15,W=Math.log(6.4)/27)=>H>=ae?oe*Math.exp(W*(H-ae)):200*H/3};function L(H,oe="htk"){const ae=x[oe];if(!ae)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof H=="number"?ae(H):H.map(W=>ae(W))}function T(H,oe){const ae=Float64Array.from({length:oe.length-1},(_e,q)=>oe[q+1]-oe[q]),W=Array.from({length:H.length},()=>new Array(oe.length));for(let _e=0;_e<H.length;++_e){const q=W[_e];for(let B=0;B<oe.length;++B)q[B]=oe[B]-H[_e]}const te=oe.length-2,ie=Array.from({length:te},()=>new Array(H.length));for(let _e=0;_e<H.length;++_e){const q=W[_e];for(let B=0;B<te;++B){const R=-q[B]/ae[B],Q=q[B+2]/ae[B+1];ie[B][_e]=Math.max(0,Math.min(R,Q))}}return ie}function E(H,oe,ae){const W=(oe-H)/(ae-1);return Float64Array.from({length:ae},(te,ie)=>H+W*ie)}function I(H,oe,ae,W,te,ie=null,_e="htk",q=!1){if(ie!==null&&ie!=="slaney")throw new Error('norm must be one of null or "slaney"');if(H<2)throw new Error(`Require num_frequency_bins: ${H} >= 2`);if(ae>W)throw new Error(`Require min_frequency: ${ae} <= max_frequency: ${W}`);const B=v(ae,_e),R=v(W,_e),Q=E(B,R,oe+2);let G=L(Q,_e),fe;if(q){const ze=te/((H-1)*2);fe=v(Float64Array.from({length:H},(Ue,ft)=>ft*ze),_e),G=Q}else fe=E(0,Math.floor(te/2),H);const Te=T(fe,G);if(ie!==null&&ie==="slaney")for(let ze=0;ze<oe;++ze){const Ue=Te[ze],ft=2/(G[ze+2]-G[ze]);for(let je=0;je<H;++je)Ue[je]*=ft}return Te}function P(H,oe,ae){const W=new H.constructor(H.length+oe+ae),te=H.length-1;for(let ie=0;ie<H.length;++ie)W[oe+ie]=H[ie];for(let ie=1;ie<=oe;++ie)W[oe-ie]=H[(0,l.calculateReflectOffset)(ie,te)];for(let ie=1;ie<=ae;++ie)W[te+oe+ie]=H[(0,l.calculateReflectOffset)(te-ie,te)];return W}function S(H,oe,ae,W,te){if(ae<=0)throw new Error("reference must be greater than zero");if(W<=0)throw new Error("min_value must be greater than zero");ae=Math.max(W,ae);const ie=Math.log10(ae);for(let _e=0;_e<H.length;++_e)H[_e]=oe*Math.log10(Math.max(W,H[_e])-ie);if(te!==null){if(te<=0)throw new Error("db_range must be greater than zero");const _e=(0,i.max)(H)[0]-te;for(let q=0;q<H.length;++q)H[q]=Math.max(H[q],_e)}return H}function k(H,oe=1,ae=1e-5,W=null){return S(H,20,oe,ae,W)}function C(H,oe=1,ae=1e-10,W=null){return S(H,10,oe,ae,W)}async function D(H,oe,ae,W,{fft_length:te=null,power:ie=1,center:_e=!0,pad_mode:q="reflect",onesided:B=!0,preemphasis:R=null,preemphasis_htk_flavor:Q=!0,mel_filters:G=null,mel_floor:fe=1e-10,log_mel:Te=null,reference:ze=1,min_value:Ue=1e-10,db_range:ft=null,remove_dc_offset:je=null,min_num_frames:le=null,max_num_frames:J=null,do_pad:be=!0,transpose:Ae=!1}={}){const Ne=oe.length;if(te===null&&(te=ae),ae>te)throw Error(`frame_length (${ae}) may not be larger than fft_length (${te})`);if(Ne!==ae)throw new Error(`Length of the window (${Ne}) must equal frame_length (${ae})`);if(W<=0)throw new Error("hop_length must be greater than zero");if(ie===null&&G!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(!Q)throw new Error("`preemphasis_htk_flavor=false` is not currently supported.");if(_e){if(q!=="reflect")throw new Error(`pad_mode="${q}" not implemented yet.`);const ct=Math.floor((te-1)/2)+1;H=P(H,ct,ct)}let De=Math.floor(1+Math.floor((H.length-ae)/W));le!==null&&De<le&&(De=le);const xe=B?Math.floor(te/2)+1:te;let Ve=De,Ee=De;J!==null&&(J>De?be&&(Ee=J):Ee=Ve=J);const Ge=new i.FFT(te),Ye=new Float64Array(te),_t=new Float64Array(Ge.outputBufferSize),Re=new Float32Array(xe*Ee);for(let ct=0;ct<Ve;++ct){const pt=ct*W,lt=Math.min(H.length-pt,ae);lt!==ae&&Ye.fill(0,0,ae);for(let Mt=0;Mt<lt;++Mt)Ye[Mt]=H[pt+Mt];if(je){let Mt=0;for(let an=0;an<lt;++an)Mt+=Ye[an];const tn=Mt/lt;for(let an=0;an<lt;++an)Ye[an]-=tn}if(R!==null){for(let Mt=lt-1;Mt>=1;--Mt)Ye[Mt]-=R*Ye[Mt-1];Ye[0]*=1-R}for(let Mt=0;Mt<oe.length;++Mt)Ye[Mt]*=oe[Mt];Ge.realTransform(_t,Ye);for(let Mt=0;Mt<xe;++Mt){const tn=Mt<<1;Re[Mt*Ee+ct]=_t[tn]**2+_t[tn+1]**2}}if(ie!==null&&ie!==2){const ct=ie/2;for(let pt=0;pt<Re.length;++pt)Re[pt]**=ct}const xt=G.length;let st=await(0,d.matmul)(new d.Tensor("float32",G.flat(),[xt,xe]),new d.Tensor("float32",Re,[xe,Ee]));Ae&&(st=st.transpose(1,0));const nt=st.data;for(let ct=0;ct<nt.length;++ct)nt[ct]=Math.max(fe,nt[ct]);if(ie!==null&&Te!==null){const ct=Math.min(nt.length,Ve*xt);switch(Te){case"log":for(let pt=0;pt<ct;++pt)nt[pt]=Math.log(nt[pt]);break;case"log10":for(let pt=0;pt<ct;++pt)nt[pt]=Math.log10(nt[pt]);break;case"dB":if(ie===1)k(nt,ze,Ue,ft);else if(ie===2)C(nt,ze,Ue,ft);else throw new Error(`Cannot use log_mel option '${Te}' with power ${ie}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${Te}'`)}}return st}function V(H,oe,{periodic:ae=!0,frame_length:W=null,center:te=!0}={}){const ie=ae?H+1:H;let _e;switch(oe){case"boxcar":_e=new Float64Array(ie).fill(1);break;case"hann":case"hann_window":_e=m(ie);break;case"hamming":_e=p(ie);break;case"povey":_e=m(ie).map(q=>Math.pow(q,.85));break;default:throw new Error(`Unknown window type ${oe}.`)}if(ae&&(_e=_e.subarray(0,H)),W===null)return _e;if(H>W)throw new Error(`Length of the window (${H}) may not be larger than frame_length (${W})`);return _e}function U(H,oe){let ae=44;const W=new ArrayBuffer(ae+H.length*4),te=new DataView(W);ne(te,0,"RIFF"),te.setUint32(4,36+H.length*4,!0),ne(te,8,"WAVE"),ne(te,12,"fmt "),te.setUint32(16,16,!0),te.setUint16(20,3,!0),te.setUint16(22,1,!0),te.setUint32(24,oe,!0),te.setUint32(28,oe*4,!0),te.setUint16(32,4,!0),te.setUint16(34,32,!0),ne(te,36,"data"),te.setUint32(40,H.length*4,!0);for(let ie=0;ie<H.length;++ie,ae+=4)te.setFloat32(ae,H[ie],!0);return W}function ne(H,oe,ae){for(let W=0;W<ae.length;++W)H.setUint8(oe+W,ae.charCodeAt(W))}class ee{constructor(oe,ae){this.audio=oe,this.sampling_rate=ae}toWav(){return U(this.audio,this.sampling_rate)}toBlob(){const oe=this.toWav();return new Blob([oe],{type:"audio/wav"})}async save(oe){let ae;if(u.apis.IS_BROWSER_ENV){if(u.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save a file from a Web Worker.");ae=l.saveBlob}else if(u.apis.IS_FS_AVAILABLE)ae=async(W,te)=>{let ie=await te.arrayBuffer();f.writeFileSync(W,Buffer.from(ie))};else throw new Error("Unable to save because filesystem is disabled in this environment.");await ae(oe,this.toBlob())}}}),"./src/utils/constants.js":((e,n,t)=>{t.r(n),t.d(n,{CHAT_TEMPLATE_NAME:()=>f,CONFIG_NAME:()=>i,FEATURE_EXTRACTOR_NAME:()=>l,GENERATION_CONFIG_NAME:()=>h,GITHUB_ISSUE_URL:()=>a,IMAGE_PROCESSOR_NAME:()=>u,PROCESSOR_NAME:()=>d});const a="https://github.com/huggingface/transformers.js/issues/new/choose",i="config.json",l="preprocessor_config.json",u=l,d="processor_config.json",f="chat_template.jinja",h="generation_config.json"}),"./src/utils/core.js":((e,n,t)=>{t.r(n),t.d(n,{calculateDimensions:()=>h,calculateReflectOffset:()=>y,count:()=>T,dispatchCallback:()=>a,escapeRegExp:()=>l,isIntegralNumber:()=>d,isNullishDimension:()=>f,isTypedArray:()=>u,len:()=>L,mergeArrays:()=>m,pick:()=>x,pop:()=>_,product:()=>p,reverseDictionary:()=>i,saveBlob:()=>v});function a(E,I){E&&E(I)}function i(E){return Object.fromEntries(Object.entries(E).map(([I,P])=>[P,I]))}function l(E){return E.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function u(E){return E?.prototype?.__proto__?.constructor?.name==="TypedArray"}function d(E){return Number.isInteger(E)||typeof E=="bigint"}function f(E){return E==null||E===-1}function h(E){const I=[];let P=E;for(;Array.isArray(P);)I.push(P.length),P=P[0];return I}function _(E,I,P=void 0){const S=E[I];if(S!==void 0)return delete E[I],S;if(P===void 0)throw Error(`Key ${I} does not exist in object.`);return P}function m(...E){return Array.prototype.concat.apply([],E)}function p(...E){return E.reduce((I,P)=>I.flatMap(S=>P.map(k=>[S,k])))}function y(E,I){return Math.abs((E+I)%(2*I)-I)}function v(E,I){const P=URL.createObjectURL(I),S=document.createElement("a");S.href=P,S.download=E,S.click(),S.remove(),URL.revokeObjectURL(P)}function x(E,I){return Object.assign({},...I.map(P=>{if(E[P]!==void 0)return{[P]:E[P]}}))}function L(E){let I=0;for(const P of E)++I;return I}function T(E,I){let P=0;for(const S of E)S===I&&++P;return P}}),"./src/utils/data-structures.js":((e,n,t)=>{t.r(n),t.d(n,{CharTrie:()=>i,DictionarySplitter:()=>f,LRUCache:()=>h,PriorityQueue:()=>a,TokenLattice:()=>u});class a{constructor(m=(y,v)=>y>v,p=1/0){this._heap=[],this._comparator=m,this._maxSize=p}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...m){return this.extend(m)}extend(m){for(const p of m)if(this.size<this._maxSize)this._heap.push(p),this._siftUp();else{const y=this._smallest();this._comparator(p,this._heap[y])&&(this._heap[y]=p,this._siftUpFrom(y))}return this.size}pop(){const m=this.peek(),p=this.size-1;return p>0&&this._swap(0,p),this._heap.pop(),this._siftDown(),m}replace(m){const p=this.peek();return this._heap[0]=m,this._siftDown(),p}_parent(m){return(m+1>>>1)-1}_left(m){return(m<<1)+1}_right(m){return m+1<<1}_greater(m,p){return this._comparator(this._heap[m],this._heap[p])}_swap(m,p){const y=this._heap[m];this._heap[m]=this._heap[p],this._heap[p]=y}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(m){for(;m>0&&this._greater(m,this._parent(m));)this._swap(m,this._parent(m)),m=this._parent(m)}_siftDown(){let m=0;for(;this._left(m)<this.size&&this._greater(this._left(m),m)||this._right(m)<this.size&&this._greater(this._right(m),m);){const p=this._right(m)<this.size&&this._greater(this._right(m),this._left(m))?this._right(m):this._left(m);this._swap(m,p),m=p}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class i{constructor(){this.root=l.default()}extend(m){for(const p of m)this.push(p)}push(m){let p=this.root;for(const y of m){let v=p.children.get(y);v===void 0&&(v=l.default(),p.children.set(y,v)),p=v}p.isLeaf=!0}*commonPrefixSearch(m){let p=this.root;if(p===void 0)return;let y="";for(const v of m){if(y+=v,p=p.children.get(v),p===void 0)return;p.isLeaf&&(yield y)}}}class l{constructor(m,p){this.isLeaf=m,this.children=p}static default(){return new l(!1,new Map)}}class u{constructor(m,p,y){this.chars=Array.from(m),this.len=this.chars.length,this.bosTokenId=p,this.eosTokenId=y,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const v=new d(this.bosTokenId,0,0,0,0),x=new d(this.eosTokenId,1,this.len,0,0);this.nodes.push(v.clone()),this.nodes.push(x.clone()),this.beginNodes[this.len].push(x),this.endNodes[0].push(v)}insert(m,p,y,v){const x=this.nodes.length,L=new d(v,x,m,p,y);this.beginNodes[m].push(L),this.endNodes[m+p].push(L),this.nodes.push(L)}viterbi(){const m=this.len;let p=0;for(;p<=m;){if(this.beginNodes[p].length==0)return[];for(let T of this.beginNodes[p]){T.prev=null;let E=0,I=null;for(let P of this.endNodes[p]){const S=P.backtraceScore+T.score;(I===null||S>E)&&(I=P.clone(),E=S)}if(I!==null)T.prev=I,T.backtraceScore=E;else return[]}++p}const y=[],x=this.beginNodes[m][0].prev;if(x===null)return[];let L=x.clone();for(;L.prev!==null;)y.push(L.clone()),L=L.clone().prev.clone();return y.reverse(),y}piece(m){return this.chars.slice(m.pos,m.pos+m.length).join("")}tokens(){return this.viterbi().map(p=>this.piece(p))}tokenIds(){return this.viterbi().map(p=>p.tokenId)}}class d{constructor(m,p,y,v,x){this.tokenId=m,this.nodeId=p,this.pos=y,this.length=v,this.score=x,this.prev=null,this.backtraceScore=0}clone(){const m=new d(this.tokenId,this.nodeId,this.pos,this.length,this.score);return m.prev=this.prev,m.backtraceScore=this.backtraceScore,m}}class f{constructor(m){this.trie=this._buildTrie(m)}_buildTrie(m){const p=Object.create(null);for(const y of m){let v=p;for(let x=0;x<y.length;++x)v=v[y[x]]??=Object.create(null);v.end=y}return p}split(m){const p=[],y=m.length;let v=0,x=0;for(;x<y;){let L=this.trie,T=null,E=x;for(;E<y&&(L=L[m[E]]);)L.end&&(T=L.end),++E;T?(x>v&&p.push(m.slice(v,x)),p.push(T),x+=T.length,v=x):++x}return v<y&&p.push(m.slice(v)),p}}class h{constructor(m){this.capacity=m,this.cache=new Map}get(m){if(!this.cache.has(m))return;const p=this.cache.get(m);return this.cache.delete(m),this.cache.set(m,p),p}put(m,p){this.cache.has(m)&&this.cache.delete(m),this.cache.set(m,p),this.cache.size>this.capacity&&this.cache.delete(this.cache.keys().next().value)}clear(){this.cache.clear()}}}),"./src/utils/devices.js":((e,n,t)=>{t.r(n),t.d(n,{DEVICE_TYPES:()=>a});const a=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})}),"./src/utils/dtypes.js":((e,n,t)=>{t.r(n),t.d(n,{DATA_TYPES:()=>u,DEFAULT_DEVICE_DTYPE_MAPPING:()=>d,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>f,isWebGpuFp16Supported:()=>l});var a=t("./src/env.js"),i=t("./src/utils/devices.js");const l=(function(){let h;return async function(){if(h===void 0)if(!a.apis.IS_WEBGPU_AVAILABLE)h=!1;else try{h=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{h=!1}return h}})(),u=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),d=Object.freeze({[i.DEVICE_TYPES.wasm]:u.q8}),f=Object.freeze({[u.fp32]:"",[u.fp16]:"_fp16",[u.int8]:"_int8",[u.uint8]:"_uint8",[u.q8]:"_quantized",[u.q4]:"_q4",[u.q4f16]:"_q4f16",[u.bnb4]:"_bnb4"})}),"./src/utils/generic.js":((e,n,t)=>{t.r(n),t.d(n,{Callable:()=>a});const a=class{constructor(){let i=function(...l){return i._call(...l)};return Object.setPrototypeOf(i,new.target.prototype)}_call(...i){throw Error("Must implement _call method in subclass")}}}),"./src/utils/hub.js":((e,n,t)=>{t.r(n),t.d(n,{MAX_EXTERNAL_DATA_CHUNKS:()=>d,getFile:()=>y,getModelFile:()=>E,getModelJSON:()=>P,getModelText:()=>I});var a=t("?7992"),i=t("?5af5"),l=t("./src/env.js"),u=t("./src/utils/core.js");const d=100,f={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class h{constructor(D){if(this.filePath=D,this.headers=new Headers,this.exists=a.existsSync(D),this.exists){this.status=200,this.statusText="OK";let V=a.statSync(D);this.headers.set("content-length",V.size.toString()),this.updateContentType();const U=a.createReadStream(D);this.body=new ReadableStream({start(ne){U.on("data",ee=>ne.enqueue(ee)),U.on("end",()=>ne.close()),U.on("error",ee=>ne.error(ee))},cancel(){U.destroy()}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const D=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",f[D]??"application/octet-stream")}clone(){let D=new h(this.filePath);return D.exists=this.exists,D.status=this.status,D.statusText=this.statusText,D.headers=new Headers(this.headers),D}async arrayBuffer(){return(await a.promises.readFile(this.filePath)).buffer}async blob(){const D=await a.promises.readFile(this.filePath);return new Blob([D],{type:this.headers.get("content-type")})}async text(){return await a.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function _(C,D=null,V=null){let U;try{U=new URL(C)}catch{return!1}return!(D&&!D.includes(U.protocol)||V&&!V.includes(U.hostname))}const m=/^(\b[\w\-.]+\b\/)?\b[\w\-.]{1,96}\b$/;function p(C){return!(!m.test(C)||C.includes("..")||C.includes("--")||C.endsWith(".git")||C.endsWith(".ipynb"))}async function y(C){if(l.env.useFS&&!_(C,["http:","https:","blob:"]))return new h(C instanceof URL?C.protocol==="file:"?C.pathname:C.toString():C);if(typeof process<"u"&&process?.release?.name==="node"){const D=!!z0?.TESTING_REMOTELY,V=l.env.version,U=new Headers;if(U.set("User-Agent",`transformers.js/${V}; is_ci/${D};`),_(C,["http:","https:"],["huggingface.co","hf.co"])){const ee=z0?.HF_TOKEN??z0?.HF_ACCESS_TOKEN;ee&&U.set("Authorization",`Bearer ${ee}`)}return fetch(C,{headers:U})}else return fetch(C)}const v={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function x(C,D,V){if(!V)return null;const U=v[C]??`Error (${C}) occurred while trying to load file`;throw Error(`${U}: "${D}".`)}class L{constructor(D){this.path=D}async match(D){let V=i.join(this.path,D),U=new h(V);if(U.exists)return U}async put(D,V,U=void 0){let ne=i.join(this.path,D);try{const ee=V.headers.get("Content-Length"),H=parseInt(ee??"0");let oe=0;await a.promises.mkdir(i.dirname(ne),{recursive:!0});const ae=a.createWriteStream(ne),W=V.body.getReader();for(;;){const{done:te,value:ie}=await W.read();if(te)break;await new Promise((q,B)=>{ae.write(ie,R=>{if(R){B(R);return}q()})}),oe+=ie.length;const _e=H?oe/H*100:0;U?.({progress:_e,loaded:oe,total:H})}ae.close()}catch(ee){try{await a.promises.unlink(ne)}catch{}throw ee}}}async function T(C,...D){for(let V of D)try{let U=await C.match(V);if(U)return U}catch{continue}}async function E(C,D,V=!0,U={},ne=!1){if(!l.env.allowLocalModels){if(U.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!l.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,u.dispatchCallback)(U.progress_callback,{status:"initiate",name:C,file:D});let ee;if(!ee&&l.env.useCustomCache){if(!l.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!l.env.customCache.match||!l.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");ee=l.env.customCache}if(!ee&&l.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{ee=await caches.open("transformers-cache")}catch(fe){console.warn("An error occurred while opening the browser cache:",fe)}}if(!ee&&l.env.useFSCache){if(!l.apis.IS_FS_AVAILABLE)throw Error("File System Cache is not available in this environment.");ee=new L(U.cache_dir??l.env.cacheDir)}const H=U.revision??"main",oe=k(C,D),ae=p(C),W=ae?k(l.env.localModelPath,oe):oe,te=k(l.env.remoteHost,l.env.remotePathTemplate.replaceAll("{model}",C).replaceAll("{revision}",encodeURIComponent(H)),D);let ie;const _e=ee instanceof L?H==="main"?oe:k(C,H,D):te;let q=!1,B;ee&&(B=await T(ee,W,_e));const R=B!==void 0;if(B===void 0){if(l.env.allowLocalModels)if(_(oe,["http:","https:"])){if(U.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${oe}.`);if(!l.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${oe}.`)}else try{B=await y(W),ie=W}catch(Te){console.warn(`Unable to load from local path "${W}": "${Te}"`)}if(B===void 0||B.status===404){if(U.local_files_only||!l.env.allowRemoteModels){if(V)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${W}".`);return null}if(!ae)throw Error(`Local file missing at "${W}" and download aborted due to invalid model ID "${C}".`);if(B=await y(te),B.status!==200)return x(B.status,te,V);ie=_e}q=ee&&typeof Response<"u"&&B instanceof Response&&B.status===200}(0,u.dispatchCallback)(U.progress_callback,{status:"download",name:C,file:D});let Q;if(!(l.apis.IS_NODE_ENV&&ne)){let fe;U.progress_callback?R&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(fe=new Uint8Array(await B.arrayBuffer()),(0,u.dispatchCallback)(U.progress_callback,{status:"progress",name:C,file:D,progress:100,loaded:fe.length,total:fe.length})):fe=await S(B,Te=>{(0,u.dispatchCallback)(U.progress_callback,{status:"progress",name:C,file:D,...Te})}):fe=new Uint8Array(await B.arrayBuffer()),Q=fe}if(q&&ie&&await ee.match(ie)===void 0)if(Q)await ee.put(ie,new Response(Q,{headers:B.headers})).catch(fe=>{console.warn(`Unable to add response to browser cache: ${fe}.`)});else{const fe=U.progress_callback?Te=>(0,u.dispatchCallback)(U.progress_callback,{status:"progress",name:C,file:D,...Te}):void 0;await ee.put(ie,B,fe)}if((0,u.dispatchCallback)(U.progress_callback,{status:"done",name:C,file:D}),Q){if(!l.apis.IS_NODE_ENV&&ne)throw new Error("Cannot return path in a browser environment.");return Q}if(B instanceof h)return B.filePath;const G=await ee?.match(ie);if(G instanceof h)return G.filePath;if(G instanceof Response)return new Uint8Array(await G.arrayBuffer());if(typeof G=="string")return G;throw new Error("Unable to get model file path or buffer.")}async function I(C,D,V=!0,U={}){const ne=await E(C,D,V,U,!1);return ne===null?null:new TextDecoder("utf-8").decode(ne)}async function P(C,D,V=!0,U={}){const ne=await I(C,D,V,U);return ne===null?{}:JSON.parse(ne)}async function S(C,D){const V=C.headers.get("Content-Length");V===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let U=parseInt(V??"0"),ne=new Uint8Array(U),ee=0;const H=C.body.getReader();async function oe(){const{done:ae,value:W}=await H.read();if(ae)return;const te=ee+W.length;if(te>U){U=te;const _e=new Uint8Array(U);_e.set(ne),ne=_e}ne.set(W,ee),ee=te;const ie=ee/U*100;return D({progress:ie,loaded:ee,total:U}),oe()}return await oe(),ne}function k(...C){return C=C.map((D,V)=>(V&&(D=D.replace(new RegExp("^/"),"")),V!==C.length-1&&(D=D.replace(new RegExp("/$"),"")),D)),C.join("/")}}),"./src/utils/image.js":((e,n,t)=>{t.r(n),t.d(n,{RawImage:()=>v,load_image:()=>x});var a=t("./src/utils/core.js"),i=t("./src/utils/hub.js"),l=t("./src/env.js"),u=t("./src/utils/tensor.js"),d=t("?2b25");let f,h,_;const m=l.apis.IS_BROWSER_ENV||l.apis.IS_WEBWORKER_ENV;if(m)f=(L,T)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(L,T)},_=self.createImageBitmap,h=self.ImageData;else if(d)_=async L=>{const E=(await L.metadata()).channels,{data:I,info:P}=await L.rotate().raw().toBuffer({resolveWithObject:!0}),S=new v(new Uint8ClampedArray(I),P.width,P.height,P.channels);return E!==void 0&&E!==P.channels&&S.convert(E),S};else throw new Error("Unable to load image processing library.");const p={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},y=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class v{constructor(T,E,I,P){this.data=T,this.width=E,this.height=I,this.channels=P}get size(){return[this.width,this.height]}static async read(T){if(T instanceof v)return T;if(typeof T=="string"||T instanceof URL)return await this.fromURL(T);if(T instanceof Blob)return await this.fromBlob(T);if(typeof HTMLCanvasElement<"u"&&T instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&T instanceof OffscreenCanvas)return this.fromCanvas(T);throw new Error(`Unsupported input type: ${typeof T}`)}static fromCanvas(T){if(!m)throw new Error("fromCanvas() is only supported in browser environments.");const I=T.getContext("2d").getImageData(0,0,T.width,T.height).data;return new v(I,T.width,T.height,4)}static async fromURL(T){const E=await(0,i.getFile)(T);if(E.status!==200)throw new Error(`Unable to read image from "${T}" (${E.status} ${E.statusText})`);const I=await E.blob();return this.fromBlob(I)}static async fromBlob(T){if(m){const E=await _(T),I=f(E.width,E.height).getContext("2d");return I.drawImage(E,0,0),new this(I.getImageData(0,0,E.width,E.height).data,E.width,E.height,4)}else{const E=d(await T.arrayBuffer());return await _(E)}}static fromTensor(T,E="CHW"){if(T.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${T.dims.length} dimensions.`);if(E==="CHW")T=T.transpose(1,2,0);else if(E!=="HWC")throw new Error(`Unsupported channel format: ${E}`);if(!(T.data instanceof Uint8ClampedArray||T.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${T.type}`);switch(T.dims[2]){case 1:case 2:case 3:case 4:return new v(T.data,T.dims[1],T.dims[0],T.dims[2]);default:throw new Error(`Unsupported number of channels: ${T.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const T=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let E=0,I=0;E<this.data.length;E+=this.channels){const P=this.data[E],S=this.data[E+1],k=this.data[E+2];T[I++]=Math.round(.2989*P+.587*S+.114*k)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(T,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const T=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let E=0,I=0;E<this.data.length;++E)T[I++]=this.data[E],T[I++]=this.data[E],T[I++]=this.data[E];break;case 4:for(let E=0,I=0;E<this.data.length;E+=4)T[I++]=this.data[E],T[I++]=this.data[E+1],T[I++]=this.data[E+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(T,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const T=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let E=0,I=0;E<this.data.length;++E)T[I++]=this.data[E],T[I++]=this.data[E],T[I++]=this.data[E],T[I++]=255;break;case 3:for(let E=0,I=0;E<this.data.length;E+=3)T[I++]=this.data[E],T[I++]=this.data[E+1],T[I++]=this.data[E+2],T[I++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(T,this.width,this.height,4)}putAlpha(T){if(T.width!==this.width||T.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${T.width}x${T.height}`);if(T.channels!==1)throw new Error(`Expected mask to have 1 channel, but got ${T.channels}`);const E=this.data,I=T.data,P=this.width*this.height;if(this.channels===3){const S=new Uint8ClampedArray(P*4);for(let k=0,C=0,D=0;k<P;++k)S[D++]=E[C++],S[D++]=E[C++],S[D++]=E[C++],S[D++]=I[k];return this._update(S,this.width,this.height,4)}else if(this.channels===4){for(let S=0;S<P;++S)E[4*S+3]=I[S];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(T,E,{resample:I=2}={}){if(this.width===T&&this.height===E)return this;let P=p[I]??I;const S=(0,a.isNullishDimension)(T),k=(0,a.isNullishDimension)(E);if(S&&k)return this;if(S?T=E/this.height*this.width:k&&(E=T/this.width*this.height),m){const C=this.channels,D=this.toCanvas(),V=f(T,E).getContext("2d");return V.drawImage(D,0,0,T,E),new v(V.getImageData(0,0,T,E).data,T,E,4).convert(C)}else{let C=this.toSharp();switch(P){case"box":case"hamming":(P==="box"||P==="hamming")&&(console.warn(`Resampling method ${P} is not yet supported. Using bilinear instead.`),P="bilinear");case"nearest":case"bilinear":case"bicubic":C=C.affine([T/this.width,0,0,E/this.height],{interpolator:P});break;case"lanczos":C=C.resize({width:T,height:E,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${P} is not supported.`)}return await _(C)}}async pad([T,E,I,P]){if(T=Math.max(T,0),E=Math.max(E,0),I=Math.max(I,0),P=Math.max(P,0),T===0&&E===0&&I===0&&P===0)return this;if(m){const S=this.channels,k=this.toCanvas(),C=this.width+T+E,D=this.height+I+P,V=f(C,D).getContext("2d");return V.drawImage(k,0,0,this.width,this.height,T,I,this.width,this.height),new v(V.getImageData(0,0,C,D).data,C,D,4).convert(S)}else{const S=this.toSharp().extend({left:T,right:E,top:I,bottom:P});return await _(S)}}async crop([T,E,I,P]){if(T=Math.max(T,0),E=Math.max(E,0),I=Math.min(I,this.width-1),P=Math.min(P,this.height-1),T===0&&E===0&&I===this.width-1&&P===this.height-1)return this;const S=I-T+1,k=P-E+1;if(m){const C=this.channels,D=this.toCanvas(),V=f(S,k).getContext("2d");return V.drawImage(D,T,E,S,k,0,0,S,k),new v(V.getImageData(0,0,S,k).data,S,k,4).convert(C)}else{const C=this.toSharp().extract({left:T,top:E,width:S,height:k});return await _(C)}}async center_crop(T,E){if(this.width===T&&this.height===E)return this;const I=(this.width-T)/2,P=(this.height-E)/2;if(m){const S=this.channels,k=this.toCanvas(),C=f(T,E).getContext("2d");let D=0,V=0,U=0,ne=0;return I>=0?D=I:U=-I,P>=0?V=P:ne=-P,C.drawImage(k,D,V,T,E,U,ne,T,E),new v(C.getImageData(0,0,T,E).data,T,E,4).convert(S)}else{let S=this.toSharp();if(I>=0&&P>=0)S=S.extract({left:Math.floor(I),top:Math.floor(P),width:T,height:E});else if(I<=0&&P<=0){const k=Math.floor(-P),C=Math.floor(-I);S=S.extend({top:k,left:C,right:T-this.width-C,bottom:E-this.height-k})}else{let k=[0,0],C=0;P<0?(k[0]=Math.floor(-P),k[1]=E-this.height-k[0]):C=Math.floor(P);let D=[0,0],V=0;I<0?(D[0]=Math.floor(-I),D[1]=T-this.width-D[0]):V=Math.floor(I),S=S.extend({top:k[0],bottom:k[1],left:D[0],right:D[1]}).extract({left:V,top:C,width:T,height:E})}return await _(S)}}async toBlob(T="image/png",E=1){if(!m)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:T,quality:E})}toTensor(T="CHW"){let E=new u.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(T!=="HWC")if(T==="CHW")E=E.permute(2,0,1);else throw new Error(`Unsupported channel format: ${T}`);return E}toCanvas(){if(!m)throw new Error("toCanvas() is only supported in browser environments.");const T=this.clone().rgba(),E=f(T.width,T.height),I=new h(T.data,T.width,T.height);return E.getContext("2d").putImageData(I,0,0),E}split(){const{data:T,width:E,height:I,channels:P}=this,S=T.constructor,k=T.length/P,C=Array.from({length:P},()=>new S(k));for(let D=0;D<k;++D){const V=P*D;for(let U=0;U<P;++U)C[U][D]=T[V+U]}return C.map(D=>new v(D,E,I,1))}_update(T,E,I,P=null){return this.data=T,this.width=E,this.height=I,P!==null&&(this.channels=P),this}clone(){return new v(this.data.slice(),this.width,this.height,this.channels)}convert(T){if(this.channels===T)return this;switch(T){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(T){if(m){if(l.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const E=T.split(".").pop().toLowerCase(),I=y.get(E)??"image/png",P=await this.toBlob(I);(0,a.saveBlob)(T,P)}else{if(l.apis.IS_FS_AVAILABLE)return await this.toSharp().toFile(T);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(m)throw new Error("toSharp() is only supported in server-side environments.");return d(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}const x=v.read.bind(v)}),"./src/utils/maths.js":((e,n,t)=>{t.r(n),t.d(n,{FFT:()=>x,bankers_round:()=>E,cos_sim:()=>f,dot:()=>d,dynamic_time_warping:()=>I,interpolate_data:()=>a,log_softmax:()=>u,magnitude:()=>h,max:()=>m,medianFilter:()=>L,min:()=>_,permute_data:()=>i,round:()=>T,softmax:()=>l});function a(P,[S,k,C],[D,V],U="bilinear",ne=!1){const ee=V/C,H=D/k,oe=new P.constructor(D*V*S),ae=k*C,W=D*V;for(let te=0;te<D;++te)for(let ie=0;ie<V;++ie){const _e=te*V+ie,q=(ie+.5)/ee-.5,B=(te+.5)/H-.5;let R=Math.floor(q),Q=Math.floor(B);const G=Math.min(R+1,C-1),fe=Math.min(Q+1,k-1);R=Math.max(R,0),Q=Math.max(Q,0);const Te=q-R,ze=B-Q,Ue=(1-Te)*(1-ze),ft=Te*(1-ze),je=(1-Te)*ze,le=Te*ze,J=Q*C,be=fe*C,Ae=J+R,Ne=J+G,De=be+R,xe=be+G;for(let Ve=0;Ve<S;++Ve){const Ee=Ve*ae;oe[Ve*W+_e]=Ue*P[Ee+Ae]+ft*P[Ee+Ne]+je*P[Ee+De]+le*P[Ee+xe]}}return oe}function i(P,S,k){const C=new Array(k.length),D=new Array(k.length);for(let ne=k.length-1,ee=1;ne>=0;--ne)D[ne]=ee,C[ne]=S[k[ne]],ee*=C[ne];const V=k.map((ne,ee)=>D[k.indexOf(ee)]),U=new P.constructor(P.length);for(let ne=0;ne<P.length;++ne){let ee=0;for(let H=S.length-1,oe=ne;H>=0;--H)ee+=oe%S[H]*V[H],oe=Math.floor(oe/S[H]);U[ee]=P[ne]}return[U,C]}function l(P){const S=m(P)[0],k=P.map(V=>Math.exp(V-S)),C=k.reduce((V,U)=>V+U,0);return k.map(V=>V/C)}function u(P){const S=m(P)[0];let k=0;for(let V=0;V<P.length;++V)k+=Math.exp(P[V]-S);const C=Math.log(k);return P.map(V=>V-S-C)}function d(P,S){let k=0;for(let C=0;C<P.length;++C)k+=P[C]*S[C];return k}function f(P,S){const k=d(P,S),C=h(P),D=h(S);return k/(C*D)}function h(P){return Math.sqrt(P.reduce((S,k)=>S+k*k,0))}function _(P){if(P.length===0)throw Error("Array must not be empty");let S=P[0],k=0;for(let C=1;C<P.length;++C)P[C]<S&&(S=P[C],k=C);return[S,k]}function m(P){if(P.length===0)throw Error("Array must not be empty");let S=P[0],k=0;for(let C=1;C<P.length;++C)P[C]>S&&(S=P[C],k=C);return[S,k]}function p(P){return P>0&&(P&P-1)===0}class y{constructor(S){if(this.size=S|0,this.size<=1||!p(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=S<<1,this.table=new Float64Array(this.size*2);for(let C=0;C<this.table.length;C+=2){const D=Math.PI*C/this.size;this.table[C]=Math.cos(D),this.table[C+1]=-Math.sin(D)}let k=0;for(let C=1;this.size>C;C<<=1)++k;this._width=k%2===0?k-1:k,this._bitrev=new Int32Array(1<<this._width);for(let C=0;C<this._bitrev.length;++C){this._bitrev[C]=0;for(let D=0;D<this._width;D+=2){const V=this._width-D-2;this._bitrev[C]|=(C>>>D&3)<<V}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(S,k){const C=k||new Array(S.length>>>1);for(let D=0;D<S.length;D+=2)C[D>>>1]=S[D];return C}toComplexArray(S,k){const C=k||this.createComplexArray();for(let D=0;D<C.length;D+=2)C[D]=S[D>>>1],C[D+1]=0;return C}transform(S,k){if(S===k)throw new Error("Input and output buffers must be different");this._transform4(S,k,1)}realTransform(S,k){if(S===k)throw new Error("Input and output buffers must be different");this._realTransform4(S,k,1)}inverseTransform(S,k){if(S===k)throw new Error("Input and output buffers must be different");this._transform4(S,k,-1);for(let C=0;C<S.length;++C)S[C]/=this.size}_transform4(S,k,C){const D=this._csize;let U=1<<this._width,ne=D/U<<1,ee,H;const oe=this._bitrev;if(ne===4)for(ee=0,H=0;ee<D;ee+=ne,++H){const W=oe[H];this._singleTransform2(k,S,ee,W,U)}else for(ee=0,H=0;ee<D;ee+=ne,++H){const W=oe[H];this._singleTransform4(k,S,ee,W,U,C)}const ae=this.table;for(U>>=2;U>=2;U>>=2){ne=D/U<<1;const W=ne>>>2;for(ee=0;ee<D;ee+=ne){const te=ee+W-1;for(let ie=ee,_e=0;ie<te;ie+=2,_e+=U){const q=ie,B=q+W,R=B+W,Q=R+W,G=S[q],fe=S[q+1],Te=S[B],ze=S[B+1],Ue=S[R],ft=S[R+1],je=S[Q],le=S[Q+1],J=ae[_e],be=C*ae[_e+1],Ae=Te*J-ze*be,Ne=Te*be+ze*J,De=ae[2*_e],xe=C*ae[2*_e+1],Ve=Ue*De-ft*xe,Ee=Ue*xe+ft*De,Ge=ae[3*_e],Ye=C*ae[3*_e+1],_t=je*Ge-le*Ye,Re=je*Ye+le*Ge,xt=G+Ve,st=fe+Ee,nt=G-Ve,ct=fe-Ee,pt=Ae+_t,lt=Ne+Re,Mt=C*(Ae-_t),tn=C*(Ne-Re);S[q]=xt+pt,S[q+1]=st+lt,S[B]=nt+tn,S[B+1]=ct-Mt,S[R]=xt-pt,S[R+1]=st-lt,S[Q]=nt-tn,S[Q+1]=ct+Mt}}}}_singleTransform2(S,k,C,D,V){const U=S[D],ne=S[D+1],ee=S[D+V],H=S[D+V+1];k[C]=U+ee,k[C+1]=ne+H,k[C+2]=U-ee,k[C+3]=ne-H}_singleTransform4(S,k,C,D,V,U){const ne=V*2,ee=V*3,H=S[D],oe=S[D+1],ae=S[D+V],W=S[D+V+1],te=S[D+ne],ie=S[D+ne+1],_e=S[D+ee],q=S[D+ee+1],B=H+te,R=oe+ie,Q=H-te,G=oe-ie,fe=ae+_e,Te=W+q,ze=U*(ae-_e),Ue=U*(W-q);k[C]=B+fe,k[C+1]=R+Te,k[C+2]=Q+Ue,k[C+3]=G-ze,k[C+4]=B-fe,k[C+5]=R-Te,k[C+6]=Q-Ue,k[C+7]=G+ze}_realTransform4(S,k,C){const D=this._csize;let U=1<<this._width,ne=D/U<<1,ee,H;const oe=this._bitrev;if(ne===4)for(ee=0,H=0;ee<D;ee+=ne,++H){const te=oe[H];this._singleRealTransform2(k,S,ee,te>>>1,U>>>1)}else for(ee=0,H=0;ee<D;ee+=ne,++H){const te=oe[H];this._singleRealTransform4(k,S,ee,te>>>1,U>>>1,C)}const ae=this.table;for(U>>=2;U>=2;U>>=2){ne=D/U<<1;const te=ne>>>1,ie=te>>>1,_e=ie>>>1;for(ee=0;ee<D;ee+=ne)for(let q=0,B=0;q<=_e;q+=2,B+=U){const R=ee+q,Q=R+ie,G=Q+ie,fe=G+ie,Te=S[R],ze=S[R+1],Ue=S[Q],ft=S[Q+1],je=S[G],le=S[G+1],J=S[fe],be=S[fe+1],Ae=Te,Ne=ze,De=ae[B],xe=C*ae[B+1],Ve=Ue*De-ft*xe,Ee=Ue*xe+ft*De,Ge=ae[2*B],Ye=C*ae[2*B+1],_t=je*Ge-le*Ye,Re=je*Ye+le*Ge,xt=ae[3*B],st=C*ae[3*B+1],nt=J*xt-be*st,ct=J*st+be*xt,pt=Ae+_t,lt=Ne+Re,Mt=Ae-_t,tn=Ne-Re,an=Ve+nt,Ft=Ee+ct,or=C*(Ve-nt),Or=C*(Ee-ct);if(S[R]=pt+an,S[R+1]=lt+Ft,S[Q]=Mt+Or,S[Q+1]=tn-or,q===0){S[G]=pt-an,S[G+1]=lt-Ft;continue}if(q===_e)continue;const Br=ee+ie-q,$r=ee+te-q;S[Br]=Mt-C*Or,S[Br+1]=-tn-C*or,S[$r]=pt-C*an,S[$r+1]=-lt+C*Ft}}const W=D>>>1;for(let te=2;te<W;te+=2)S[D-te]=S[te],S[D-te+1]=-S[te+1]}_singleRealTransform2(S,k,C,D,V){const U=S[D],ne=S[D+V];k[C]=U+ne,k[C+1]=0,k[C+2]=U-ne,k[C+3]=0}_singleRealTransform4(S,k,C,D,V,U){const ne=V*2,ee=V*3,H=S[D],oe=S[D+V],ae=S[D+ne],W=S[D+ee],te=H+ae,ie=H-ae,_e=oe+W,q=U*(oe-W);k[C]=te+_e,k[C+1]=0,k[C+2]=ie,k[C+3]=-q,k[C+4]=te-_e,k[C+5]=0,k[C+6]=ie,k[C+7]=q}}class v{constructor(S){const k=2*(S-1),C=2*(2*S-1),D=2**Math.ceil(Math.log2(C));this.bufferSize=D,this._a=k;const V=new Float64Array(C),U=new Float64Array(D);this._chirpBuffer=new Float64Array(D),this._buffer1=new Float64Array(D),this._buffer2=new Float64Array(D),this._outBuffer1=new Float64Array(D),this._outBuffer2=new Float64Array(D);const ne=-2*Math.PI/S,ee=Math.cos(ne),H=Math.sin(ne);for(let oe=0;oe<C>>1;++oe){const ae=(oe+1-S)**2/2,W=Math.sqrt(ee**2+H**2)**ae,te=ae*Math.atan2(H,ee),ie=2*oe;V[ie]=W*Math.cos(te),V[ie+1]=W*Math.sin(te),U[ie]=V[ie],U[ie+1]=-V[ie+1]}this._slicedChirpBuffer=V.subarray(k,C),this._f=new y(D>>1),this._f.transform(this._chirpBuffer,U)}_transform(S,k,C){const D=this._buffer1,V=this._buffer2,U=this._outBuffer1,ne=this._outBuffer2,ee=this._chirpBuffer,H=this._slicedChirpBuffer,oe=this._a;if(C)for(let ae=0;ae<H.length;ae+=2){const W=ae+1,te=ae>>1,ie=k[te];D[ae]=ie*H[ae],D[W]=ie*H[W]}else for(let ae=0;ae<H.length;ae+=2){const W=ae+1;D[ae]=k[ae]*H[ae]-k[W]*H[W],D[W]=k[ae]*H[W]+k[W]*H[ae]}this._f.transform(U,D);for(let ae=0;ae<ee.length;ae+=2){const W=ae+1;V[ae]=U[ae]*ee[ae]-U[W]*ee[W],V[W]=U[ae]*ee[W]+U[W]*ee[ae]}this._f.inverseTransform(ne,V);for(let ae=0;ae<ne.length;ae+=2){const W=ne[ae+oe],te=ne[ae+oe+1],ie=H[ae],_e=H[ae+1];S[ae]=W*ie-te*_e,S[ae+1]=W*_e+te*ie}}transform(S,k){this._transform(S,k,!1)}realTransform(S,k){this._transform(S,k,!0)}}class x{constructor(S){this.fft_length=S,this.isPowerOfTwo=p(S),this.isPowerOfTwo?(this.fft=new y(S),this.outputBufferSize=2*S):(this.fft=new v(S),this.outputBufferSize=this.fft.bufferSize)}realTransform(S,k){this.fft.realTransform(S,k)}transform(S,k){this.fft.transform(S,k)}}function L(P,S){if(S%2===0||S<=0)throw new Error("Window size must be a positive odd number");const k=new P.constructor(P.length),C=new P.constructor(S),D=Math.floor(S/2);for(let V=0;V<P.length;++V){let U=0;for(let ne=-D;ne<=D;++ne){let ee=V+ne;ee<0?ee=Math.abs(ee):ee>=P.length&&(ee=2*(P.length-1)-ee),C[U++]=P[ee]}C.sort(),k[V]=C[D]}return k}function T(P,S){const k=Math.pow(10,S);return Math.round(P*k)/k}function E(P){const S=Math.round(P);return Math.abs(P)%1===.5?S%2===0?S:S-1:S}function I(P){const S=P.length,k=P[0].length,C=[S+1,k+1],D=Array.from({length:C[0]},()=>Array(C[1]).fill(1/0));D[0][0]=0;const V=Array.from({length:C[0]},()=>Array(C[1]).fill(-1));for(let oe=1;oe<C[1];++oe)for(let ae=1;ae<C[0];++ae){const W=D[ae-1][oe-1],te=D[ae-1][oe],ie=D[ae][oe-1];let _e,q;W<te&&W<ie?(_e=W,q=0):te<W&&te<ie?(_e=te,q=1):(_e=ie,q=2),D[ae][oe]=P[ae-1][oe-1]+_e,V[ae][oe]=q}for(let oe=0;oe<C[1];++oe)V[0][oe]=2;for(let oe=0;oe<C[0];++oe)V[oe][0]=1;let U=S,ne=k,ee=[],H=[];for(;U>0||ne>0;)switch(ee.push(U-1),H.push(ne-1),V[U][ne]){case 0:--U,--ne;break;case 1:--U;break;case 2:--ne;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${U}, ${ne}]. Please file a bug report.`)}return ee.reverse(),H.reverse(),[ee,H]}}),"./src/utils/tensor.js":((e,n,t)=>{t.r(n),t.d(n,{DataTypeMap:()=>u,Tensor:()=>d,cat:()=>k,full:()=>H,full_like:()=>oe,interpolate:()=>_,interpolate_4d:()=>m,layer_norm:()=>E,matmul:()=>p,mean:()=>U,mean_pooling:()=>T,ones:()=>ae,ones_like:()=>W,permute:()=>h,quantize_embeddings:()=>q,rand:()=>_e,rfft:()=>y,slice:()=>L,stack:()=>C,std_mean:()=>V,topk:()=>v,zeros:()=>te,zeros_like:()=>ie});var a=t("./src/utils/maths.js"),i=t("./src/backends/onnx.js"),l=t("./src/ops/registry.js");const u=Object.freeze({float32:Float32Array,float16:typeof Float16Array<"u"?Float16Array:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class d{get dims(){return this.ort_tensor.dims}set dims(R){this.ort_tensor.dims=R}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}ort_tensor;constructor(...R){return(0,i.isONNXTensor)(R[0])?this.ort_tensor=R[0]:this.ort_tensor=new i.Tensor(R[0],R[1],R[2]),new Proxy(this,{get:(Q,G)=>{if(typeof G=="string"){let fe=Number(G);if(Number.isInteger(fe))return Q._getitem(fe)}return Q[G]},set:(Q,G,fe)=>Q[G]=fe})}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[R,...Q]=this.dims;if(Q.length>0){const G=Q.reduce((fe,Te)=>fe*Te);for(let fe=0;fe<R;++fe)yield this._subarray(fe,G,Q)}else yield*this.data}_getitem(R){const[Q,...G]=this.dims;if(R=S(R,Q),G.length>0){const fe=G.reduce((Te,ze)=>Te*ze);return this._subarray(R,fe,G)}else return new d(this.type,[this.data[R]],G)}indexOf(R){const Q=this.data;for(let G=0;G<Q.length;++G)if(Q[G]==R)return G;return-1}_subarray(R,Q,G){const fe=R*Q,Te=(R+1)*Q,ze="subarray"in this.data?this.data.subarray(fe,Te):this.data.slice(fe,Te);return new d(this.type,ze,G)}item(){const R=this.data;if(R.length!==1)throw new Error(`a Tensor with ${R.length} elements cannot be converted to Scalar`);return R[0]}tolist(){return f(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const R=this.data;for(let Q=0;Q<R.length;++Q)R[Q]=1/(1+Math.exp(-R[Q]));return this}map(R){return this.clone().map_(R)}map_(R){const Q=this.data;for(let G=0;G<Q.length;++G)Q[G]=R(Q[G],G,Q);return this}mul(R){return this.clone().mul_(R)}mul_(R){const Q=this.data;for(let G=0;G<Q.length;++G)Q[G]*=R;return this}div(R){return this.clone().div_(R)}div_(R){const Q=this.data;for(let G=0;G<Q.length;++G)Q[G]/=R;return this}add(R){return this.clone().add_(R)}add_(R){const Q=this.data;for(let G=0;G<Q.length;++G)Q[G]+=R;return this}sub(R){return this.clone().sub_(R)}sub_(R){const Q=this.data;for(let G=0;G<Q.length;++G)Q[G]-=R;return this}clone(){return new d(this.type,this.data.slice(),this.dims.slice())}slice(...R){const Q=[],G=[];for(let le=0;le<this.dims.length;++le){let J=R[le];if(J==null)G.push([0,this.dims[le]]),Q.push(this.dims[le]);else if(typeof J=="number")J=S(J,this.dims[le],le),G.push([J,J+1]);else if(Array.isArray(J)&&J.length===2){let[be,Ae]=J;if(be=be===null?0:S(be,this.dims[le],le,!1),Ae=Ae===null?this.dims[le]:S(Ae,this.dims[le],le,!1),be>Ae)throw new Error(`Invalid slice: ${J}`);const Ne=[Math.max(be,0),Math.min(Ae,this.dims[le])];G.push(Ne),Q.push(Ne[1]-Ne[0])}else throw new Error(`Invalid slice: ${J}`)}const fe=G.map(([le,J])=>J-le),Te=fe.reduce((le,J)=>le*J),ze=this.data,Ue=new ze.constructor(Te),ft=this.stride();let je=!0;for(let le=1;le<fe.length;++le)if(G[le][0]!==0||G[le][1]!==this.dims[le]){je=!1;break}if(je){const le=G[0][0]*ft[0],J=G[0][1]*ft[0];if(ArrayBuffer.isView(ze))Ue.set(ze.subarray(le,J));else if(Array.isArray(ze)){const be=ze.slice(le,J);for(let Ae=0;Ae<be.length;++Ae)Ue[Ae]=be[Ae]}else throw new Error("Unsupported data type for slicing")}else for(let le=0;le<Te;++le){let J=0;for(let be=fe.length-1,Ae=le;be>=0;--be){const Ne=fe[be];J+=(Ae%Ne+G[be][0])*ft[be],Ae=Math.floor(Ae/Ne)}Ue[le]=ze[J]}return new d(this.type,Ue,Q)}permute(...R){return h(this,R)}transpose(...R){return this.permute(...R)}sum(R=null,Q=!1){return this.norm(1,R,Q)}norm(R="fro",Q=null,G=!1){if(R==="fro")R=2;else if(typeof R=="string")throw Error(`Unsupported norm: ${R}`);const fe=this.data,Te=(je,le)=>je+le**R;if(Q===null){const je=fe.reduce(Te,0)**(1/R);return new d(this.type,[je],[])}const[ze,Ue,ft]=D(Te,this,Q,G);if(R!==1)for(let je=0;je<Ue.length;++je)Ue[je]=Ue[je]**(1/R);return new d(ze,Ue,ft)}normalize_(R=2,Q=1){Q=S(Q,this.dims.length);const G=this.norm(R,Q,!0),fe=this.data,Te=G.data;for(let ze=0;ze<fe.length;++ze){let Ue=0;for(let ft=this.dims.length-1,je=ze,le=1;ft>=0;--ft){const J=this.dims[ft];if(ft!==Q){const be=je%J;Ue+=be*le,le*=this.dims[ft]}je=Math.floor(je/J)}fe[ze]/=Te[Ue]}return this}normalize(R=2,Q=1){return this.clone().normalize_(R,Q)}stride(){return ne(this.dims)}squeeze(R=null){return new d(this.type,this.data,I(this.dims,R))}squeeze_(R=null){return this.dims=I(this.dims,R),this}unsqueeze(R=null){return new d(this.type,this.data,P(this.dims,R))}unsqueeze_(R=null){return this.dims=P(this.dims,R),this}flatten_(R=0,Q=-1){Q=(Q+this.dims.length)%this.dims.length;let G=this.dims.slice(0,R),fe=this.dims.slice(R,Q+1),Te=this.dims.slice(Q+1);return this.dims=[...G,fe.reduce((ze,Ue)=>ze*Ue,1),...Te],this}flatten(R=0,Q=-1){return this.clone().flatten_(R,Q)}view(...R){let Q=-1;for(let fe=0;fe<R.length;++fe)if(R[fe]===-1){if(Q!==-1)throw new Error("Only one dimension can be inferred");Q=fe}const G=this.data;if(Q!==-1){const fe=R.reduce((Te,ze,Ue)=>Ue!==Q?Te*ze:Te,1);R[Q]=G.length/fe}return new d(this.type,G,R)}neg_(){const R=this.data;for(let Q=0;Q<R.length;++Q)R[Q]=-R[Q];return this}neg(){return this.clone().neg_()}gt(R){const Q=new Uint8Array(this.data.length),G=this.data;for(let fe=0;fe<G.length;++fe)Q[fe]=G[fe]>R?1:0;return new d("bool",Q,this.dims)}lt(R){const Q=new Uint8Array(this.data.length),G=this.data;for(let fe=0;fe<G.length;++fe)Q[fe]=G[fe]<R?1:0;return new d("bool",Q,this.dims)}clamp_(R,Q){const G=this.data;for(let fe=0;fe<G.length;++fe)G[fe]=Math.min(Math.max(G[fe],R),Q);return this}clamp(R,Q){return this.clone().clamp_(R,Q)}round_(){const R=this.data;for(let Q=0;Q<R.length;++Q)R[Q]=Math.round(R[Q]);return this}round(){return this.clone().round_()}mean(R=null,Q=!1){return U(this,R,Q)}min(R=null,Q=!1){if(R===null){const ze=(0,a.min)(this.data)[0];return new d(this.type,[ze],[])}const[G,fe,Te]=D((ze,Ue)=>Math.min(ze,Ue),this,R,Q,1/0);return new d(G,fe,Te)}max(R=null,Q=!1){if(R===null){const ze=(0,a.max)(this.data)[0];return new d(this.type,[ze],[])}const[G,fe,Te]=D((ze,Ue)=>Math.max(ze,Ue),this,R,Q,-1/0);return new d(G,fe,Te)}argmin(R=null,Q=!1){if(R!==null)throw new Error("`dim !== null` not yet implemented.");const G=(0,a.min)(this.data)[1];return new d("int64",[BigInt(G)],[])}argmax(R=null,Q=!1){if(R!==null)throw new Error("`dim !== null` not yet implemented.");const G=(0,a.max)(this.data)[1];return new d("int64",[BigInt(G)],[])}to(R){if(this.type===R)return this;if(!u.hasOwnProperty(R))throw new Error(`Unsupported type: ${R}`);let Q;const G=["int64","uint64"].includes(this.type),fe=["int64","uint64"].includes(R);return G&&!fe?Q=Number:!G&&fe&&(Q=BigInt),new d(R,u[R].from(this.data,Q),this.dims)}}function f(B,R){const Q=B.length,G=R.reduce((Te,ze)=>Te*ze);if(Q!==G)throw Error(`cannot reshape array of size ${Q} into shape (${R})`);let fe=B;for(let Te=R.length-1;Te>=0;Te--)fe=fe.reduce((ze,Ue)=>{let ft=ze[ze.length-1];return ft.length<R[Te]?ft.push(Ue):ze.push([Ue]),ze},[[]]);return fe[0]}function h(B,R){const[Q,G]=(0,a.permute_data)(B.data,B.dims,R);return new d(B.type,Q,G)}function _(B,[R,Q],G="bilinear",fe=!1){const Te=B.dims.at(-3)??1,ze=B.dims.at(-2),Ue=B.dims.at(-1);let ft=(0,a.interpolate_data)(B.data,[Te,ze,Ue],[R,Q],G,fe);return new d(B.type,ft,[Te,R,Q])}async function m(B,{size:R=null,mode:Q="bilinear"}={}){if(B.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!R)throw new Error("`interpolate_4d` requires a `size` argument.");let G;if(R.length===2)G=[...B.dims.slice(0,2),...R];else if(R.length===3)G=[B.dims[0],...R];else if(R.length===4)G=R;else throw new Error("`size` must be of length 2, 3, or 4.");let fe;if(Q==="nearest")fe=await l.TensorOpRegistry.nearest_interpolate_4d;else if(Q==="bilinear")fe=await l.TensorOpRegistry.bilinear_interpolate_4d;else if(Q==="bicubic")fe=await l.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${Q}`);const Te=new d("int64",new BigInt64Array(G.map(BigInt)),[G.length]);return await fe({x:B,s:Te})}async function p(B,R){return await(await l.TensorOpRegistry.matmul)({a:B,b:R})}async function y(B,R){return await(await l.TensorOpRegistry.rfft)({x:B,a:R})}async function v(B,R){const Q=await l.TensorOpRegistry.top_k;return R==null?R=B.dims.at(-1):R=Math.min(R,B.dims.at(-1)),await Q({x:B,k:new d("int64",[BigInt(R)],[1])})}const x=B=>new d("int64",B,[B.length]);async function L(B,R,Q,G,fe){return await(await l.TensorOpRegistry.slice)({x:B,s:x(R),e:x(Q),a:x(G),t:x(fe??new Array(G.length).fill(1))})}function T(B,R){const Q=B.data,G=R.data,fe=[B.dims[0],B.dims[2]],Te=new Q.constructor(fe[0]*fe[1]),[ze,Ue,ft]=B.dims;let je=0;for(let le=0;le<ze;++le){const J=le*ft*Ue;for(let be=0;be<ft;++be){let Ae=0,Ne=0;const De=le*Ue,xe=J+be;for(let Ee=0;Ee<Ue;++Ee){const Ge=Number(G[De+Ee]);Ne+=Ge,Ae+=Q[xe+Ee*ft]*Ge}const Ve=Ae/Ne;Te[je++]=Ve}}return new d(B.type,Te,fe)}function E(B,R,{eps:Q=1e-5}={}){if(B.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[G,fe]=B.dims;if(R.length!==1&&R[0]!==fe)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[Te,ze]=V(B,1,0,!0),Ue=Te.data,ft=ze.data,je=B.data,le=new je.constructor(je.length);for(let J=0;J<G;++J){const be=J*fe;for(let Ae=0;Ae<fe;++Ae){const Ne=be+Ae;le[Ne]=(je[Ne]-ft[J])/(Ue[J]+Q)}}return new d(B.type,le,B.dims)}function I(B,R){return B=B.slice(),R===null?B=B.filter(Q=>Q!==1):typeof R=="number"?B[R]===1&&B.splice(R,1):Array.isArray(R)&&(B=B.filter((Q,G)=>Q!==1||!R.includes(G))),B}function P(B,R){return R=S(R,B.length+1),B=B.slice(),B.splice(R,0,1),B}function S(B,R,Q=null,G=!0){if(B<-R||B>=R){if(G)throw new Error(`IndexError: index ${B} is out of bounds for dimension${Q===null?"":" "+Q} with size ${R}`);return B<-R?0:R}return B<0&&(B=(B%R+R)%R),B}function k(B,R=0){R=S(R,B[0].dims.length);const Q=B[0].dims.slice();Q[R]=B.reduce((ze,Ue)=>ze+Ue.dims[R],0);const G=Q.reduce((ze,Ue)=>ze*Ue,1),fe=new B[0].data.constructor(G),Te=B[0].type;if(R===0){let ze=0;for(const Ue of B){const ft=Ue.data;fe.set(ft,ze),ze+=ft.length}}else{let ze=0;for(let Ue=0;Ue<B.length;++Ue){const{data:ft,dims:je}=B[Ue];for(let le=0;le<ft.length;++le){let J=0;for(let be=je.length-1,Ae=le,Ne=1;be>=0;--be){const De=je[be];let xe=Ae%De;be===R&&(xe+=ze),J+=xe*Ne,Ne*=Q[be],Ae=Math.floor(Ae/De)}fe[J]=ft[le]}ze+=je[R]}}return new d(Te,fe,Q)}function C(B,R=0){return k(B.map(Q=>Q.unsqueeze(R)),R)}function D(B,R,Q=null,G=!1,fe=null){const Te=R.data,ze=R.dims;Q=S(Q,ze.length);const Ue=ze.slice();Ue[Q]=1;const ft=new Te.constructor(Te.length/ze[Q]);fe!==null&&ft.fill(fe);for(let je=0;je<Te.length;++je){let le=0;for(let J=ze.length-1,be=je,Ae=1;J>=0;--J){const Ne=ze[J];if(J!==Q){const De=be%Ne;le+=De*Ae,Ae*=Ue[J]}be=Math.floor(be/Ne)}ft[le]=B(ft[le],Te[je],je,le)}return G||Ue.splice(Q,1),[R.type,ft,Ue]}function V(B,R=null,Q=1,G=!1){const fe=B.data,Te=B.dims;if(R===null){const Ae=fe.reduce((Ve,Ee)=>Ve+Ee,0)/fe.length,Ne=Math.sqrt(fe.reduce((Ve,Ee)=>Ve+(Ee-Ae)**2,0)/(fe.length-Q)),De=new d(B.type,[Ae],[]);return[new d(B.type,[Ne],[]),De]}R=S(R,Te.length);const ze=U(B,R,G),Ue=ze.data,[ft,je,le]=D((be,Ae,Ne,De)=>be+(Ae-Ue[De])**2,B,R,G);for(let be=0;be<je.length;++be)je[be]=Math.sqrt(je[be]/(Te[R]-Q));return[new d(ft,je,le),ze]}function U(B,R=null,Q=!1){const G=B.dims,fe=B.data;if(R===null){const ft=fe.reduce((je,le)=>je+le,0);return new d(B.type,[ft/fe.length],[])}R=S(R,G.length);const[Te,ze,Ue]=D((ft,je)=>ft+je,B,R,Q);if(G[R]!==1)for(let ft=0;ft<ze.length;++ft)ze[ft]/=G[R];return new d(Te,ze,Ue)}function ne(B){const R=new Array(B.length);for(let Q=B.length-1,G=1;Q>=0;--Q)R[Q]=G,G*=B[Q];return R}function ee(B,R,Q,G){const fe=B.reduce((Te,ze)=>Te*ze,1);return new d(Q,new G(fe).fill(R),B)}function H(B,R){let Q,G;if(typeof R=="number")Q="float32",G=Float32Array;else if(typeof R=="bigint")Q="int64",G=BigInt64Array;else if(typeof R=="boolean")Q="bool",G=Uint8Array;else throw new Error(`Unsupported data type: ${typeof R}`);return ee(B,R,Q,G)}function oe(B,R){return H(B.dims,R)}function ae(B){return ee(B,1n,"int64",BigInt64Array)}function W(B){return ae(B.dims)}function te(B){return ee(B,0n,"int64",BigInt64Array)}function ie(B){return te(B.dims)}function _e(B){const R=B.reduce((Q,G)=>Q*G,1);return new d("float32",Float32Array.from({length:R},()=>Math.random()),B)}function q(B,R){if(B.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(B.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(R))throw new Error("The precision must be either 'binary' or 'ubinary'");const Q=R==="binary",G=Q?"int8":"uint8",fe=Q?Int8Array:Uint8Array,Te=B.data,ze=new fe(Te.length/8);for(let Ue=0;Ue<Te.length;++Ue){const ft=Te[Ue]>0?1:0,je=Math.floor(Ue/8),le=Ue%8;ze[je]|=ft<<7-le,Q&&le===0&&(ze[je]-=128)}return new d(G,ze,[B.dims[0],B.dims[1]/8])}}),"./src/utils/video.js":((e,n,t)=>{t.r(n),t.d(n,{RawVideo:()=>u,RawVideoFrame:()=>l,load_video:()=>d});var a=t("./src/utils/image.js"),i=t("./src/env.js");class l{constructor(h,_){this.image=h,this.timestamp=_}}class u{constructor(h,_){h.length>0&&h[0]instanceof a.RawImage&&(h=h.map((m,p)=>new l(m,(p+1)/(h.length+1)*_))),this.frames=h,this.duration=_}get width(){return this.frames[0].image.width}get height(){return this.frames[0].image.height}get fps(){return this.frames.length/this.duration}}async function d(f,{num_frames:h=null,fps:_=null}={}){if(!i.apis.IS_BROWSER_ENV)throw new Error("`load_video` is currently only supported in browser environments.");if(h==null&&_==null)throw new Error("Either num_frames or fps must be provided.");const m=[],p=document.createElement("video");if(p.crossOrigin="anonymous",p.muted=!0,typeof f=="string")p.src=f;else if(f instanceof Blob)p.src=URL.createObjectURL(f);else if(f instanceof HTMLVideoElement)p.src=f.src;else throw new Error("Invalid URL or video element provided.");if(await new Promise(I=>p.onloadedmetadata=I),p.seekable.start(0)===p.seekable.end(0)){const P=await(await fetch(p.src)).blob();p.src=URL.createObjectURL(P),await new Promise(S=>p.onloadedmetadata=S)}const y=p.duration;let v,x;h!=null?(v=h,x=h===1?0:y/(h-1)):(x=1/_,v=Math.floor(y/x));let L=[];for(let I=0;I<v;++I)L.push(h===1?y/2:I*x);const T=document.createElement("canvas");T.width=p.videoWidth,T.height=p.videoHeight;const E=T.getContext("2d",{willReadFrequently:!0});for(const I of L){p.currentTime=I,await new Promise(C=>{p.onseeked=C}),E.drawImage(p,0,0,T.width,T.height);const P=E.getImageData(0,0,T.width,T.height),S=new a.RawImage(P.data,T.width,T.height,4),k=new l(S,I);m.push(k)}return p.remove(),new u(m,y)}})},X2={};function An(e){var n=X2[e];if(n!==void 0)return n.exports;var t=X2[e]={exports:{}};return R$[e](t,t.exports,An),t.exports}(()=>{var e=Object.getPrototypeOf?t=>Object.getPrototypeOf(t):t=>t.__proto__,n;An.t=function(t,a){if(a&1&&(t=this(t)),a&8||typeof t=="object"&&t&&(a&4&&t.__esModule||a&16&&typeof t.then=="function"))return t;var i=Object.create(null);An.r(i);var l={};n=n||[null,e({}),e([]),e(e)];for(var u=a&2&&t;typeof u=="object"&&!~n.indexOf(u);u=e(u))Object.getOwnPropertyNames(u).forEach(d=>l[d]=()=>t[d]);return l.default=()=>t,An.d(i,l),i}})();An.d=(e,n)=>{for(var t in n)An.o(n,t)&&!An.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})};An.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n);An.r=e=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var w={};(()=>{/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/An.r(w),An.d(w,{ASTFeatureExtractor:()=>m.ASTFeatureExtractor,ASTForAudioClassification:()=>t.ASTForAudioClassification,ASTModel:()=>t.ASTModel,ASTPreTrainedModel:()=>t.ASTPreTrainedModel,AlbertForMaskedLM:()=>t.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>t.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>t.AlbertForSequenceClassification,AlbertModel:()=>t.AlbertModel,AlbertPreTrainedModel:()=>t.AlbertPreTrainedModel,AlbertTokenizer:()=>a.AlbertTokenizer,ArceeForCausalLM:()=>t.ArceeForCausalLM,ArceeModel:()=>t.ArceeModel,ArceePreTrainedModel:()=>t.ArceePreTrainedModel,AudioClassificationPipeline:()=>n.AudioClassificationPipeline,AutoConfig:()=>i.AutoConfig,AutoFeatureExtractor:()=>p.AutoFeatureExtractor,AutoImageProcessor:()=>x.AutoImageProcessor,AutoModel:()=>t.AutoModel,AutoModelForAudioClassification:()=>t.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>t.AutoModelForAudioFrameClassification,AutoModelForAudioTextToText:()=>t.AutoModelForAudioTextToText,AutoModelForCTC:()=>t.AutoModelForCTC,AutoModelForCausalLM:()=>t.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>t.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>t.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>t.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>t.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>t.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>t.AutoModelForImageSegmentation,AutoModelForImageTextToText:()=>t.AutoModelForImageTextToText,AutoModelForImageToImage:()=>t.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>t.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>t.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>t.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>t.AutoModelForObjectDetection,AutoModelForPoseEstimation:()=>t.AutoModelForPoseEstimation,AutoModelForQuestionAnswering:()=>t.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>t.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>t.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>t.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>t.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>t.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>t.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>t.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>t.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>t.AutoModelForVision2Seq,AutoModelForXVector:()=>t.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>t.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>E.AutoProcessor,AutoTokenizer:()=>a.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>n.AutomaticSpeechRecognitionPipeline,BackgroundRemovalPipeline:()=>n.BackgroundRemovalPipeline,BartForConditionalGeneration:()=>t.BartForConditionalGeneration,BartForSequenceClassification:()=>t.BartForSequenceClassification,BartModel:()=>t.BartModel,BartPretrainedModel:()=>t.BartPretrainedModel,BartTokenizer:()=>a.BartTokenizer,BaseModelOutput:()=>t.BaseModelOutput,BaseStreamer:()=>I.BaseStreamer,BeitFeatureExtractor:()=>v.BeitFeatureExtractor,BeitForImageClassification:()=>t.BeitForImageClassification,BeitModel:()=>t.BeitModel,BeitPreTrainedModel:()=>t.BeitPreTrainedModel,BertForMaskedLM:()=>t.BertForMaskedLM,BertForQuestionAnswering:()=>t.BertForQuestionAnswering,BertForSequenceClassification:()=>t.BertForSequenceClassification,BertForTokenClassification:()=>t.BertForTokenClassification,BertModel:()=>t.BertModel,BertPreTrainedModel:()=>t.BertPreTrainedModel,BertTokenizer:()=>a.BertTokenizer,BitImageProcessor:()=>v.BitImageProcessor,BlenderbotForConditionalGeneration:()=>t.BlenderbotForConditionalGeneration,BlenderbotModel:()=>t.BlenderbotModel,BlenderbotPreTrainedModel:()=>t.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>t.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>t.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>t.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>a.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>a.BlenderbotTokenizer,BloomForCausalLM:()=>t.BloomForCausalLM,BloomModel:()=>t.BloomModel,BloomPreTrainedModel:()=>t.BloomPreTrainedModel,BloomTokenizer:()=>a.BloomTokenizer,CLIPFeatureExtractor:()=>v.CLIPFeatureExtractor,CLIPImageProcessor:()=>v.CLIPImageProcessor,CLIPModel:()=>t.CLIPModel,CLIPPreTrainedModel:()=>t.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>t.CLIPSegForImageSegmentation,CLIPSegModel:()=>t.CLIPSegModel,CLIPSegPreTrainedModel:()=>t.CLIPSegPreTrainedModel,CLIPTextModel:()=>t.CLIPTextModel,CLIPTextModelWithProjection:()=>t.CLIPTextModelWithProjection,CLIPTokenizer:()=>a.CLIPTokenizer,CLIPVisionModel:()=>t.CLIPVisionModel,CLIPVisionModelWithProjection:()=>t.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>t.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>t.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>t.CamembertForSequenceClassification,CamembertForTokenClassification:()=>t.CamembertForTokenClassification,CamembertModel:()=>t.CamembertModel,CamembertPreTrainedModel:()=>t.CamembertPreTrainedModel,CamembertTokenizer:()=>a.CamembertTokenizer,CausalLMOutput:()=>t.CausalLMOutput,CausalLMOutputWithPast:()=>t.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>v.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>t.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>t.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>t.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>m.ClapFeatureExtractor,ClapModel:()=>t.ClapModel,ClapPreTrainedModel:()=>t.ClapPreTrainedModel,ClapTextModelWithProjection:()=>t.ClapTextModelWithProjection,ClassifierFreeGuidanceLogitsProcessor:()=>S.ClassifierFreeGuidanceLogitsProcessor,CodeGenForCausalLM:()=>t.CodeGenForCausalLM,CodeGenModel:()=>t.CodeGenModel,CodeGenPreTrainedModel:()=>t.CodeGenPreTrainedModel,CodeGenTokenizer:()=>a.CodeGenTokenizer,CodeLlamaTokenizer:()=>a.CodeLlamaTokenizer,CohereForCausalLM:()=>t.CohereForCausalLM,CohereModel:()=>t.CohereModel,CoherePreTrainedModel:()=>t.CoherePreTrainedModel,CohereTokenizer:()=>a.CohereTokenizer,ConvBertForMaskedLM:()=>t.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>t.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>t.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>t.ConvBertForTokenClassification,ConvBertModel:()=>t.ConvBertModel,ConvBertPreTrainedModel:()=>t.ConvBertPreTrainedModel,ConvBertTokenizer:()=>a.ConvBertTokenizer,ConvNextFeatureExtractor:()=>v.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>t.ConvNextForImageClassification,ConvNextImageProcessor:()=>v.ConvNextImageProcessor,ConvNextModel:()=>t.ConvNextModel,ConvNextPreTrainedModel:()=>t.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>t.ConvNextV2ForImageClassification,ConvNextV2Model:()=>t.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>t.ConvNextV2PreTrainedModel,DFineForObjectDetection:()=>t.DFineForObjectDetection,DFineModel:()=>t.DFineModel,DFinePreTrainedModel:()=>t.DFinePreTrainedModel,DINOv3ConvNextModel:()=>t.DINOv3ConvNextModel,DINOv3ConvNextPreTrainedModel:()=>t.DINOv3ConvNextPreTrainedModel,DINOv3ViTImageProcessor:()=>v.DINOv3ViTImageProcessor,DINOv3ViTModel:()=>t.DINOv3ViTModel,DINOv3ViTPreTrainedModel:()=>t.DINOv3ViTPreTrainedModel,DPTFeatureExtractor:()=>v.DPTFeatureExtractor,DPTForDepthEstimation:()=>t.DPTForDepthEstimation,DPTImageProcessor:()=>v.DPTImageProcessor,DPTModel:()=>t.DPTModel,DPTPreTrainedModel:()=>t.DPTPreTrainedModel,DacDecoderModel:()=>t.DacDecoderModel,DacDecoderOutput:()=>t.DacDecoderOutput,DacEncoderModel:()=>t.DacEncoderModel,DacEncoderOutput:()=>t.DacEncoderOutput,DacFeatureExtractor:()=>m.DacFeatureExtractor,DacModel:()=>t.DacModel,DacPreTrainedModel:()=>t.DacPreTrainedModel,DataTypeMap:()=>f.DataTypeMap,DebertaForMaskedLM:()=>t.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>t.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>t.DebertaForSequenceClassification,DebertaForTokenClassification:()=>t.DebertaForTokenClassification,DebertaModel:()=>t.DebertaModel,DebertaPreTrainedModel:()=>t.DebertaPreTrainedModel,DebertaTokenizer:()=>a.DebertaTokenizer,DebertaV2ForMaskedLM:()=>t.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>t.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>t.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>t.DebertaV2ForTokenClassification,DebertaV2Model:()=>t.DebertaV2Model,DebertaV2PreTrainedModel:()=>t.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>a.DebertaV2Tokenizer,DecisionTransformerModel:()=>t.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>t.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>v.DeiTFeatureExtractor,DeiTForImageClassification:()=>t.DeiTForImageClassification,DeiTImageProcessor:()=>v.DeiTImageProcessor,DeiTModel:()=>t.DeiTModel,DeiTPreTrainedModel:()=>t.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>t.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>t.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>n.DepthEstimationPipeline,DepthProForDepthEstimation:()=>t.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>t.DepthProPreTrainedModel,DetrFeatureExtractor:()=>v.DetrFeatureExtractor,DetrForObjectDetection:()=>t.DetrForObjectDetection,DetrForSegmentation:()=>t.DetrForSegmentation,DetrImageProcessor:()=>v.DetrImageProcessor,DetrModel:()=>t.DetrModel,DetrObjectDetectionOutput:()=>t.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>t.DetrPreTrainedModel,DetrSegmentationOutput:()=>t.DetrSegmentationOutput,Dinov2ForImageClassification:()=>t.Dinov2ForImageClassification,Dinov2Model:()=>t.Dinov2Model,Dinov2PreTrainedModel:()=>t.Dinov2PreTrainedModel,Dinov2WithRegistersForImageClassification:()=>t.Dinov2WithRegistersForImageClassification,Dinov2WithRegistersModel:()=>t.Dinov2WithRegistersModel,Dinov2WithRegistersPreTrainedModel:()=>t.Dinov2WithRegistersPreTrainedModel,DistilBertForMaskedLM:()=>t.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>t.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>t.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>t.DistilBertForTokenClassification,DistilBertModel:()=>t.DistilBertModel,DistilBertPreTrainedModel:()=>t.DistilBertPreTrainedModel,DistilBertTokenizer:()=>a.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>n.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>v.DonutFeatureExtractor,DonutImageProcessor:()=>v.DonutImageProcessor,DonutSwinModel:()=>t.DonutSwinModel,DonutSwinPreTrainedModel:()=>t.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>t.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>v.EfficientNetImageProcessor,EfficientNetModel:()=>t.EfficientNetModel,EfficientNetPreTrainedModel:()=>t.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>t.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>t.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>t.ElectraForSequenceClassification,ElectraForTokenClassification:()=>t.ElectraForTokenClassification,ElectraModel:()=>t.ElectraModel,ElectraPreTrainedModel:()=>t.ElectraPreTrainedModel,ElectraTokenizer:()=>a.ElectraTokenizer,EncodecFeatureExtractor:()=>m.EncodecFeatureExtractor,EosTokenCriteria:()=>P.EosTokenCriteria,Ernie4_5_ForCausalLM:()=>t.Ernie4_5_ForCausalLM,Ernie4_5_Model:()=>t.Ernie4_5_Model,Ernie4_5_PretrainedModel:()=>t.Ernie4_5_PretrainedModel,Ernie4_5_Tokenizer:()=>a.Ernie4_5_Tokenizer,EsmForMaskedLM:()=>t.EsmForMaskedLM,EsmForSequenceClassification:()=>t.EsmForSequenceClassification,EsmForTokenClassification:()=>t.EsmForTokenClassification,EsmModel:()=>t.EsmModel,EsmPreTrainedModel:()=>t.EsmPreTrainedModel,EsmTokenizer:()=>a.EsmTokenizer,ExaoneForCausalLM:()=>t.ExaoneForCausalLM,ExaoneModel:()=>t.ExaoneModel,ExaonePreTrainedModel:()=>t.ExaonePreTrainedModel,FFT:()=>h.FFT,FalconForCausalLM:()=>t.FalconForCausalLM,FalconModel:()=>t.FalconModel,FalconPreTrainedModel:()=>t.FalconPreTrainedModel,FalconTokenizer:()=>a.FalconTokenizer,FastViTForImageClassification:()=>t.FastViTForImageClassification,FastViTModel:()=>t.FastViTModel,FastViTPreTrainedModel:()=>t.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>n.FeatureExtractionPipeline,FeatureExtractor:()=>_.FeatureExtractor,FillMaskPipeline:()=>n.FillMaskPipeline,Florence2ForConditionalGeneration:()=>t.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>t.Florence2PreTrainedModel,Florence2Processor:()=>T.Florence2Processor,ForcedBOSTokenLogitsProcessor:()=>S.ForcedBOSTokenLogitsProcessor,ForcedEOSTokenLogitsProcessor:()=>S.ForcedEOSTokenLogitsProcessor,GLPNFeatureExtractor:()=>v.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>t.GLPNForDepthEstimation,GLPNModel:()=>t.GLPNModel,GLPNPreTrainedModel:()=>t.GLPNPreTrainedModel,GPT2LMHeadModel:()=>t.GPT2LMHeadModel,GPT2Model:()=>t.GPT2Model,GPT2PreTrainedModel:()=>t.GPT2PreTrainedModel,GPT2Tokenizer:()=>a.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>t.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>t.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>t.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>t.GPTJForCausalLM,GPTJModel:()=>t.GPTJModel,GPTJPreTrainedModel:()=>t.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>t.GPTNeoForCausalLM,GPTNeoModel:()=>t.GPTNeoModel,GPTNeoPreTrainedModel:()=>t.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>t.GPTNeoXForCausalLM,GPTNeoXModel:()=>t.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>t.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>a.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>t.Gemma2ForCausalLM,Gemma2Model:()=>t.Gemma2Model,Gemma2PreTrainedModel:()=>t.Gemma2PreTrainedModel,Gemma3ForCausalLM:()=>t.Gemma3ForCausalLM,Gemma3Model:()=>t.Gemma3Model,Gemma3PreTrainedModel:()=>t.Gemma3PreTrainedModel,Gemma3nAudioFeatureExtractor:()=>m.Gemma3nAudioFeatureExtractor,Gemma3nForConditionalGeneration:()=>t.Gemma3nForConditionalGeneration,Gemma3nPreTrainedModel:()=>t.Gemma3nPreTrainedModel,Gemma3nProcessor:()=>T.Gemma3nProcessor,GemmaForCausalLM:()=>t.GemmaForCausalLM,GemmaModel:()=>t.GemmaModel,GemmaPreTrainedModel:()=>t.GemmaPreTrainedModel,GemmaTokenizer:()=>a.GemmaTokenizer,GlmForCausalLM:()=>t.GlmForCausalLM,GlmModel:()=>t.GlmModel,GlmPreTrainedModel:()=>t.GlmPreTrainedModel,GraniteForCausalLM:()=>t.GraniteForCausalLM,GraniteModel:()=>t.GraniteModel,GranitePreTrainedModel:()=>t.GranitePreTrainedModel,Grok1Tokenizer:()=>a.Grok1Tokenizer,GroundingDinoForObjectDetection:()=>t.GroundingDinoForObjectDetection,GroundingDinoImageProcessor:()=>v.GroundingDinoImageProcessor,GroundingDinoPreTrainedModel:()=>t.GroundingDinoPreTrainedModel,GroundingDinoProcessor:()=>T.GroundingDinoProcessor,GroupViTModel:()=>t.GroupViTModel,GroupViTPreTrainedModel:()=>t.GroupViTPreTrainedModel,HeliumForCausalLM:()=>t.HeliumForCausalLM,HeliumModel:()=>t.HeliumModel,HeliumPreTrainedModel:()=>t.HeliumPreTrainedModel,HerbertTokenizer:()=>a.HerbertTokenizer,HieraForImageClassification:()=>t.HieraForImageClassification,HieraModel:()=>t.HieraModel,HieraPreTrainedModel:()=>t.HieraPreTrainedModel,HubertForCTC:()=>t.HubertForCTC,HubertForSequenceClassification:()=>t.HubertForSequenceClassification,HubertModel:()=>t.HubertModel,HubertPreTrainedModel:()=>t.HubertPreTrainedModel,IJepaForImageClassification:()=>t.IJepaForImageClassification,IJepaModel:()=>t.IJepaModel,IJepaPreTrainedModel:()=>t.IJepaPreTrainedModel,Idefics3ForConditionalGeneration:()=>t.Idefics3ForConditionalGeneration,Idefics3ImageProcessor:()=>v.Idefics3ImageProcessor,Idefics3PreTrainedModel:()=>t.Idefics3PreTrainedModel,Idefics3Processor:()=>T.Idefics3Processor,ImageClassificationPipeline:()=>n.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>n.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>m.ImageFeatureExtractor,ImageMattingOutput:()=>t.ImageMattingOutput,ImageProcessor:()=>y.ImageProcessor,ImageSegmentationPipeline:()=>n.ImageSegmentationPipeline,ImageToImagePipeline:()=>n.ImageToImagePipeline,ImageToTextPipeline:()=>n.ImageToTextPipeline,InterruptableStoppingCriteria:()=>P.InterruptableStoppingCriteria,JAISLMHeadModel:()=>t.JAISLMHeadModel,JAISModel:()=>t.JAISModel,JAISPreTrainedModel:()=>t.JAISPreTrainedModel,JinaCLIPImageProcessor:()=>v.JinaCLIPImageProcessor,JinaCLIPModel:()=>t.JinaCLIPModel,JinaCLIPPreTrainedModel:()=>t.JinaCLIPPreTrainedModel,JinaCLIPProcessor:()=>T.JinaCLIPProcessor,JinaCLIPTextModel:()=>t.JinaCLIPTextModel,JinaCLIPVisionModel:()=>t.JinaCLIPVisionModel,Lfm2ForCausalLM:()=>t.Lfm2ForCausalLM,Lfm2Model:()=>t.Lfm2Model,Lfm2PreTrainedModel:()=>t.Lfm2PreTrainedModel,LiteWhisperForConditionalGeneration:()=>t.LiteWhisperForConditionalGeneration,Llama4ForCausalLM:()=>t.Llama4ForCausalLM,Llama4PreTrainedModel:()=>t.Llama4PreTrainedModel,LlamaForCausalLM:()=>t.LlamaForCausalLM,LlamaModel:()=>t.LlamaModel,LlamaPreTrainedModel:()=>t.LlamaPreTrainedModel,LlamaTokenizer:()=>a.LlamaTokenizer,LlavaForConditionalGeneration:()=>t.LlavaForConditionalGeneration,LlavaOnevisionForConditionalGeneration:()=>t.LlavaOnevisionForConditionalGeneration,LlavaOnevisionImageProcessor:()=>v.LlavaOnevisionImageProcessor,LlavaPreTrainedModel:()=>t.LlavaPreTrainedModel,LlavaProcessor:()=>T.LlavaProcessor,LlavaQwen2ForCausalLM:()=>t.LlavaQwen2ForCausalLM,LogitsProcessor:()=>S.LogitsProcessor,LogitsProcessorList:()=>S.LogitsProcessorList,LogitsWarper:()=>S.LogitsWarper,LongT5ForConditionalGeneration:()=>t.LongT5ForConditionalGeneration,LongT5Model:()=>t.LongT5Model,LongT5PreTrainedModel:()=>t.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>t.M2M100ForConditionalGeneration,M2M100Model:()=>t.M2M100Model,M2M100PreTrainedModel:()=>t.M2M100PreTrainedModel,M2M100Tokenizer:()=>a.M2M100Tokenizer,MBart50Tokenizer:()=>a.MBart50Tokenizer,MBartForCausalLM:()=>t.MBartForCausalLM,MBartForConditionalGeneration:()=>t.MBartForConditionalGeneration,MBartForSequenceClassification:()=>t.MBartForSequenceClassification,MBartModel:()=>t.MBartModel,MBartPreTrainedModel:()=>t.MBartPreTrainedModel,MBartTokenizer:()=>a.MBartTokenizer,MPNetForMaskedLM:()=>t.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>t.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>t.MPNetForSequenceClassification,MPNetForTokenClassification:()=>t.MPNetForTokenClassification,MPNetModel:()=>t.MPNetModel,MPNetPreTrainedModel:()=>t.MPNetPreTrainedModel,MPNetTokenizer:()=>a.MPNetTokenizer,MT5ForConditionalGeneration:()=>t.MT5ForConditionalGeneration,MT5Model:()=>t.MT5Model,MT5PreTrainedModel:()=>t.MT5PreTrainedModel,MarianMTModel:()=>t.MarianMTModel,MarianModel:()=>t.MarianModel,MarianPreTrainedModel:()=>t.MarianPreTrainedModel,MarianTokenizer:()=>a.MarianTokenizer,Mask2FormerImageProcessor:()=>v.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>v.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>t.MaskFormerForInstanceSegmentation,MaskFormerImageProcessor:()=>v.MaskFormerImageProcessor,MaskFormerModel:()=>t.MaskFormerModel,MaskFormerPreTrainedModel:()=>t.MaskFormerPreTrainedModel,MaskedLMOutput:()=>t.MaskedLMOutput,MaxLengthCriteria:()=>P.MaxLengthCriteria,Metric3DForDepthEstimation:()=>t.Metric3DForDepthEstimation,Metric3DPreTrainedModel:()=>t.Metric3DPreTrainedModel,Metric3Dv2ForDepthEstimation:()=>t.Metric3Dv2ForDepthEstimation,Metric3Dv2PreTrainedModel:()=>t.Metric3Dv2PreTrainedModel,MgpstrForSceneTextRecognition:()=>t.MgpstrForSceneTextRecognition,MgpstrModelOutput:()=>t.MgpstrModelOutput,MgpstrPreTrainedModel:()=>t.MgpstrPreTrainedModel,MgpstrProcessor:()=>T.MgpstrProcessor,MgpstrTokenizer:()=>a.MgpstrTokenizer,MimiDecoderModel:()=>t.MimiDecoderModel,MimiDecoderOutput:()=>t.MimiDecoderOutput,MimiEncoderModel:()=>t.MimiEncoderModel,MimiEncoderOutput:()=>t.MimiEncoderOutput,MimiModel:()=>t.MimiModel,MimiPreTrainedModel:()=>t.MimiPreTrainedModel,MinLengthLogitsProcessor:()=>S.MinLengthLogitsProcessor,MinNewTokensLengthLogitsProcessor:()=>S.MinNewTokensLengthLogitsProcessor,MistralForCausalLM:()=>t.MistralForCausalLM,MistralModel:()=>t.MistralModel,MistralPreTrainedModel:()=>t.MistralPreTrainedModel,MobileBertForMaskedLM:()=>t.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>t.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>t.MobileBertForSequenceClassification,MobileBertModel:()=>t.MobileBertModel,MobileBertPreTrainedModel:()=>t.MobileBertPreTrainedModel,MobileBertTokenizer:()=>a.MobileBertTokenizer,MobileLLMForCausalLM:()=>t.MobileLLMForCausalLM,MobileLLMModel:()=>t.MobileLLMModel,MobileLLMPreTrainedModel:()=>t.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>v.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>t.MobileNetV1ForImageClassification,MobileNetV1ForSemanticSegmentation:()=>t.MobileNetV1ForSemanticSegmentation,MobileNetV1ImageProcessor:()=>v.MobileNetV1ImageProcessor,MobileNetV1Model:()=>t.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>t.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>v.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>t.MobileNetV2ForImageClassification,MobileNetV2ForSemanticSegmentation:()=>t.MobileNetV2ForSemanticSegmentation,MobileNetV2ImageProcessor:()=>v.MobileNetV2ImageProcessor,MobileNetV2Model:()=>t.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>t.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>v.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>t.MobileNetV3ForImageClassification,MobileNetV3ForSemanticSegmentation:()=>t.MobileNetV3ForSemanticSegmentation,MobileNetV3ImageProcessor:()=>v.MobileNetV3ImageProcessor,MobileNetV3Model:()=>t.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>t.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>v.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>t.MobileNetV4ForImageClassification,MobileNetV4ForSemanticSegmentation:()=>t.MobileNetV4ForSemanticSegmentation,MobileNetV4ImageProcessor:()=>v.MobileNetV4ImageProcessor,MobileNetV4Model:()=>t.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>t.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>v.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>t.MobileViTForImageClassification,MobileViTImageProcessor:()=>v.MobileViTImageProcessor,MobileViTModel:()=>t.MobileViTModel,MobileViTPreTrainedModel:()=>t.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>t.MobileViTV2ForImageClassification,MobileViTV2Model:()=>t.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>t.MobileViTV2PreTrainedModel,ModelOutput:()=>t.ModelOutput,ModernBertDecoderForCausalLM:()=>t.ModernBertDecoderForCausalLM,ModernBertDecoderModel:()=>t.ModernBertDecoderModel,ModernBertDecoderPreTrainedModel:()=>t.ModernBertDecoderPreTrainedModel,ModernBertForMaskedLM:()=>t.ModernBertForMaskedLM,ModernBertForSequenceClassification:()=>t.ModernBertForSequenceClassification,ModernBertForTokenClassification:()=>t.ModernBertForTokenClassification,ModernBertModel:()=>t.ModernBertModel,ModernBertPreTrainedModel:()=>t.ModernBertPreTrainedModel,Moondream1ForConditionalGeneration:()=>t.Moondream1ForConditionalGeneration,MoonshineFeatureExtractor:()=>m.MoonshineFeatureExtractor,MoonshineForConditionalGeneration:()=>t.MoonshineForConditionalGeneration,MoonshineModel:()=>t.MoonshineModel,MoonshinePreTrainedModel:()=>t.MoonshinePreTrainedModel,MoonshineProcessor:()=>T.MoonshineProcessor,MptForCausalLM:()=>t.MptForCausalLM,MptModel:()=>t.MptModel,MptPreTrainedModel:()=>t.MptPreTrainedModel,MultiModalityCausalLM:()=>t.MultiModalityCausalLM,MultiModalityPreTrainedModel:()=>t.MultiModalityPreTrainedModel,MusicgenForCausalLM:()=>t.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>t.MusicgenForConditionalGeneration,MusicgenModel:()=>t.MusicgenModel,MusicgenPreTrainedModel:()=>t.MusicgenPreTrainedModel,NeoBertForMaskedLM:()=>t.NeoBertForMaskedLM,NeoBertForQuestionAnswering:()=>t.NeoBertForQuestionAnswering,NeoBertForSequenceClassification:()=>t.NeoBertForSequenceClassification,NeoBertForTokenClassification:()=>t.NeoBertForTokenClassification,NeoBertModel:()=>t.NeoBertModel,NeoBertPreTrainedModel:()=>t.NeoBertPreTrainedModel,NllbTokenizer:()=>a.NllbTokenizer,NoBadWordsLogitsProcessor:()=>S.NoBadWordsLogitsProcessor,NoRepeatNGramLogitsProcessor:()=>S.NoRepeatNGramLogitsProcessor,NomicBertModel:()=>t.NomicBertModel,NomicBertPreTrainedModel:()=>t.NomicBertPreTrainedModel,NougatImageProcessor:()=>v.NougatImageProcessor,NougatTokenizer:()=>a.NougatTokenizer,OPTForCausalLM:()=>t.OPTForCausalLM,OPTModel:()=>t.OPTModel,OPTPreTrainedModel:()=>t.OPTPreTrainedModel,ObjectDetectionPipeline:()=>n.ObjectDetectionPipeline,Olmo2ForCausalLM:()=>t.Olmo2ForCausalLM,Olmo2Model:()=>t.Olmo2Model,Olmo2PreTrainedModel:()=>t.Olmo2PreTrainedModel,OlmoForCausalLM:()=>t.OlmoForCausalLM,OlmoModel:()=>t.OlmoModel,OlmoPreTrainedModel:()=>t.OlmoPreTrainedModel,OpenELMForCausalLM:()=>t.OpenELMForCausalLM,OpenELMModel:()=>t.OpenELMModel,OpenELMPreTrainedModel:()=>t.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>v.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>t.OwlViTForObjectDetection,OwlViTImageProcessor:()=>v.OwlViTImageProcessor,OwlViTModel:()=>t.OwlViTModel,OwlViTPreTrainedModel:()=>t.OwlViTPreTrainedModel,OwlViTProcessor:()=>T.OwlViTProcessor,Owlv2ForObjectDetection:()=>t.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>v.Owlv2ImageProcessor,Owlv2Model:()=>t.Owlv2Model,Owlv2PreTrainedModel:()=>t.Owlv2PreTrainedModel,PaliGemmaForConditionalGeneration:()=>t.PaliGemmaForConditionalGeneration,PaliGemmaPreTrainedModel:()=>t.PaliGemmaPreTrainedModel,PaliGemmaProcessor:()=>T.PaliGemmaProcessor,PatchTSMixerForPrediction:()=>t.PatchTSMixerForPrediction,PatchTSMixerModel:()=>t.PatchTSMixerModel,PatchTSMixerPreTrainedModel:()=>t.PatchTSMixerPreTrainedModel,PatchTSTForPrediction:()=>t.PatchTSTForPrediction,PatchTSTModel:()=>t.PatchTSTModel,PatchTSTPreTrainedModel:()=>t.PatchTSTPreTrainedModel,Phi3ForCausalLM:()=>t.Phi3ForCausalLM,Phi3Model:()=>t.Phi3Model,Phi3PreTrainedModel:()=>t.Phi3PreTrainedModel,Phi3VForCausalLM:()=>t.Phi3VForCausalLM,Phi3VImageProcessor:()=>v.Phi3VImageProcessor,Phi3VPreTrainedModel:()=>t.Phi3VPreTrainedModel,Phi3VProcessor:()=>T.Phi3VProcessor,PhiForCausalLM:()=>t.PhiForCausalLM,PhiModel:()=>t.PhiModel,PhiPreTrainedModel:()=>t.PhiPreTrainedModel,Pipeline:()=>n.Pipeline,PreTrainedModel:()=>t.PreTrainedModel,PreTrainedTokenizer:()=>a.PreTrainedTokenizer,PretrainedConfig:()=>i.PretrainedConfig,PretrainedMixin:()=>t.PretrainedMixin,Processor:()=>L.Processor,PvtForImageClassification:()=>t.PvtForImageClassification,PvtImageProcessor:()=>v.PvtImageProcessor,PvtModel:()=>t.PvtModel,PvtPreTrainedModel:()=>t.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>m.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>t.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>t.PyAnnoteModel,PyAnnotePreTrainedModel:()=>t.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>T.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>t.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>n.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>t.Qwen2ForCausalLM,Qwen2Model:()=>t.Qwen2Model,Qwen2PreTrainedModel:()=>t.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>a.Qwen2Tokenizer,Qwen2VLForConditionalGeneration:()=>t.Qwen2VLForConditionalGeneration,Qwen2VLImageProcessor:()=>v.Qwen2VLImageProcessor,Qwen2VLPreTrainedModel:()=>t.Qwen2VLPreTrainedModel,Qwen2VLProcessor:()=>T.Qwen2VLProcessor,Qwen3ForCausalLM:()=>t.Qwen3ForCausalLM,Qwen3Model:()=>t.Qwen3Model,Qwen3PreTrainedModel:()=>t.Qwen3PreTrainedModel,RFDetrForObjectDetection:()=>t.RFDetrForObjectDetection,RFDetrModel:()=>t.RFDetrModel,RFDetrObjectDetectionOutput:()=>t.RFDetrObjectDetectionOutput,RFDetrPreTrainedModel:()=>t.RFDetrPreTrainedModel,RTDetrForObjectDetection:()=>t.RTDetrForObjectDetection,RTDetrImageProcessor:()=>v.RTDetrImageProcessor,RTDetrModel:()=>t.RTDetrModel,RTDetrObjectDetectionOutput:()=>t.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>t.RTDetrPreTrainedModel,RTDetrV2ForObjectDetection:()=>t.RTDetrV2ForObjectDetection,RTDetrV2Model:()=>t.RTDetrV2Model,RTDetrV2ObjectDetectionOutput:()=>t.RTDetrV2ObjectDetectionOutput,RTDetrV2PreTrainedModel:()=>t.RTDetrV2PreTrainedModel,RawAudio:()=>l.RawAudio,RawImage:()=>u.RawImage,RawVideo:()=>d.RawVideo,RawVideoFrame:()=>d.RawVideoFrame,RepetitionPenaltyLogitsProcessor:()=>S.RepetitionPenaltyLogitsProcessor,ResNetForImageClassification:()=>t.ResNetForImageClassification,ResNetModel:()=>t.ResNetModel,ResNetPreTrainedModel:()=>t.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>t.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>t.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>t.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>t.RoFormerForTokenClassification,RoFormerModel:()=>t.RoFormerModel,RoFormerPreTrainedModel:()=>t.RoFormerPreTrainedModel,RoFormerTokenizer:()=>a.RoFormerTokenizer,RobertaForMaskedLM:()=>t.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>t.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>t.RobertaForSequenceClassification,RobertaForTokenClassification:()=>t.RobertaForTokenClassification,RobertaModel:()=>t.RobertaModel,RobertaPreTrainedModel:()=>t.RobertaPreTrainedModel,RobertaTokenizer:()=>a.RobertaTokenizer,SamImageProcessor:()=>v.SamImageProcessor,SamImageSegmentationOutput:()=>t.SamImageSegmentationOutput,SamModel:()=>t.SamModel,SamPreTrainedModel:()=>t.SamPreTrainedModel,SamProcessor:()=>T.SamProcessor,SapiensForDepthEstimation:()=>t.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>t.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>t.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>t.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>m.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>v.SegformerFeatureExtractor,SegformerForImageClassification:()=>t.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>t.SegformerForSemanticSegmentation,SegformerImageProcessor:()=>v.SegformerImageProcessor,SegformerModel:()=>t.SegformerModel,SegformerPreTrainedModel:()=>t.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>t.Seq2SeqLMOutput,SequenceClassifierOutput:()=>t.SequenceClassifierOutput,SiglipImageProcessor:()=>v.SiglipImageProcessor,SiglipModel:()=>t.SiglipModel,SiglipPreTrainedModel:()=>t.SiglipPreTrainedModel,SiglipTextModel:()=>t.SiglipTextModel,SiglipTokenizer:()=>a.SiglipTokenizer,SiglipVisionModel:()=>t.SiglipVisionModel,SmolLM3ForCausalLM:()=>t.SmolLM3ForCausalLM,SmolLM3Model:()=>t.SmolLM3Model,SmolLM3PreTrainedModel:()=>t.SmolLM3PreTrainedModel,SmolVLMForConditionalGeneration:()=>t.SmolVLMForConditionalGeneration,SmolVLMImageProcessor:()=>v.SmolVLMImageProcessor,SmolVLMProcessor:()=>T.SmolVLMProcessor,SnacDecoderModel:()=>t.SnacDecoderModel,SnacEncoderModel:()=>t.SnacEncoderModel,SnacFeatureExtractor:()=>m.SnacFeatureExtractor,SnacModel:()=>t.SnacModel,SnacPreTrainedModel:()=>t.SnacPreTrainedModel,SpeechT5FeatureExtractor:()=>m.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>t.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>t.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>t.SpeechT5HifiGan,SpeechT5Model:()=>t.SpeechT5Model,SpeechT5PreTrainedModel:()=>t.SpeechT5PreTrainedModel,SpeechT5Processor:()=>T.SpeechT5Processor,SpeechT5Tokenizer:()=>a.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>t.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>t.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>t.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>t.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>t.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>a.SqueezeBertTokenizer,StableLmForCausalLM:()=>t.StableLmForCausalLM,StableLmModel:()=>t.StableLmModel,StableLmPreTrainedModel:()=>t.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>t.Starcoder2ForCausalLM,Starcoder2Model:()=>t.Starcoder2Model,Starcoder2PreTrainedModel:()=>t.Starcoder2PreTrainedModel,StoppingCriteria:()=>P.StoppingCriteria,StoppingCriteriaList:()=>P.StoppingCriteriaList,StyleTextToSpeech2Model:()=>t.StyleTextToSpeech2Model,StyleTextToSpeech2PreTrainedModel:()=>t.StyleTextToSpeech2PreTrainedModel,SummarizationPipeline:()=>n.SummarizationPipeline,SuppressTokensAtBeginLogitsProcessor:()=>S.SuppressTokensAtBeginLogitsProcessor,Swin2SRForImageSuperResolution:()=>t.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>v.Swin2SRImageProcessor,Swin2SRModel:()=>t.Swin2SRModel,Swin2SRPreTrainedModel:()=>t.Swin2SRPreTrainedModel,SwinForImageClassification:()=>t.SwinForImageClassification,SwinForSemanticSegmentation:()=>t.SwinForSemanticSegmentation,SwinModel:()=>t.SwinModel,SwinPreTrainedModel:()=>t.SwinPreTrainedModel,T5ForConditionalGeneration:()=>t.T5ForConditionalGeneration,T5Model:()=>t.T5Model,T5PreTrainedModel:()=>t.T5PreTrainedModel,T5Tokenizer:()=>a.T5Tokenizer,TableTransformerForObjectDetection:()=>t.TableTransformerForObjectDetection,TableTransformerModel:()=>t.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>t.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>t.TableTransformerPreTrainedModel,TemperatureLogitsWarper:()=>S.TemperatureLogitsWarper,Tensor:()=>f.Tensor,Text2TextGenerationPipeline:()=>n.Text2TextGenerationPipeline,TextClassificationPipeline:()=>n.TextClassificationPipeline,TextGenerationPipeline:()=>n.TextGenerationPipeline,TextStreamer:()=>I.TextStreamer,TextToAudioPipeline:()=>n.TextToAudioPipeline,TokenClassificationPipeline:()=>n.TokenClassificationPipeline,TokenClassifierOutput:()=>t.TokenClassifierOutput,TokenizerModel:()=>a.TokenizerModel,TopKLogitsWarper:()=>S.TopKLogitsWarper,TopPLogitsWarper:()=>S.TopPLogitsWarper,TrOCRForCausalLM:()=>t.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>t.TrOCRPreTrainedModel,TranslationPipeline:()=>n.TranslationPipeline,UltravoxModel:()=>t.UltravoxModel,UltravoxPreTrainedModel:()=>t.UltravoxPreTrainedModel,UltravoxProcessor:()=>T.UltravoxProcessor,UniSpeechForCTC:()=>t.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>t.UniSpeechForSequenceClassification,UniSpeechModel:()=>t.UniSpeechModel,UniSpeechPreTrainedModel:()=>t.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>t.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>t.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>t.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>t.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>t.UniSpeechSatPreTrainedModel,VLChatProcessor:()=>T.VLChatProcessor,VLMImageProcessor:()=>v.VLMImageProcessor,VaultGemmaForCausalLM:()=>t.VaultGemmaForCausalLM,VaultGemmaModel:()=>t.VaultGemmaModel,VaultGemmaPreTrainedModel:()=>t.VaultGemmaPreTrainedModel,ViTFeatureExtractor:()=>v.ViTFeatureExtractor,ViTForImageClassification:()=>t.ViTForImageClassification,ViTImageProcessor:()=>v.ViTImageProcessor,ViTMAEModel:()=>t.ViTMAEModel,ViTMAEPreTrainedModel:()=>t.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>t.ViTMSNForImageClassification,ViTMSNModel:()=>t.ViTMSNModel,ViTMSNPreTrainedModel:()=>t.ViTMSNPreTrainedModel,ViTModel:()=>t.ViTModel,ViTPreTrainedModel:()=>t.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>t.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>t.VitMatteForImageMatting,VitMatteImageProcessor:()=>v.VitMatteImageProcessor,VitMattePreTrainedModel:()=>t.VitMattePreTrainedModel,VitPoseForPoseEstimation:()=>t.VitPoseForPoseEstimation,VitPoseImageProcessor:()=>v.VitPoseImageProcessor,VitPosePreTrainedModel:()=>t.VitPosePreTrainedModel,VitsModel:()=>t.VitsModel,VitsModelOutput:()=>t.VitsModelOutput,VitsPreTrainedModel:()=>t.VitsPreTrainedModel,VitsTokenizer:()=>a.VitsTokenizer,VoxtralForConditionalGeneration:()=>t.VoxtralForConditionalGeneration,VoxtralProcessor:()=>T.VoxtralProcessor,Wav2Vec2BertForCTC:()=>t.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>t.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>t.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>t.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>a.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>m.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>t.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>t.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>t.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>t.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>t.Wav2Vec2PreTrainedModel,Wav2Vec2Processor:()=>T.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>T.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>t.WavLMForAudioFrameClassification,WavLMForCTC:()=>t.WavLMForCTC,WavLMForSequenceClassification:()=>t.WavLMForSequenceClassification,WavLMForXVector:()=>t.WavLMForXVector,WavLMModel:()=>t.WavLMModel,WavLMPreTrainedModel:()=>t.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>m.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>t.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>t.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>m.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>t.WhisperForConditionalGeneration,WhisperModel:()=>t.WhisperModel,WhisperPreTrainedModel:()=>t.WhisperPreTrainedModel,WhisperProcessor:()=>T.WhisperProcessor,WhisperTextStreamer:()=>I.WhisperTextStreamer,WhisperTimeStampLogitsProcessor:()=>S.WhisperTimeStampLogitsProcessor,WhisperTokenizer:()=>a.WhisperTokenizer,XLMForQuestionAnswering:()=>t.XLMForQuestionAnswering,XLMForSequenceClassification:()=>t.XLMForSequenceClassification,XLMForTokenClassification:()=>t.XLMForTokenClassification,XLMModel:()=>t.XLMModel,XLMPreTrainedModel:()=>t.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>t.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>t.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>t.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>t.XLMRobertaForTokenClassification,XLMRobertaModel:()=>t.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>t.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>a.XLMRobertaTokenizer,XLMTokenizer:()=>a.XLMTokenizer,XLMWithLMHeadModel:()=>t.XLMWithLMHeadModel,XVectorOutput:()=>t.XVectorOutput,YolosFeatureExtractor:()=>v.YolosFeatureExtractor,YolosForObjectDetection:()=>t.YolosForObjectDetection,YolosImageProcessor:()=>v.YolosImageProcessor,YolosModel:()=>t.YolosModel,YolosObjectDetectionOutput:()=>t.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>t.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>n.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>n.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>n.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>n.ZeroShotObjectDetectionPipeline,bankers_round:()=>h.bankers_round,cat:()=>f.cat,cos_sim:()=>h.cos_sim,dot:()=>h.dot,dynamic_time_warping:()=>h.dynamic_time_warping,env:()=>e.env,full:()=>f.full,full_like:()=>f.full_like,getCacheShapes:()=>i.getCacheShapes,hamming:()=>l.hamming,hanning:()=>l.hanning,interpolate:()=>f.interpolate,interpolate_4d:()=>f.interpolate_4d,interpolate_data:()=>h.interpolate_data,is_chinese_char:()=>a.is_chinese_char,layer_norm:()=>f.layer_norm,load_image:()=>u.load_image,load_video:()=>d.load_video,log_softmax:()=>h.log_softmax,magnitude:()=>h.magnitude,matmul:()=>f.matmul,max:()=>h.max,mean:()=>f.mean,mean_pooling:()=>f.mean_pooling,medianFilter:()=>h.medianFilter,mel_filter_bank:()=>l.mel_filter_bank,min:()=>h.min,ones:()=>f.ones,ones_like:()=>f.ones_like,permute:()=>f.permute,permute_data:()=>h.permute_data,pipeline:()=>n.pipeline,quantize_embeddings:()=>f.quantize_embeddings,rand:()=>f.rand,read_audio:()=>l.read_audio,rfft:()=>f.rfft,round:()=>h.round,slice:()=>f.slice,softmax:()=>h.softmax,spectrogram:()=>l.spectrogram,stack:()=>f.stack,std_mean:()=>f.std_mean,topk:()=>f.topk,window_function:()=>l.window_function,zeros:()=>f.zeros,zeros_like:()=>f.zeros_like});var e=An("./src/env.js"),n=An("./src/pipelines.js"),t=An("./src/models.js"),a=An("./src/tokenizers.js"),i=An("./src/configs.js"),l=An("./src/utils/audio.js"),u=An("./src/utils/image.js"),d=An("./src/utils/video.js"),f=An("./src/utils/tensor.js"),h=An("./src/utils/maths.js"),_=An("./src/base/feature_extraction_utils.js"),m=An("./src/models/feature_extractors.js"),p=An("./src/models/auto/feature_extraction_auto.js"),y=An("./src/base/image_processors_utils.js"),v=An("./src/models/image_processors.js"),x=An("./src/models/auto/image_processing_auto.js"),L=An("./src/base/processing_utils.js"),T=An("./src/models/processors.js"),E=An("./src/models/auto/processing_auto.js"),I=An("./src/generation/streamers.js"),P=An("./src/generation/stopping_criteria.js"),S=An("./src/generation/logits_process.js")})();w.ASTFeatureExtractor;w.ASTForAudioClassification;w.ASTModel;w.ASTPreTrainedModel;w.AlbertForMaskedLM;w.AlbertForQuestionAnswering;w.AlbertForSequenceClassification;w.AlbertModel;w.AlbertPreTrainedModel;w.AlbertTokenizer;w.ArceeForCausalLM;w.ArceeModel;w.ArceePreTrainedModel;w.AudioClassificationPipeline;w.AutoConfig;w.AutoFeatureExtractor;w.AutoImageProcessor;var B$=w.AutoModel;w.AutoModelForAudioClassification;w.AutoModelForAudioFrameClassification;w.AutoModelForAudioTextToText;w.AutoModelForCTC;w.AutoModelForCausalLM;w.AutoModelForDepthEstimation;w.AutoModelForDocumentQuestionAnswering;w.AutoModelForImageClassification;w.AutoModelForImageFeatureExtraction;w.AutoModelForImageMatting;w.AutoModelForImageSegmentation;w.AutoModelForImageTextToText;w.AutoModelForImageToImage;w.AutoModelForMaskGeneration;w.AutoModelForMaskedLM;w.AutoModelForNormalEstimation;w.AutoModelForObjectDetection;w.AutoModelForPoseEstimation;w.AutoModelForQuestionAnswering;w.AutoModelForSemanticSegmentation;w.AutoModelForSeq2SeqLM;w.AutoModelForSequenceClassification;w.AutoModelForSpeechSeq2Seq;w.AutoModelForTextToSpectrogram;w.AutoModelForTextToWaveform;w.AutoModelForTokenClassification;w.AutoModelForUniversalSegmentation;w.AutoModelForVision2Seq;w.AutoModelForXVector;w.AutoModelForZeroShotObjectDetection;var j$=w.AutoProcessor;w.AutoTokenizer;w.AutomaticSpeechRecognitionPipeline;w.BackgroundRemovalPipeline;w.BartForConditionalGeneration;w.BartForSequenceClassification;w.BartModel;w.BartPretrainedModel;w.BartTokenizer;w.BaseModelOutput;w.BaseStreamer;w.BeitFeatureExtractor;w.BeitForImageClassification;w.BeitModel;w.BeitPreTrainedModel;w.BertForMaskedLM;w.BertForQuestionAnswering;w.BertForSequenceClassification;w.BertForTokenClassification;w.BertModel;w.BertPreTrainedModel;w.BertTokenizer;w.BitImageProcessor;w.BlenderbotForConditionalGeneration;w.BlenderbotModel;w.BlenderbotPreTrainedModel;w.BlenderbotSmallForConditionalGeneration;w.BlenderbotSmallModel;w.BlenderbotSmallPreTrainedModel;w.BlenderbotSmallTokenizer;w.BlenderbotTokenizer;w.BloomForCausalLM;w.BloomModel;w.BloomPreTrainedModel;w.BloomTokenizer;w.CLIPFeatureExtractor;w.CLIPImageProcessor;w.CLIPModel;w.CLIPPreTrainedModel;w.CLIPSegForImageSegmentation;w.CLIPSegModel;w.CLIPSegPreTrainedModel;w.CLIPTextModel;w.CLIPTextModelWithProjection;w.CLIPTokenizer;w.CLIPVisionModel;w.CLIPVisionModelWithProjection;w.CamembertForMaskedLM;w.CamembertForQuestionAnswering;w.CamembertForSequenceClassification;w.CamembertForTokenClassification;w.CamembertModel;w.CamembertPreTrainedModel;w.CamembertTokenizer;w.CausalLMOutput;w.CausalLMOutputWithPast;w.ChineseCLIPFeatureExtractor;w.ChineseCLIPModel;w.ChineseCLIPPreTrainedModel;w.ClapAudioModelWithProjection;w.ClapFeatureExtractor;w.ClapModel;w.ClapPreTrainedModel;w.ClapTextModelWithProjection;w.ClassifierFreeGuidanceLogitsProcessor;w.CodeGenForCausalLM;w.CodeGenModel;w.CodeGenPreTrainedModel;w.CodeGenTokenizer;w.CodeLlamaTokenizer;w.CohereForCausalLM;w.CohereModel;w.CoherePreTrainedModel;w.CohereTokenizer;w.ConvBertForMaskedLM;w.ConvBertForQuestionAnswering;w.ConvBertForSequenceClassification;w.ConvBertForTokenClassification;w.ConvBertModel;w.ConvBertPreTrainedModel;w.ConvBertTokenizer;w.ConvNextFeatureExtractor;w.ConvNextForImageClassification;w.ConvNextImageProcessor;w.ConvNextModel;w.ConvNextPreTrainedModel;w.ConvNextV2ForImageClassification;w.ConvNextV2Model;w.ConvNextV2PreTrainedModel;w.DFineForObjectDetection;w.DFineModel;w.DFinePreTrainedModel;w.DINOv3ConvNextModel;w.DINOv3ConvNextPreTrainedModel;w.DINOv3ViTImageProcessor;w.DINOv3ViTModel;w.DINOv3ViTPreTrainedModel;w.DPTFeatureExtractor;w.DPTForDepthEstimation;w.DPTImageProcessor;w.DPTModel;w.DPTPreTrainedModel;w.DacDecoderModel;w.DacDecoderOutput;w.DacEncoderModel;w.DacEncoderOutput;w.DacFeatureExtractor;w.DacModel;w.DacPreTrainedModel;w.DataTypeMap;w.DebertaForMaskedLM;w.DebertaForQuestionAnswering;w.DebertaForSequenceClassification;w.DebertaForTokenClassification;w.DebertaModel;w.DebertaPreTrainedModel;w.DebertaTokenizer;w.DebertaV2ForMaskedLM;w.DebertaV2ForQuestionAnswering;w.DebertaV2ForSequenceClassification;w.DebertaV2ForTokenClassification;w.DebertaV2Model;w.DebertaV2PreTrainedModel;w.DebertaV2Tokenizer;w.DecisionTransformerModel;w.DecisionTransformerPreTrainedModel;w.DeiTFeatureExtractor;w.DeiTForImageClassification;w.DeiTImageProcessor;w.DeiTModel;w.DeiTPreTrainedModel;w.DepthAnythingForDepthEstimation;w.DepthAnythingPreTrainedModel;w.DepthEstimationPipeline;w.DepthProForDepthEstimation;w.DepthProPreTrainedModel;w.DetrFeatureExtractor;w.DetrForObjectDetection;w.DetrForSegmentation;w.DetrImageProcessor;w.DetrModel;w.DetrObjectDetectionOutput;w.DetrPreTrainedModel;w.DetrSegmentationOutput;w.Dinov2ForImageClassification;w.Dinov2Model;w.Dinov2PreTrainedModel;w.Dinov2WithRegistersForImageClassification;w.Dinov2WithRegistersModel;w.Dinov2WithRegistersPreTrainedModel;w.DistilBertForMaskedLM;w.DistilBertForQuestionAnswering;w.DistilBertForSequenceClassification;w.DistilBertForTokenClassification;w.DistilBertModel;w.DistilBertPreTrainedModel;w.DistilBertTokenizer;w.DocumentQuestionAnsweringPipeline;w.DonutFeatureExtractor;w.DonutImageProcessor;w.DonutSwinModel;w.DonutSwinPreTrainedModel;w.EfficientNetForImageClassification;w.EfficientNetImageProcessor;w.EfficientNetModel;w.EfficientNetPreTrainedModel;w.ElectraForMaskedLM;w.ElectraForQuestionAnswering;w.ElectraForSequenceClassification;w.ElectraForTokenClassification;w.ElectraModel;w.ElectraPreTrainedModel;w.ElectraTokenizer;w.EncodecFeatureExtractor;w.EosTokenCriteria;w.Ernie4_5_ForCausalLM;w.Ernie4_5_Model;w.Ernie4_5_PretrainedModel;w.Ernie4_5_Tokenizer;w.EsmForMaskedLM;w.EsmForSequenceClassification;w.EsmForTokenClassification;w.EsmModel;w.EsmPreTrainedModel;w.EsmTokenizer;w.ExaoneForCausalLM;w.ExaoneModel;w.ExaonePreTrainedModel;w.FFT;w.FalconForCausalLM;w.FalconModel;w.FalconPreTrainedModel;w.FalconTokenizer;w.FastViTForImageClassification;w.FastViTModel;w.FastViTPreTrainedModel;w.FeatureExtractionPipeline;w.FeatureExtractor;w.FillMaskPipeline;w.Florence2ForConditionalGeneration;w.Florence2PreTrainedModel;w.Florence2Processor;w.ForcedBOSTokenLogitsProcessor;w.ForcedEOSTokenLogitsProcessor;w.GLPNFeatureExtractor;w.GLPNForDepthEstimation;w.GLPNModel;w.GLPNPreTrainedModel;w.GPT2LMHeadModel;w.GPT2Model;w.GPT2PreTrainedModel;w.GPT2Tokenizer;w.GPTBigCodeForCausalLM;w.GPTBigCodeModel;w.GPTBigCodePreTrainedModel;w.GPTJForCausalLM;w.GPTJModel;w.GPTJPreTrainedModel;w.GPTNeoForCausalLM;w.GPTNeoModel;w.GPTNeoPreTrainedModel;w.GPTNeoXForCausalLM;w.GPTNeoXModel;w.GPTNeoXPreTrainedModel;w.GPTNeoXTokenizer;w.Gemma2ForCausalLM;w.Gemma2Model;w.Gemma2PreTrainedModel;w.Gemma3ForCausalLM;w.Gemma3Model;w.Gemma3PreTrainedModel;w.Gemma3nAudioFeatureExtractor;w.Gemma3nForConditionalGeneration;w.Gemma3nPreTrainedModel;w.Gemma3nProcessor;w.GemmaForCausalLM;w.GemmaModel;w.GemmaPreTrainedModel;w.GemmaTokenizer;w.GlmForCausalLM;w.GlmModel;w.GlmPreTrainedModel;w.GraniteForCausalLM;w.GraniteModel;w.GranitePreTrainedModel;w.Grok1Tokenizer;w.GroundingDinoForObjectDetection;w.GroundingDinoImageProcessor;w.GroundingDinoPreTrainedModel;w.GroundingDinoProcessor;w.GroupViTModel;w.GroupViTPreTrainedModel;w.HeliumForCausalLM;w.HeliumModel;w.HeliumPreTrainedModel;w.HerbertTokenizer;w.HieraForImageClassification;w.HieraModel;w.HieraPreTrainedModel;w.HubertForCTC;w.HubertForSequenceClassification;w.HubertModel;w.HubertPreTrainedModel;w.IJepaForImageClassification;w.IJepaModel;w.IJepaPreTrainedModel;w.Idefics3ForConditionalGeneration;w.Idefics3ImageProcessor;w.Idefics3PreTrainedModel;w.Idefics3Processor;w.ImageClassificationPipeline;w.ImageFeatureExtractionPipeline;w.ImageFeatureExtractor;w.ImageMattingOutput;w.ImageProcessor;w.ImageSegmentationPipeline;w.ImageToImagePipeline;w.ImageToTextPipeline;w.InterruptableStoppingCriteria;w.JAISLMHeadModel;w.JAISModel;w.JAISPreTrainedModel;w.JinaCLIPImageProcessor;w.JinaCLIPModel;w.JinaCLIPPreTrainedModel;w.JinaCLIPProcessor;w.JinaCLIPTextModel;w.JinaCLIPVisionModel;w.Lfm2ForCausalLM;w.Lfm2Model;w.Lfm2PreTrainedModel;w.LiteWhisperForConditionalGeneration;w.Llama4ForCausalLM;w.Llama4PreTrainedModel;w.LlamaForCausalLM;w.LlamaModel;w.LlamaPreTrainedModel;w.LlamaTokenizer;w.LlavaForConditionalGeneration;w.LlavaOnevisionForConditionalGeneration;w.LlavaOnevisionImageProcessor;w.LlavaPreTrainedModel;w.LlavaProcessor;w.LlavaQwen2ForCausalLM;w.LogitsProcessor;w.LogitsProcessorList;w.LogitsWarper;w.LongT5ForConditionalGeneration;w.LongT5Model;w.LongT5PreTrainedModel;w.M2M100ForConditionalGeneration;w.M2M100Model;w.M2M100PreTrainedModel;w.M2M100Tokenizer;w.MBart50Tokenizer;w.MBartForCausalLM;w.MBartForConditionalGeneration;w.MBartForSequenceClassification;w.MBartModel;w.MBartPreTrainedModel;w.MBartTokenizer;w.MPNetForMaskedLM;w.MPNetForQuestionAnswering;w.MPNetForSequenceClassification;w.MPNetForTokenClassification;w.MPNetModel;w.MPNetPreTrainedModel;w.MPNetTokenizer;w.MT5ForConditionalGeneration;w.MT5Model;w.MT5PreTrainedModel;w.MarianMTModel;w.MarianModel;w.MarianPreTrainedModel;w.MarianTokenizer;w.Mask2FormerImageProcessor;w.MaskFormerFeatureExtractor;w.MaskFormerForInstanceSegmentation;w.MaskFormerImageProcessor;w.MaskFormerModel;w.MaskFormerPreTrainedModel;w.MaskedLMOutput;w.MaxLengthCriteria;w.Metric3DForDepthEstimation;w.Metric3DPreTrainedModel;w.Metric3Dv2ForDepthEstimation;w.Metric3Dv2PreTrainedModel;w.MgpstrForSceneTextRecognition;w.MgpstrModelOutput;w.MgpstrPreTrainedModel;w.MgpstrProcessor;w.MgpstrTokenizer;w.MimiDecoderModel;w.MimiDecoderOutput;w.MimiEncoderModel;w.MimiEncoderOutput;w.MimiModel;w.MimiPreTrainedModel;w.MinLengthLogitsProcessor;w.MinNewTokensLengthLogitsProcessor;w.MistralForCausalLM;w.MistralModel;w.MistralPreTrainedModel;w.MobileBertForMaskedLM;w.MobileBertForQuestionAnswering;w.MobileBertForSequenceClassification;w.MobileBertModel;w.MobileBertPreTrainedModel;w.MobileBertTokenizer;w.MobileLLMForCausalLM;w.MobileLLMModel;w.MobileLLMPreTrainedModel;w.MobileNetV1FeatureExtractor;w.MobileNetV1ForImageClassification;w.MobileNetV1ForSemanticSegmentation;w.MobileNetV1ImageProcessor;w.MobileNetV1Model;w.MobileNetV1PreTrainedModel;w.MobileNetV2FeatureExtractor;w.MobileNetV2ForImageClassification;w.MobileNetV2ForSemanticSegmentation;w.MobileNetV2ImageProcessor;w.MobileNetV2Model;w.MobileNetV2PreTrainedModel;w.MobileNetV3FeatureExtractor;w.MobileNetV3ForImageClassification;w.MobileNetV3ForSemanticSegmentation;w.MobileNetV3ImageProcessor;w.MobileNetV3Model;w.MobileNetV3PreTrainedModel;w.MobileNetV4FeatureExtractor;w.MobileNetV4ForImageClassification;w.MobileNetV4ForSemanticSegmentation;w.MobileNetV4ImageProcessor;w.MobileNetV4Model;w.MobileNetV4PreTrainedModel;w.MobileViTFeatureExtractor;w.MobileViTForImageClassification;w.MobileViTImageProcessor;w.MobileViTModel;w.MobileViTPreTrainedModel;w.MobileViTV2ForImageClassification;w.MobileViTV2Model;w.MobileViTV2PreTrainedModel;w.ModelOutput;w.ModernBertDecoderForCausalLM;w.ModernBertDecoderModel;w.ModernBertDecoderPreTrainedModel;w.ModernBertForMaskedLM;w.ModernBertForSequenceClassification;w.ModernBertForTokenClassification;w.ModernBertModel;w.ModernBertPreTrainedModel;w.Moondream1ForConditionalGeneration;w.MoonshineFeatureExtractor;w.MoonshineForConditionalGeneration;w.MoonshineModel;w.MoonshinePreTrainedModel;w.MoonshineProcessor;w.MptForCausalLM;w.MptModel;w.MptPreTrainedModel;w.MultiModalityCausalLM;w.MultiModalityPreTrainedModel;w.MusicgenForCausalLM;w.MusicgenForConditionalGeneration;w.MusicgenModel;w.MusicgenPreTrainedModel;w.NeoBertForMaskedLM;w.NeoBertForQuestionAnswering;w.NeoBertForSequenceClassification;w.NeoBertForTokenClassification;w.NeoBertModel;w.NeoBertPreTrainedModel;w.NllbTokenizer;w.NoBadWordsLogitsProcessor;w.NoRepeatNGramLogitsProcessor;w.NomicBertModel;w.NomicBertPreTrainedModel;w.NougatImageProcessor;w.NougatTokenizer;w.OPTForCausalLM;w.OPTModel;w.OPTPreTrainedModel;w.ObjectDetectionPipeline;w.Olmo2ForCausalLM;w.Olmo2Model;w.Olmo2PreTrainedModel;w.OlmoForCausalLM;w.OlmoModel;w.OlmoPreTrainedModel;w.OpenELMForCausalLM;w.OpenELMModel;w.OpenELMPreTrainedModel;w.OwlViTFeatureExtractor;w.OwlViTForObjectDetection;w.OwlViTImageProcessor;w.OwlViTModel;w.OwlViTPreTrainedModel;w.OwlViTProcessor;w.Owlv2ForObjectDetection;w.Owlv2ImageProcessor;w.Owlv2Model;w.Owlv2PreTrainedModel;w.PaliGemmaForConditionalGeneration;w.PaliGemmaPreTrainedModel;w.PaliGemmaProcessor;w.PatchTSMixerForPrediction;w.PatchTSMixerModel;w.PatchTSMixerPreTrainedModel;w.PatchTSTForPrediction;w.PatchTSTModel;w.PatchTSTPreTrainedModel;w.Phi3ForCausalLM;w.Phi3Model;w.Phi3PreTrainedModel;w.Phi3VForCausalLM;w.Phi3VImageProcessor;w.Phi3VPreTrainedModel;w.Phi3VProcessor;w.PhiForCausalLM;w.PhiModel;w.PhiPreTrainedModel;w.Pipeline;w.PreTrainedModel;w.PreTrainedTokenizer;w.PretrainedConfig;w.PretrainedMixin;w.Processor;w.PvtForImageClassification;w.PvtImageProcessor;w.PvtModel;w.PvtPreTrainedModel;w.PyAnnoteFeatureExtractor;w.PyAnnoteForAudioFrameClassification;w.PyAnnoteModel;w.PyAnnotePreTrainedModel;w.PyAnnoteProcessor;w.QuestionAnsweringModelOutput;w.QuestionAnsweringPipeline;w.Qwen2ForCausalLM;w.Qwen2Model;w.Qwen2PreTrainedModel;w.Qwen2Tokenizer;w.Qwen2VLForConditionalGeneration;w.Qwen2VLImageProcessor;w.Qwen2VLPreTrainedModel;w.Qwen2VLProcessor;w.Qwen3ForCausalLM;w.Qwen3Model;w.Qwen3PreTrainedModel;w.RFDetrForObjectDetection;w.RFDetrModel;w.RFDetrObjectDetectionOutput;w.RFDetrPreTrainedModel;w.RTDetrForObjectDetection;w.RTDetrImageProcessor;w.RTDetrModel;w.RTDetrObjectDetectionOutput;w.RTDetrPreTrainedModel;w.RTDetrV2ForObjectDetection;w.RTDetrV2Model;w.RTDetrV2ObjectDetectionOutput;w.RTDetrV2PreTrainedModel;w.RawAudio;var Y2=w.RawImage;w.RawVideo;w.RawVideoFrame;w.RepetitionPenaltyLogitsProcessor;w.ResNetForImageClassification;w.ResNetModel;w.ResNetPreTrainedModel;w.RoFormerForMaskedLM;w.RoFormerForQuestionAnswering;w.RoFormerForSequenceClassification;w.RoFormerForTokenClassification;w.RoFormerModel;w.RoFormerPreTrainedModel;w.RoFormerTokenizer;w.RobertaForMaskedLM;w.RobertaForQuestionAnswering;w.RobertaForSequenceClassification;w.RobertaForTokenClassification;w.RobertaModel;w.RobertaPreTrainedModel;w.RobertaTokenizer;w.SamImageProcessor;w.SamImageSegmentationOutput;w.SamModel;w.SamPreTrainedModel;w.SamProcessor;w.SapiensForDepthEstimation;w.SapiensForNormalEstimation;w.SapiensForSemanticSegmentation;w.SapiensPreTrainedModel;w.SeamlessM4TFeatureExtractor;w.SegformerFeatureExtractor;w.SegformerForImageClassification;w.SegformerForSemanticSegmentation;w.SegformerImageProcessor;w.SegformerModel;w.SegformerPreTrainedModel;w.Seq2SeqLMOutput;w.SequenceClassifierOutput;w.SiglipImageProcessor;w.SiglipModel;w.SiglipPreTrainedModel;w.SiglipTextModel;w.SiglipTokenizer;w.SiglipVisionModel;w.SmolLM3ForCausalLM;w.SmolLM3Model;w.SmolLM3PreTrainedModel;w.SmolVLMForConditionalGeneration;w.SmolVLMImageProcessor;w.SmolVLMProcessor;w.SnacDecoderModel;w.SnacEncoderModel;w.SnacFeatureExtractor;w.SnacModel;w.SnacPreTrainedModel;w.SpeechT5FeatureExtractor;w.SpeechT5ForSpeechToText;w.SpeechT5ForTextToSpeech;w.SpeechT5HifiGan;w.SpeechT5Model;w.SpeechT5PreTrainedModel;w.SpeechT5Processor;w.SpeechT5Tokenizer;w.SqueezeBertForMaskedLM;w.SqueezeBertForQuestionAnswering;w.SqueezeBertForSequenceClassification;w.SqueezeBertModel;w.SqueezeBertPreTrainedModel;w.SqueezeBertTokenizer;w.StableLmForCausalLM;w.StableLmModel;w.StableLmPreTrainedModel;w.Starcoder2ForCausalLM;w.Starcoder2Model;w.Starcoder2PreTrainedModel;w.StoppingCriteria;w.StoppingCriteriaList;w.StyleTextToSpeech2Model;w.StyleTextToSpeech2PreTrainedModel;w.SummarizationPipeline;w.SuppressTokensAtBeginLogitsProcessor;w.Swin2SRForImageSuperResolution;w.Swin2SRImageProcessor;w.Swin2SRModel;w.Swin2SRPreTrainedModel;w.SwinForImageClassification;w.SwinForSemanticSegmentation;w.SwinModel;w.SwinPreTrainedModel;w.T5ForConditionalGeneration;w.T5Model;w.T5PreTrainedModel;w.T5Tokenizer;w.TableTransformerForObjectDetection;w.TableTransformerModel;w.TableTransformerObjectDetectionOutput;w.TableTransformerPreTrainedModel;w.TemperatureLogitsWarper;w.Tensor;w.Text2TextGenerationPipeline;w.TextClassificationPipeline;w.TextGenerationPipeline;w.TextStreamer;w.TextToAudioPipeline;w.TokenClassificationPipeline;w.TokenClassifierOutput;w.TokenizerModel;w.TopKLogitsWarper;w.TopPLogitsWarper;w.TrOCRForCausalLM;w.TrOCRPreTrainedModel;w.TranslationPipeline;w.UltravoxModel;w.UltravoxPreTrainedModel;w.UltravoxProcessor;w.UniSpeechForCTC;w.UniSpeechForSequenceClassification;w.UniSpeechModel;w.UniSpeechPreTrainedModel;w.UniSpeechSatForAudioFrameClassification;w.UniSpeechSatForCTC;w.UniSpeechSatForSequenceClassification;w.UniSpeechSatModel;w.UniSpeechSatPreTrainedModel;w.VLChatProcessor;w.VLMImageProcessor;w.VaultGemmaForCausalLM;w.VaultGemmaModel;w.VaultGemmaPreTrainedModel;w.ViTFeatureExtractor;w.ViTForImageClassification;w.ViTImageProcessor;w.ViTMAEModel;w.ViTMAEPreTrainedModel;w.ViTMSNForImageClassification;w.ViTMSNModel;w.ViTMSNPreTrainedModel;w.ViTModel;w.ViTPreTrainedModel;w.VisionEncoderDecoderModel;w.VitMatteForImageMatting;w.VitMatteImageProcessor;w.VitMattePreTrainedModel;w.VitPoseForPoseEstimation;w.VitPoseImageProcessor;w.VitPosePreTrainedModel;w.VitsModel;w.VitsModelOutput;w.VitsPreTrainedModel;w.VitsTokenizer;w.VoxtralForConditionalGeneration;w.VoxtralProcessor;w.Wav2Vec2BertForCTC;w.Wav2Vec2BertForSequenceClassification;w.Wav2Vec2BertModel;w.Wav2Vec2BertPreTrainedModel;w.Wav2Vec2CTCTokenizer;w.Wav2Vec2FeatureExtractor;w.Wav2Vec2ForAudioFrameClassification;w.Wav2Vec2ForCTC;w.Wav2Vec2ForSequenceClassification;w.Wav2Vec2Model;w.Wav2Vec2PreTrainedModel;w.Wav2Vec2Processor;w.Wav2Vec2ProcessorWithLM;w.WavLMForAudioFrameClassification;w.WavLMForCTC;w.WavLMForSequenceClassification;w.WavLMForXVector;w.WavLMModel;w.WavLMPreTrainedModel;w.WeSpeakerFeatureExtractor;w.WeSpeakerResNetModel;w.WeSpeakerResNetPreTrainedModel;w.WhisperFeatureExtractor;w.WhisperForConditionalGeneration;w.WhisperModel;w.WhisperPreTrainedModel;w.WhisperProcessor;w.WhisperTextStreamer;w.WhisperTimeStampLogitsProcessor;w.WhisperTokenizer;w.XLMForQuestionAnswering;w.XLMForSequenceClassification;w.XLMForTokenClassification;w.XLMModel;w.XLMPreTrainedModel;w.XLMRobertaForMaskedLM;w.XLMRobertaForQuestionAnswering;w.XLMRobertaForSequenceClassification;w.XLMRobertaForTokenClassification;w.XLMRobertaModel;w.XLMRobertaPreTrainedModel;w.XLMRobertaTokenizer;w.XLMTokenizer;w.XLMWithLMHeadModel;w.XVectorOutput;w.YolosFeatureExtractor;w.YolosForObjectDetection;w.YolosImageProcessor;w.YolosModel;w.YolosObjectDetectionOutput;w.YolosPreTrainedModel;w.ZeroShotAudioClassificationPipeline;w.ZeroShotClassificationPipeline;w.ZeroShotImageClassificationPipeline;w.ZeroShotObjectDetectionPipeline;w.bankers_round;w.cat;w.cos_sim;w.dot;w.dynamic_time_warping;var F0=w.env;w.full;w.full_like;w.getCacheShapes;w.hamming;w.hanning;w.interpolate;w.interpolate_4d;w.interpolate_data;w.is_chinese_char;w.layer_norm;w.load_image;w.load_video;w.log_softmax;w.magnitude;w.matmul;w.max;w.mean;w.mean_pooling;w.medianFilter;w.mel_filter_bank;w.min;w.ones;w.ones_like;w.permute;w.permute_data;w.pipeline;w.quantize_embeddings;w.rand;w.read_audio;w.rfft;w.round;w.slice;w.softmax;w.spectrogram;w.stack;w.std_mean;w.topk;w.window_function;w.zeros;w.zeros_like;const g_="briaai/RMBG-1.4",js={model:null,processor:null,currentModelId:g_,initializing:!1};async function qS(){if(js.model&&js.processor)return!0;if(js.initializing){for(;js.initializing;)await new Promise(e=>setTimeout(e,100));return!!(js.model&&js.processor)}try{return js.initializing=!0,F0.allowLocalModels=!1,F0.backends?.onnx?.wasm&&(F0.backends.onnx.wasm.proxy=!0),js.model=await B$.from_pretrained(g_,{config:{model_type:"custom",is_encoder_decoder:!1,max_position_embeddings:0,"transformers.js_config":{}}}),js.processor=await j$.from_pretrained(g_,{config:{do_normalize:!0,do_pad:!1,do_rescale:!0,do_resize:!0,image_mean:[.5,.5,.5],feature_extractor_type:"ImageFeatureExtractor",image_std:[1,1,1],resample:2,rescale_factor:1/255,size:{width:1024,height:1024}}}),js.currentModelId=g_,!0}finally{js.initializing=!1}}async function QS(e){if(!js.model||!js.processor)throw new Error("Local model not initialized. Call initializeModel() first.");const n=await Y2.fromURL(URL.createObjectURL(e)),{pixel_values:t}=await js.processor(n),{output:a}=await js.model({input:t}),u=(await(await Y2.fromTensor(a[0].mul(255).to("uint8"))).resize(n.width,n.height)).data,d=document.createElement("canvas");d.width=n.width,d.height=n.height;const f=d.getContext("2d");if(!f)throw new Error("Could not get 2d context");f.drawImage(n.toCanvas(),0,0);const h=f.getImageData(0,0,n.width,n.height);for(let v=0;v<u.length;v++)h.data[4*v+3]=u[v];f.putImageData(h,0,0);const _=d.toDataURL("image/png"),m=document.createElement("canvas");m.width=n.width,m.height=n.height;const p=m.getContext("2d");if(p){const v=p.createImageData(n.width,n.height);for(let x=0;x<u.length;x++){const L=u[x];v.data[4*x]=L,v.data[4*x+1]=L,v.data[4*x+2]=L,v.data[4*x+3]=255}p.putImageData(v,0,0)}const y=m.toDataURL("image/png");return{processedDataUrl:_,maskDataUrl:y}}const N$=()=>{const e=Ce.useRef(null),{setOriginalFile:n,setOriginalPreview:t,setProcessedImage:a,setLoading:i,setError:l,mode:u}=D_(),d=O_(),{openSignIn:f}=ky(),{isSignedIn:h}=I_(),{getToken:_}=G1(),m=async p=>{const y=p.target.files?.[0];if(!y)return;if(u==="server"&&!h){f({});return}l(""),a(""),n(y);const v=new FileReader;v.onload=()=>t(v.result),v.readAsDataURL(y);try{if(i(!0),d("/result"),u==="local"){await qS();const{processedDataUrl:x}=await QS(y);a(x)}else{const x=new FormData;x.append("image",y);const L="https://your-backend-api-url.com",T=await _(),E={};T&&(E.Authorization=`Bearer ${T}`);const I=await fetch(`${L}/api/image/remove-bg`,{method:"POST",body:x,headers:E}),P=await I.json();if(!I.ok||!P.success)throw new Error(P.message||"Failed to process image");a(P.image)}}catch(x){console.error(x),l(x.message||"Upload failed")}finally{i(!1)}};return rt.jsxs("div",{className:"flex items-center justify-between max-sm:flex-col-reverse gap-y-10 px-4 mt-10 lg:px-44 sm:mt-20",children:[rt.jsxs("div",{children:[rt.jsxs("h1",{className:"text-4xl xl:text-5xl 2xl:text-6xl font-bold text-neutral-700 leading-tight",children:["Remove the ",rt.jsx("br",{className:"max-md:hidden"})," ",rt.jsx("span",{className:"bg-gradient-to-r from-violet-600 to-fuchsia-500 bg-clip-text text-transparent",children:"background"})," from ",rt.jsx("br",{className:"max-md:hidden"})," images for free."]}),rt.jsx("p",{className:"my-6 text-[15px] text-gray-500",children:h?"Our AI-powered tool makes it easy to remove backgrounds from your images in just a few clicks.":u==="local"?"Try our free local background removal tool that runs entirely in your browser. No sign-up required!":"Sign in to access our AI-powered background removal tool and process your images instantly."}),rt.jsxs("div",{children:[rt.jsx("input",{ref:e,type:"file",accept:"image/*",id:"upload1",hidden:!0,onChange:m}),rt.jsxs("label",{className:`inline-flex gap-3 px-8 py-3.5 rounded-full cursor-pointer m-auto hover:scale-105 transition-all duration-700 ${h||u==="local"?"bg-gradient-to-r from-violet-600 to-fuchsia-500":"bg-gray-400"}`,htmlFor:"upload1",children:[rt.jsx("img",{width:20,height:10,src:Xs.upload_btn_icon,alt:""}),rt.jsx("p",{className:"text-white text-sm",children:h?"Upload Your Image":u==="local"?"Try Free (Local)":"Sign in to Upload"})]})]})]}),rt.jsx("div",{className:"w-full max-w-md",children:rt.jsx("img",{src:Xs.header_img,alt:""})})]})},U$=()=>rt.jsxs("div",{className:"py-20",children:[rt.jsxs("h1",{className:"text-center text-2xl md:text-3xl lg:text-4xl mt-4 font-semibold bg-gradient-to-r from-gray-900 to-gray-400 bg-clip-text text-transparent",children:["Steps to remove background ",rt.jsx("br",{})," image in seconds"]}),rt.jsxs("div",{className:"flex items-start flex-wrap gap-4 mt-16 xl:mt-24 justify-center",children:[rt.jsxs("div",{className:"flex items-start gap-4 bg-white  drop-shadow-md p-7 pb-10 rounded hover:scale-105 transition-all duration-500 ",children:[rt.jsx("img",{className:"max-w-9",src:Xs.upload_icon,alt:""}),rt.jsxs("div",{children:[rt.jsx("p",{className:"text-xl font-medium",children:"Sign in and upload"}),rt.jsxs("p",{className:"text-sm text-neutral-500 mt-1",children:["Create your account and upload your image ",rt.jsx("br",{}),"to get started with background removal."]})]})]}),rt.jsxs("div",{className:"flex items-start gap-4 bg-white  drop-shadow-md p-7 pb-10 rounded hover:scale-105 transition-all duration-500 ",children:[rt.jsx("img",{className:"max-w-9",src:Xs.remove_bg_icon,alt:""}),rt.jsxs("div",{children:[rt.jsx("p",{className:"text-xl font-medium",children:"Remove background"}),rt.jsxs("p",{className:"text-sm text-neutral-500 mt-1",children:["Our AI processes your image instantly ",rt.jsx("br",{}),"removing the background automatically."]})]})]}),rt.jsxs("div",{className:"flex items-start gap-4 bg-white  drop-shadow-md p-7 pb-10 rounded hover:scale-105 transition-all duration-500 ",children:[rt.jsx("img",{className:"max-w-9",src:Xs.download_icon,alt:""}),rt.jsxs("div",{children:[rt.jsx("p",{className:"text-xl font-medium",children:"Download image"}),rt.jsxs("p",{className:"text-sm text-neutral-500 mt-1",children:["Download your processed image with ",rt.jsx("br",{}),"transparent background in PNG format."]})]})]})]})]}),V$=()=>{const[e,n]=We.useState(50),t=a=>{n(a.target.value)};return rt.jsxs("div",{className:"py-20 px-4",children:[rt.jsx("h1",{className:"mb-12 sm:mb-20 text-center text-2xl md:text-3xl lg:text-4xl mt-4 font-semibold bg-gradient-to-r from-gray-900 to-gray-400 bg-clip-text text-transparent",children:"Remove Background With High Quality and Accuracy"}),rt.jsxs("div",{className:"relative w-full max-w-3xl overflow-hidden m-auto mt-16 rounded-lg drop-shadow-lg",children:[rt.jsx("img",{src:Xs.image_w_bg,style:{clipPath:`inset(0 ${100.2-e}% 0 0)`},alt:""}),rt.jsx("img",{className:"absolute top-0 left-0 w-full h-full object-cover",src:Xs.image_wo_bg,style:{clipPath:`inset(0 0 0 ${e}%)`},alt:""}),rt.jsx("input",{className:"absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full z-10 slider",type:"range",min:"0",max:"100",value:e,onChange:t})]})]})},G$=()=>{const{setOriginalFile:e,setOriginalPreview:n,setProcessedImage:t,setLoading:a,setError:i,mode:l}=D_(),u=O_(),{openSignIn:d}=ky(),{isSignedIn:f}=I_(),{getToken:h}=G1(),_=async m=>{const p=m.target.files?.[0];if(!p)return;if(l==="server"&&!f){d({});return}i(""),t(""),e(p);const y=new FileReader;y.onload=()=>n(y.result),y.readAsDataURL(p);try{if(a(!0),u("/result"),l==="local"){await qS();const{processedDataUrl:v}=await QS(p);t(v)}else{const v=new FormData;v.append("image",p);const x="https://your-backend-api-url.com",L=await h(),T={};L&&(T.Authorization=`Bearer ${L}`);const E=await fetch(`${x}/api/image/remove-bg`,{method:"POST",body:v,headers:T}),I=await E.json();if(!E.ok||!I.success)throw new Error(I.message||"Failed to process image");t(I.image)}}catch(v){console.error(v),i(v.message||"Upload failed")}finally{a(!1)}};return rt.jsxs("div",{className:"pb-16",children:[rt.jsx("h1",{className:"text-center text-2xl md:text-3xl lg:text-4xl mt-4 font-semibold bg-gradient-to-r from-gray-900 to-gray-400 bg-clip-text text-transparent",children:"See the magic. Try now"}),rt.jsxs("div",{className:"text-center mb-24 mt-10",children:[rt.jsx("input",{type:"file",accept:"image/*",id:"upload2",hidden:!0,onChange:_}),rt.jsxs("label",{className:`inline-flex gap-3 px-8 py-3.5 rounded-full cursor-pointer m-auto hover:scale-105 transition-all duration-700 ${f||l==="local"?"bg-gradient-to-r from-violet-600 to-fuchsia-500":"bg-gray-400"}`,htmlFor:"upload2",children:[rt.jsx("img",{width:20,height:10,src:Xs.upload_btn_icon,alt:""}),rt.jsx("p",{className:"text-white text-sm",children:f?"Upload Your Image":l==="local"?"Upload Your Image (Local/Free)":"Sign in to Upload"})]})]})]})},W$=()=>rt.jsx(rt.Fragment,{children:rt.jsxs("div",{children:[rt.jsx(N$,{}),rt.jsx(U$,{}),rt.jsx(V$,{}),rt.jsx(G$,{})]})}),H$=()=>{const{originalPreview:e,processedImage:n,loading:t,setProcessedImage:a,error:i,mode:l}=D_(),u=O_(),{isSignedIn:d,isLoaded:f}=I_();Ce.useEffect(()=>{f&&l==="server"&&!d&&u("/")},[d,f,u,l]);const h=()=>{if(!n)return;const p=document.createElement("a");p.href=n,p.download="bg-removed.png",document.body.appendChild(p),p.click(),p.remove()},_=()=>{a(""),u("/")};if(!f)return rt.jsx("div",{className:"mx-4 my-3 lg:mx-44 mt-14 min-h-[75vh] flex items-center justify-center",children:rt.jsx("div",{className:"border-4 border-violet-600 rounded-full h-12 w-12 border-t-transparent animate-spin"})});if(l==="server"&&!d)return null;const m=t||!n&&!!e;return rt.jsx("div",{className:"mx-4 my-3 lg:mx-44 mt-14 min-h-[75vh]",children:rt.jsxs("div",{className:"bg-white rounded-lg px-8 py-6 drop-shadow-sm",children:[i&&rt.jsx("div",{className:"mb-4 p-3 text-sm text-red-700 bg-red-100 rounded",children:i}),rt.jsxs("div",{className:"flex flex-col sm:grid grid-cols-2 gap-8",children:[rt.jsxs("div",{children:[rt.jsx("p",{className:"font-semibold text-gray-600 md-2",children:"Original"}),e?rt.jsx("img",{className:"rounded-md",src:e,alt:"original"}):rt.jsx("div",{className:"rounded-md border-gray-300 h-full relative bg-layer overflow-hidden min-h-64 flex items-center justify-center text-gray-500",children:"No image selected. Go back and upload an image."})]}),rt.jsxs("div",{className:"flex flex-col",children:[rt.jsx("p",{className:"font-semibold text-gray-600 md-2",children:"Background Removed"}),rt.jsx("div",{className:"rounded-md border-gray-300 h-full relative bg-layer overflow-hidden",children:n?rt.jsx("img",{className:"w-full h-full object-contain",src:n,alt:"bg-removed"}):m?rt.jsx("div",{className:"absolute inset-0 flex items-center justify-center",children:rt.jsx("div",{className:"border-4 border-violet-600 rounded-full h-12 w-12 border-t-transparent animate-spin"})}):rt.jsx("div",{className:"absolute inset-0 flex items-center justify-center text-gray-500",children:"Result will appear here after processing."})})]})]}),rt.jsxs("div",{className:"flex justify-center sm:justify-end items-center flex-wrap gap-4 mt-6",children:[rt.jsx("button",{onClick:_,className:"px-8 py-2.5 text-violet-600 text-sm border border-violet-600 rounded-full hover:scale-105 transition-all duration-700",children:"Try another image"}),rt.jsx("button",{disabled:!n,onClick:h,className:"px-8 py-2.5 text-white text-sm bg-gradient-to-r from-violet-600 to-fuchsia-600 rounded-full hover:scale-105 transition-all duration-700 disabled:opacity-50 disabled:cursor-not-allowed",children:"Download image"})]})]})})},K$=()=>{const{openSignIn:e}=ky(),{isSignedIn:n,user:t}=I_(),{mode:a,setMode:i}=D_();return rt.jsxs("div",{className:"flex items-center justify-between mx-4 py-3 lg:mx-44",children:[rt.jsx(Ty,{to:"/",children:rt.jsx("img",{className:"w-32 sm:w-44",src:Xs.logo,alt:""})}),rt.jsxs("div",{className:"flex items-center gap-3",children:[rt.jsxs("div",{className:"flex items-center rounded-full bg-gray-100 p-1 border border-gray-200",children:[rt.jsx("button",{type:"button",onClick:()=>n&&i("server"),"aria-pressed":a==="server",disabled:!n,className:`px-3 py-1 text-xs sm:text-sm rounded-full transition-all whitespace-nowrap ${a==="server"&&n?"bg-gradient-to-r from-violet-600 to-fuchsia-500 text-white shadow":"text-gray-700 hover:bg-white"} ${n?"cursor-pointer":"cursor-not-allowed opacity-50"}`,title:n?"Server mode":"Sign in required for server mode",children:"Server"}),rt.jsxs("button",{type:"button",onClick:()=>i("local"),"aria-pressed":a==="local",title:"Local processing (free, no sign-up required)",className:`px-3 py-1 text-xs sm:text-sm rounded-full transition-all whitespace-nowrap cursor-pointer ${a==="local"?"bg-gradient-to-r from-violet-600 to-fuchsia-500 text-white shadow":"text-gray-700 hover:bg-white"}`,children:["Local ",rt.jsx("span",{className:"hidden sm:inline",children:"(free)"})]})]}),n?rt.jsx(gk,{}):rt.jsxs("button",{onClick:()=>e({}),className:"bg-zinc-800 text-white flex items-center gap-4 px-4 py-2 sm:px-8 sm:py-3 text-sm rounded-full cursor-pointer",children:["Get Started ",rt.jsx("img",{src:Xs.arrow_icon,alt:""})]})]})]})},q$=()=>rt.jsxs("div",{className:"flex items-center justify-between gap-4 px-4 lg:px-44 py-3",children:[rt.jsx("img",{width:150,src:Xs.logo,alt:""}),rt.jsx("p",{className:"flex-1  border-gray-400 pl-4 text-sm text-gray-500 max-sm:hidden",children:"Copyright @GreatStack.dev | All right reserved."}),rt.jsxs("div",{className:"flex gap-1",children:[rt.jsx("img",{src:Xs.facebook_icon,alt:""}),rt.jsx("img",{src:Xs.twitter_icon,alt:""}),rt.jsx("img",{src:Xs.google_plus_icon,alt:""})]})]}),Q$=()=>rt.jsxs("div",{className:"min-h-screen bg-slate-50",children:[rt.jsx(K$,{}),rt.jsxs(dP,{children:[rt.jsx(B0,{path:"/",element:rt.jsx(W$,{})}),rt.jsx(B0,{path:"/result",element:rt.jsx(H$,{})})]}),rt.jsx(q$,{})]}),X$="pk_test_ZmxlZXQtdHJvdXQtMzEuY2xlcmsuYWNjb3VudHMuZGV2JA";wC.createRoot(document.getElementById("root")).render(rt.jsx(IP,{children:rt.jsx(ox,{publishableKey:X$,children:rt.jsx(r3,{children:rt.jsx(Q$,{})})})}));
